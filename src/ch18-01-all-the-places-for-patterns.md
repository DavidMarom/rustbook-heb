## כל המקומות בהם ניתן להשתמש בתבניות

תבניות מופיעות במספר מקומות בראסט, וכבר עשיתם שימוש נרחב בהם מבלי לדעת זאת! סעיף זה ידון בכל המקומות בהם לתבניות יכול להיות תוקף.

### זרועות `match`

כפי שנידון בפרק 6, אנו משתמשים בתבניות בזרועות של ביטויי `match`. באופן פורמלי, ביטויי `match` מוגדרים באמצעות מילת-המפתח `match`, ערך עליו יש לבצע את ההתאמה, ולפחות זרוע התאמה אחת שמורכבת מתבנית וביטוי להרצה במידה והערך תואם את תבנית הזרוע, כמו למשל:

```text
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

לדוגמא, הינה ביטוי `match` מרשימה 6-5 שמבצע התאמה על ערך מטיפוס `Option<i32>` שבמשתנה `x`:

```rust,ignore
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

התבניות בביטוי `match` זה הן ה- `None` וה-`Some(i)` שבצד שמאל של כל חץ.

אחת הדרישות עבור ביטויי `match` היא שהם חייבים להיות *ממצים * במובן שכל האפשרויות של ערכים בביטוי ה- `match` חייבים להיות מובאים בחשבון. דרך אחת לוודא שכיסיתם את כל האפשרויות היא להכליל תבנית תופסת-כל עבור הזרוע האחרונה: למשל, שם משתנה שתואם כל ערך לעולם לא יוכל לא להיות מותאם וכך יכסה את כל האפשרויות שלא הותאמו בזרועות הקודמות.

התבנית `_` תותאם לכל דבר שהוא, אבל היא אף פעם לא נקשרת למשתנה, ולכן משתמשים בו לרוב בזרוע האחרונה בביטויי התאמה. התבנית `_` יכולה להיות שימושית, למשל, כאשר רוצים להתעלם מכל ערך שלא מצויין בפירוש. נדון בתבנית `_` ביתר פירוט בסעיף ["התעלמות מערכים בתבנית"]()<!-- ignore --> מאוחר יותר בפרק הנוכחי.

### ביטויי `if let` מותנים

בפרק 6 ראינו כיצד להשתמש בביטויי `if let` בעיקר כדרך מקוצרת לכתיבת ביטויי `match` בהם מתבצעת רק התאמה אחת. ביטוי `if let` יכול גם לכלול `else` מתאים שמכיל קוד להרצה במקרה שהתבנית ב-`else` לא מותאמת.

רשימה 18-1 מראה שניתן גם לערב ביטויי `if let`, `else
if`, ו- `else if let`. אפשרות זו משיגה גמישות רבה יותר ממה שביטוי `match` מציע, שכן בביטוי <0>match</0> ניתן לציין רק ערך אחד לצורך ההשואה מול התבניות. בנוסף, ראסט לא דורשת שהתנאים בסדרה של זרועות `if
let`, `else if`, `else if let` יהיו קשורים אחד אל השני.

הקוד ברשימה 18-1 קובע באיזה צבע יהיה הרקע בהתבסס על סדרת בדיקות של כמה תנאים. עבור דוגמא זו, יצרנו משתנים עם קידוד ישיר של ערכים שיכולים להתקבל מהמשתמש בתכנית אמיתית.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-01/src/main.rs}}
```


<span class="caption">רשימה 18-1: שילוב `if let`, `else if`, `else if let`, ו-`else`</span>

במידה והמשתמש מציין צבע מועדף, צבע זה יהיה הצבע של הרקע. אם לא מסופק צבע מועדף והיום יום שלישי, צבע הרקע יהיה ירוק. אחרת, אם המשתמש מציין את גילם כמחרוזת ואנחנו מצליחים לקרוא אותה בהצלחה כמספר, הצבע יהיה או סגול או כתום בתלות בערך של המספר. אם אף אחד מתנאים אלה מתקיים, צבע הרקע יהיה כחול.

בניות מותנות כאלה מאפשרות לנו לתמוך בדרישות מורכבות. עם הערכים המקודדים לעיל, דוגמא זו תדפיס `Using purple as the
background color`.

כפי שאתם רוצים, ביטוי `if let` יכול גם לבצע האפלה של משתנים באותה הדרך בה זרוע של ביטוי `match` יכולה לעשות זאת: השורה `if let Ok(age) = age` מגדירה משתנה מואפל חדש בשם `age` שמכיל את הערך הפנימי של הווריאנט `Ok`. משמעות הדבר היא שצריך למקם את התנאי `if age > 30` בתוך הבלוק: לא ניתן לשלב שני תנאים אלו לתנאי היחיד `if let Ok(age) = age && age > 30`. המשתנה המואפל `age` שאנו רוצים להשוות מול 30 אינו תקף עד שהמתחם החדש מתחיל בסוגר המסולסל.

החסרון שבשימוש בביטויי `if let` הוא שהקומפיילר לא בודק מיצוי של כל הערכים האפשריים, בעוד שעם ביטויי `match` הוא עושה זאת. לו השמטנו את בלוק ה- `else` האחרון, ובכך מפספסים טיפול בכמה מקרים, הקומפיילר לא היה מתריע על הפוטנציאל לבאג לוגי.

### לולאות מותנות עם `while let`

בדומה ל- `if let`, הלולאה המותנית `while let` מאפשרת ללולאת `while` לרוץ כל עוד מותאמת תבנית מסויימת. ברשימה 18-2 אנו מקודדים לולאת `while let` שמשתמשת בווקטור כמחסנית ומדפיסה את הערכים בווקטור בסדר הפוך לזה שבו הם הוכנסו.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-02/src/main.rs:here}}
```


<span class="caption">רשימה 18-2: שימוש בלולאת `while let` כדי להדפיס ערכים כל עוד `stack.pop()` מחזיר `Some`</span>

דוגמא זו מדפיסה 3, 2, ואז1. המתודה `pop` מוציאה את האלמנט האחרון מהווקטור ומחזירה `Some(value)`. אם הווקטור ריק, `pop` מחזירה `None`. לולאת ה- `while` ממשיכה בהרצת הקוד שבבלוק שלה כל עוד `pop` מחזירה `Some`. כאשר `pop` מחזירה `None`, הלולאה עוצרת. ניתן להשתמש בלולאת `while let` כדי להוציא את כל האלמנטים מהמחסנית.

### לולאות `for`

בלולאת `for`, הערך שמופיע מייד לאחר מילת המפתח `for` הוא תבנית. למשל, ב- `for x in y` ה- `x` הוא תבנית. רשימה 18-3 מדגימה כיצד להשתמש בתבנית כחלק מלולאת `for` על מנת לפרק מרצף.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-03/src/main.rs:here}}
```


<span class="caption">רשימה 18-3: שימוש בתבנית כחלק מלולאת `for` על מנת לפרק מרצף</span>

הקוד מרשימה 18-3 יפיק את הפלט הבא:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-03/output.txt}}
```

אנו מתאימים איטרטור באמצעות המתודה `enumerate` כדי להפיק ערך יחד עם האינדקס של הערך, ממוקמים בתוך מרצף. הערך הראשון שמופק הוא המרצף `(0, 'a')`. כאשר ערך זה מותאם מול התבנית `(index, value)`, המשתנה `index` יהיה `0` והמשתנה `value` יהיה `'a'`, והשורה הראשונה של הפלט תודפס.

### פקודות `let`

עד לפרק זה בספר, דיברנו מפורשות על שימושים בתבניות רק עם `match` ו- `if let`, אבל, למעשה, עשינו שימוש בתבניות גם במקומום אחרים, כולל בפקודות `let`. לדוגמא, התבוננו בהשמה פשוטה זו למשתנה באמצעות `let`:

```rust
let x = 5;
```

בכל פעם שעשיתם שימוש בפקודת `let` כמו זו בעצם עשיתם שימוש בתבנית, למרות שאולי לא הייתם מודעים לכך! בצורה יותר פורמלית, פקודת `let` נראית כך:

```text
let PATTERN = EXPRESSION;
```

בפקודות כמו `let x = 5;` עם שם משתנה בחלק של ה- `PATTERN`, שם המשתנה הוא למעשה תבנית פשוטה מאוד. ראסט משווה את הביטוי מול התבנית ומבצעת השנה עבור השמות שהיא מוצאת. כך, בדוגמא `let x = 5;`, שם המשתנה `x` הוא תבנית שמשמע "קשור למשנתה `x` את מה שמותאם." היות והשם `x` מהווה את התבנית כולה, תבנית זו מבטאת למעשה את ההוראה "קשור כל דבר למשתנה `x`, לא משנה מהו הערך."

כדי לראות יותר בבהירות את האספקטים של התאמת תבניות בפקודות `let`, התבוננו ברשימה 18-4, אשר משתמשת בתבנית עם `let` כדי לפרק מרצף.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-04/src/main.rs:here}}
```


<span class="caption">רשימה 18-4: שימוש בתבנית כדי לפרק מרצף וליצור שלושה משתנים בבת אחת</span>

כאן, אנו מתאימים מרצף מול התבנית. ראסט משווה את הערך `(1, 2, 3)` מול התבנית `(x, y, z)` ורואה שהערך מתאים לתבנית, ולכן ראסט קושרת את `1` ל- `x`, את `2` ל- `y`, ואת `3` ל- `z`. ניתן לחשוב על תבנית מרצף זו כעל שלוש תבניות שמוקננות לתוך תבנית יחידה.

אם מספר האלמנטים בתבנית לא תואם את מספר האלמנטים במרצף, הטיפוס כולו לא יותאם ונקבל שגיאת קומפילציה. למשל, רשימה 18-5 מראה ניסיון לפרק מרצף עם שלושה אלמנטים לתוך שני משתנים, וזה לא עובד.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-05/src/main.rs:here}}
```


<span class="caption">רשימה 18-5: פירוק לא תקין של תבנית בה מספר המשתנים לא תואם את מספר האלמנטים במרצף</span>

ניסון לקמפל קוד זה יוביל לשגיאה הבאה:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-05/output.txt}}
```

על מנת לתקן את הבעיה, נוכל להתעלם מאחד, או יותר, מהערכים במרצף על-ידי שימוש ב-`_` או ב- `..`, כפי ניתן לראות בסעיף ["התעלמות מערכים בתבנית"]()<!-- ignore --> . אם הבעיה היא שיש לנו יותר מידי ערכים בתבנית, הפתרון הוא לוודא שהטיפוסים מתאימים על-ידי הסרת משתנים כך שמספר המתשנים יהיה שווה למספר האלמנטים במרצף.

### פרמטרים לפונקציות

פרמטרים לפונקציות יכולים גם הם להיות תבניות. הקוד ברשימה 18-6, שמצהיר על פונקציה בשם `foo` שמקבלת פרמטר אחד בשם `x` מטיפוס `i32`, צהיר להיות לכם מוכר.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-06/src/main.rs:here}}
```


<span class="caption">רשימה 18-6: חותם פונקציה שמשתמש בתבנית ברשימת הפרמטרים</span>

ה- `x` הוא תבנית! כפי שעשינו עם `let`, ניתן להתאים מרצף בארגומנט של פונקציה מול תבנית. רשימה 18-7 מפצלת את הערכים במרצף בעודם מועברים לפונקציה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-07/src/main.rs}}
```


<span class="caption">רשימה 18-7: פונקציה עם פרמטרים שמפרקים מרצף</span>

קוד זה מדפיס `Current location: (3, 5)`. הערכים `&(3, 5)` מתאימים לתבנית `&(x, y)`, ולכן `x` מקבל את הערך `3` ו- `y` את הערך `5`.

ניתן גם להשתמש בתבניות ברשימת הפרמטרים של סגור באותה הדרך כמו ברשימת הפרמטרים של פונקציה, כיוון שסגורים דומים לפונקציות, כפי שנידון בפרק 13.

בנקודה זה, ראיתם כמה דרכים להשתמש בתבניות, אבל תבניות לא עובדות באותה הדרך בכל מקום בו ניתן להשתמש בהן. במקומות מסויימים על התבניות להיות לא ניתנון להפרכה; בנסיבות אחרות, הן יכולות להיות ניתנות להפרכה. שני מושגים אלה הם נושאי המשך הדיון.
ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern
