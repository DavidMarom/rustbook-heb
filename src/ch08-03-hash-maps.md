## אחסון מפתחות וערכים משויכים במפות גיבוב

האחרון מבין האוספים הנפוצים שלנו הוא _מפת הגיבוב_. הטיפוס `HashMap<K, V>` מאחסן מיפוי של מפתחות מסוג `K` לערכים מסוג `V` באמצעות _פונקציית גיבוב_, שקובעת כיצד יוצבו המפתחות ביחס לערכים הללו בזיכרון. שפות תכנות רבות תומכות במבנה נתונים מסוג זה, אך לעיתים קרובות הוא מופיע בשם אחר, כגון גיבוב, מפה, אובייקט, טבלת גיבוב, מילון, מערך אסוציאטיבי, או שלל מונחים.

מפות גיבוב שימושיות כאשר אתה רוצה לאתר נתונים שלא באמצעות אינדקס, כמו במקרה של וקטורים, אלא באמצעות מפתח שיכול להיות מכל טיפוס שהוא. במשחק כלשהו, לדוגמה, אתה יכול לעקוב אחר הניקוד של כל קבוצה באמצעות מפת גיבוב בה כל מפתח הוא שם הקבוצה, והערכים הם הניקוד של כל קבוצה. בהינתן שם קבוצה, אתה יכול לאחזר בקלות את הניקוד שלה.

בסעיף זה נעבור על ה-API הבסיסי של מפות גיבוב, אבל דברים טובים אחרים מסתתרים בפונקציות המוגדרות ב-'HashMap<K,V>' על-ידי הספרייה הסטנדרטית. כמו תמיד, לקבלת מידע נוסף, עיין בתיעוד הספרייה הסטנדרטית.

### יצירת מפת גיבוב חדשה

אחת הדרכים ליצור מפת גיבוב ריקה היא שימוש במילת המפתח 'new' והוספת פריטים אליה עם 'insert'. ברשימה 8-20 אנו עוקבים אחר התוצאות של שתי קבוצות ששמותיהן _כחול_ ו*צהוב*. הקבוצה הכחולה פותחת עם 10 נקודות, והצהובה פותחת עם 50.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
```

<span class="caption">רשימה 8-20: יצירת מפת גיבוב חדשה והכנסת מפתחות וערכים</span>

שים לב שעלינו קודם להשתמש במילת המפתח 'use' ל-'HashMap', מקטגורית האוספים של הספרייה הסטנדרטית. מבין שלושת האוספים הנפוצים שלנו, מפת הגיבוב לא נמצאת בשימוש תדיר, כך שהיא אינה נכללת במתחם באופן אוטומטי חלק מן הפרליוד. למפות גיבוב מוענקת תמיכה מופחתת מהספרייה הסטנדרטית; לא קיים מאקרו מובנה כדי לאתחל אחת, למשל.

בדיוק כמו וקטורים, מפות גיבוב מאחסנות את הנתונים שלהן בזיכרון הערימה. ל-`HashMap` המסוים הזה מפתחות מסוג `String` וערכים מסוג `i32`. בדומה לווקטורים, מפות גיבוב הן הומוגניות: המפתחות כולם חייבים מאותו הטיפוס, והערכים כולם חייבים להיות מאותו הטיפוס.

### גישה לערכים במפת גיבוב

נוכל לגשת לערך במפת הגיבוב באמצעות העברת המפתח שלה למתודה `get`, כפי שמוצגה רשימה8-21.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
```

<span class="caption">רשימה 8-21: גישה לניקוד של הצוות הכחול המאוחסן במפת הגיבוב</span>

כאן, ל-'score' יועתק הערך המשויך לצוות הכחול, והתוצאה תהיה '10'. המתודה `get` מחזירה `Option<&V>`; אם מפת הגיבוב אינו מכילה ערך התואם למפתח זה, המתודה 'get' תחזיר 'None'. תוכנית זו מטפלת ב-'Option' על ידי קריאה למתודה 'copied' כדי לקבל 'Option<i32>' במקום 'Option<&i32>'. אז, קוראים למתודה 'unwrap_or' בכדי להגדיר את 'score' כ-0 cבמקרה שלמפה `scores` אין ערך התואם למפתח שהועבר.

אנו יכולים לעבור על כל צמד מפתח-ערך במפת גיבוב כפי שאנו עושים עם וקטורים, באמצעות לולאת `for`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
```

קוד זה ידפיס כל צמד בסדר שרירותי:

```text
Yellow: 50
Blue: 10
```

### מפות גיבוב ובעלות

עבור טיפוסים המיישמים את התכונה 'copy', כמו 'i32', הערכים מועתקים למפת הגיבוב. עם זאת, עבור ערכים שנמצאים בבעלות, כגון הטיפוס `String`, הערכים יוזזו, ומפת הגיבוב תהפוך לבעלים של הערכים הללו, כפי שמדגימה רשימה 8-22.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
```

<span class="caption">רשימה 8-22: מפתחות וערכים נמצאים בבעלות מפת הגיבוב לאחר הכנסתם אליה</span>

הקריאה למתודה `add` מעבירה את הבעלות על המשתנים `field_name` ו-`field_value` למפת הגיבוב, ולכן אין אנו יכולים להשתמש במשתנים אלה יותר.

כלומר, אם נכניס למפת הגיבוב הפניות לערכים, הערכים לא יועברו למפת הגיבוב. הערכים שההפניות מצביעות עליהם חייבים להיות תקפים לפחות כל עוד מפת הגיבוב תקפה. נדבר יותר על הבעיות הללו בפרק 10, בסעיף [“Validating References with Lifetimes”][validating-references-with-lifetimes]<!-- ignore -->

### עדכון מפת גיבוב

ניתן להגדיל את מספר צמדי המפתח והערכים במפת הגיבוב ללא הגבלה. עם זאת, בכל זמן נתון, לכל מפתח יחודי יכול להיות רק ערך אחד המשויך אליו. (אך יש לציין, לא להיפך: לדוגמה, גם לצוות הכחול וגם לצוות הצהוב יכול להיות ערך 10 מאוחסן ב- מפת הגיבוב `scores`).

כאשר ברצונך לשנות או לעדכן את הנתונים במפת הגיבוב עבור מפתח נתון, עלינו להחליט כיצד לטפל במקרה בו למפתח קיים כבר ערך. אנו יכולים, למשל, להחליף את הערך הישן בערך החדש, תוך התעלמות מוחלטת מהערך הישן; אנו יכולים לשמור את הערך הישן ולהתעלם מהערך החדש, ולהוסיף את הערך החדש רק אם למפתח _אין_ כבר ערך; או שאנו יכולים לשלב את הערך הישן והערך החדש באופן כזה או אחר. בואו נראה איך לעשות כל אחד מאלה!

#### החלפת ערך

אם נכניס מפתח וערך למפת גיבוב, ואז נכניס את אותו המפתח בשנית עם ערך אחר, יוחלף הערך הקיים לאותו המפתח. למרות שהקוד ברישום 8-23 קורא ל-'add' פעמיים, מפת הגיבוב תכיל רק צמד מפתח-ערך אחד, כיוון שבשתי הפעמים אנו מכניסים את הערך למפתח של הצוות הכחול.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
```

<span class="caption">רשימה 8-23: החלפת ערך קיים עבור מפתח נתון</span>

קוד זה ידפיס `{"Blue": 25}`; הערך המקורי, '10', הוחלף.

<!-- Old headings. Do not remove or links may break. -->

<a id="only-inserting-a-value-if-the-key-has-no-value"></a>

#### הוספת מפתח וערך רק אם המפתח אינו קיים במפה

נוהג מקובל הוא לבדוק אם מפתח מסוים כבר קיים במפת הגיבוב, ולבצע את הפעולות הבאות: אם המפתח אכן קיים במפת הגיבוב, אין לבצע אף שינוי בערך הקיים; אם המפתח אינו קיים, הכנס אותו ואת הערך המשויך אליו.

למפות גיבוב קיים API מיוחד לזה למטרה זו בשם `entry`, שמקבל כפרמטר את המפתח שברצונכם לבדוק. ערך ההחזרה של מתודת ה-'entry' הוא מבחר בשם 'Entry' שמייצג ערך שייתכן וקיים. נניח שאנו רוצים לבדוק האם למפתח של הצוות הצהוב יש ערך משויך. אם לא, אנחנו רוצים להכניס את הערך 50, ואותו הדבר עבור הצוות הכחול. בשימוש ה-API של 'entry', הקוד יראה כדוגמת רשימה 8-24.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
```

<span class="caption">רשימה 8-24: שימוש במתודה `entry` להוספה רק אם למפתח לא קיים ערך</span>

כאשר היא מופעלת על מבחר מטיפוס `Entry`, המתודה `or_insert` מוגדרת כמחזירה הפניה ברת-שינוי לערך המשויך למפתח של אותו ה-`Entry`, אם קיים. אם לא, המתודה תכניס את הפרמטר שהועבר לה כערך החדש המשויך למפתח זה, ותחזיר הפניה ברת-שינוי לערך החדש. טכניקה זו נקייה הרבה יותר מאשר כתיבת ההיגיון בעצמנו, ואף עובדת טוב יותר עם בודק ההשאלה.

הקוד ברשימה 8-24 ידפיס `{"Yellow": 50, "Blue": 10}`. הקריאה הראשונה ל-'entry' תכניס את המפתח לצוות הצהוב עם הערך 50, כי לצוות הצהוב אין ערך קיים. עם זאת, הקריאה השנייה ל-'entry' לא תשנה את מפת הגיבוב מכיוון שהערך `10` כבר קיים עבור הצוות הכחול.

#### עדכון ערך בהתבסס על הערך הישן

מקרה נפוץ נוסף עבור מפות גיבוב הוא הצורך לאתר ערך של מפתח נתון, ולאחר מכן לעדכן אותו בהתבסס על הערך הישן. לדוגמה, רשימה 8-25 מציגה קוד שסופר כמה פעמים כל מילה מופיעה בטקסט נתון. אנו משתמשים במפת גיבוב עם המילים כמפתחות, ומגדילים את הערך המשויך לכל מילה בכדי לספור כמה פעמים ראינו אותה. אם זו הפעם הראשונה שאנו רואים מילה, נכניס עבורה את הערך 0.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
```

<span class="caption">רשימה 8-25: ספירת מופעים של מילים באמצעות מפת גיבוב המאחסנת מילים וספירה עבורן</span>

קוד זה ידפיס `{"world": 2, "hello": 1, "wonderful": 1}`. יתכן שתראו את אותם צמדי מפתח-ערך מודפסים בסדר שונה: זכרו מהסעיף [“Accessing Values in a Hash Map”][access]<!-- ignore --> שאיטרציה על מפת Hash מתרחשת בסדר שרירותי.

שיטת `split_whitespace` מחזירה איטרטור על תת-חיתוכים, מופרדות בתו רווח-לבן (whitespace), של הערך המאוחסן במשתנה `text`. המתודה `or_insert` מחזירה הפניה ברת-שינוי (`&mut V`) לערך המשויך למפתח שצוין. כאן אנו מאחסנים את ההפניה ברת-השינוי במשתנה `count`. כעת, כדי לעדכן ערך זה, עלינו תחילה לבצע דה-הפניה באמצעות אופרטור הכוכבית (`*`). ההפניה ברת-השינוי יוצאת מהמתחם בסוף לולאת ה-'for', כך שכל השינויים הללו בטוחים ומותרים על פי כללי ההשאלה.

### פונקציות גיבוב

כברירת מחדל, `HashMap` מסתמכת על פונקצית גיבוב בשם _SipHash_ שמעניקה הגנה מפני מתקפות מניעת שירות (DoS) המערבות טבלאות גיבוב[^siphash]<!-- ignore -->. זה אמנם לא אלגוריתם הגיבוב המהיר ביותר בנמצא, אך בתמורה לירידה בביצועים, מקבלים אבטחת נתונים טובה יותר. אם תבדקו את הקוד שלכם ותגלו שפונקציית הגיבוב המוגדרת כברירת-המחדל איטית מדי עבורכם, תוכלו לעבור לפונקציה אחרת על ידי ציון מגבב אחר. מגבב - _hasher_ - הוא טיפוס שמיישם את התכונה 'BuildHasher'. נדבר על תכונות וכיצד ליישם אותן בפרק 10. לא מן ההכרח שתידרדשו לממש את פונקצית הגיבוב שלכם שלך מאפס; קיימות ספריות רבות המספקות מימושי אלגוריתמי גיבוב נפוצים רבים. תוכלו למצוא אותן ב- [crates.io](https://crates.io/)<!-- ignore -->
[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)

## סיכום

וקטורים, מחרוזות ומפות גיבוב מעניקות רבות מן הפונקציונליות הדרושה לאחסון, לגישה, ועדכון נתונים. כעת יש לכם את כל הכלים הדרושים בכדי לפתור את התרגילים הבאים:

- בהינתן רשימה של מספרים שלמים, השתמש בווקטור בכדי להחזיר את החציון (באוסף ממוין, זהו הערך במיקום האמצעי), ואת השכיח (הערך המופיע בתדירות הגבוהה ביותר; מפת גיבוב תעזור כאן).
- המרת מחרוזות לפיג לטין (Pig Latin): העיצור הראשון של כל מילה יועבר לסוף המילה, ולאחר תתווסף התנועה "ay", כך שהמילה "first" תהפוך ל-”irst-fay”. עבור מילים שמתחילות בתנועה, יתווסף "hay" לסוף המילה ("apple" תהפוך כך ל-"apple-hay"). זכרו את מה שלמדתם אודות קידוד UTF-8!
- באמצעות מפת גיבוב ו-וקטורים, צרו ממשק טקסט שיאפשר למשתמש להוסיף שמות עובדים למחלקה בחברה. לדוגמה “,Add Sally to Engineering” או “Add Amir to Sales.” לאחר מכן, אפשר למשתמש לאחזר רשימה של כל האנשים במחלקה או כל האנשים בחברה לפי מחלקה, ממוינת בסדר אלפביתי.

תיעוד ה-API של הספרייה הסטנדרטית כולל שיטות המשויכות לווקטורים, למחרוזות ולמפות גיבוב שיעזרו לכם.

אנחנו מגיעים כעת לדון בתוכניות מורכבות יותר, בהן פעולות עלולות להיכשל. זהו, אפוא,הזמן המושלם לדון בטיפול בשגיאות. נעשה זאת בפרק הבא!
[validating-references-with-lifetimes]:
ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[access]: #accessing-values-in-a-hash-map
