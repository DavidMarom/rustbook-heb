## אחסון מפתחות עם ערכים משויכים במפות גיבוב

האחרון מבין האוספים הנפוצים שלנו הוא _מפת הגיבוב_. הטיפוס `HashMap<K, V>` מאחסן מיפוי של מפתחות מטיפוס `K` לערכים מטיפוס `V` באמצעות _פונקציית גיבוב_, שקובעת כיצד יוצבו המפתחות ביחס לערכים הללו בזיכרון. שפות תכנות רבות תומכות במבנה נתונים מסוג זה, אך לעיתים קרובות הוא מופיע בשם אחר, כגון גיבוב, מפה, אובייקט, טבלת גיבוב, מילון, מערך אסוציאטיבי, או כל מונח דומה.

מפות גיבוב שימושיות כאשר אתה רוצה לגשת לנתונים שלא באמצעות אינדקס, כמו במקרה של וקטורים, אלא באמצעות מפתח שיכול להיות מכל טיפוס שהוא. אם, לדוגמה, יש לנו משחק כלשהו, אנו יכולים לעקוב אחר הניקוד של כל קבוצה באמצעות מפת גיבוב בה כל מפתח הוא שם הקבוצה, והערכים הם הניקוד שלהן. בהינתן שם קבוצה, אתה יכול לאחזר בקלות את הניקוד שלה.

בסעיף זה נעבור על ה-API הבסיסי של מפות גיבוב, אבל דברים טובים רבים אחרים מסתתרים במתודות המוגדרות על '<HashMap<K,V' על-ידי הספרייה הסטנדרטית. כמו תמיד, למידע נוסף, עיין בתיעוד הספרייה הסטנדרטית.

### יצירת מפת גיבוב חדשה

אחת הדרכים ליצור מפת גיבוב ריקה היא שימוש במילת המפתח 'new' והוספת פריטים אליה עם 'insert'. ברשימה 8-20 אנו עוקבים אחר התוצאות של שתי קבוצות ששמותיהן _כחול_ ו*צהוב*. הקבוצה הכחולה פותחת עם 10 נקודות, והצהובה פותחת עם 50.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
```

<span class="caption">רשימה 8-20: יצירת מפת גיבוב חדשה והכנסת מפתחות וערכים</span>

שימו לב שעלינו קודם להשתמש במילת המפתח 'use' להכנסת ה-'HashMap' למתחם מקטגוריית האוספים של הספרייה הסטנדרטית. מבין שלושת האוספים הנפוצים שלנו, מפת הגיבוב לא נמצאת בשימוש תדיר, כך שהיא אינה נכללת במתחם באופן אוטומטי, כחלק מן הפרליוד. הספרייה הסטנדרטית מעניקה למפות גיבוב תמיכה מופחתת; לא קיים מאקרו מובנה כדי לאתחל אחת, למשל.

בדיוק כמו וקטורים, מפות גיבוב מאחסנות את הנתונים שלהן בזיכרון הערימה. ל-`HashMap` המסוים הזה מפתחות מסוג `String` וערכים מסוג `i32`. בדומה לוקטורים, מפות גיבוב הן הומוגניות: המפתחות כולם חייבים להיות מאותו הטיפוס, והערכים כולם חייבים להיות מאותו הטיפוס.

### גישה לערכים במפת גיבוב

נוכל לגשת לערך במפת הגיבוב באמצעות העברת המפתח שלה למתודה `get`, כפי שמציגה רשימה8-21.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
```

<span class="caption">רשימה 8-21: גישה לניקוד של הצוות הכחול המאוחסן במפת הגיבוב</span>

כאן, ל-'score' יועתק הערך המשויך לצוות הכחול, והתוצאה תהיה '10'. המתודה `get` מחזירה `Option<&V>`; אם מפת הגיבוב אינו מכילה ערך התואם למפתח זה, המתודה 'get' תחזיר 'None'. תוכנית זו מטפלת ב-'Option' על-ידי קריאה למתודה 'copied' כדי לקבל '<Option<i32' במקום '<Option<&i32'. אז, נקרא למתודה 'unwrap_or' בכדי להגדיר את 'score' כ-0 במקרה שלמפה `scores` אין ערך התואם למפתח שהועבר.

אנו יכולים לעבור על כל צמד מפתח-ערך במפת גיבוב כפי שאנו עושים עם וקטורים, באמצעות לולאת `for`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
```

קוד זה ידפיס כל צמד בסדר שרירותי:

```text
Yellow: 50
Blue: 10
```

### מפות גיבוב ובעלות

עבור טיפוסים המיישמים את התכונה 'copy', כפי שעושה 'i32', הערכים מועתקים למפת הגיבוב. עם זאת, עבור ערכים שנמצאים בבעלות, כגון הטיפוס `String`, הערכים יועברו, ומפת הגיבוב תהפוך לבעלים של הערכים הללו, כפי שמדגימה רשימה 8-22.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
```

<span class="caption">רשימה 8-22: מפתחות וערכים נמצאים בבעלות מפת הגיבוב לאחר הכנסתם אליה</span>

הקריאה למתודה `insert` מעבירה את הבעלות על המשתנים `field_name` ו-`field_value` למפת הגיבוב, ולכן אין אנו יכולים להשתמש במשתנים אלה יותר.

אם נכניס למפת הגיבוב הפניות לערכים, הערכים לא יועברו למפת הגיבוב. עם זאת, הערכים אליהם מצביעות ההפניות חייבים להיות תקפים לפחות כל עוד מפת הגיבוב עצמה תקפה. נדון בבעיות הללו עוד בפרק 10, בסעיף [“ווידוא הפניות במאצעות משך-חיים”][validating-references-with-lifetimes]

### עדכון מפת גיבוב

ניתן להגדיל ללא הגבלה את מספר צמדי מפתח-ערך המאוחסנים במפת הגיבוב. עם זאת, בכל זמן נתון, לכל מפתח יחודי יכול להיות רק ערך אחד המשויך אליו. (אך, יש לציין, לא להיפך: לדוגמה, הערך 10 יכול להיות מאוחסן ב-`scores` גם עבור הצוות הכחול וגם עבור הצוות הצהוב).

כאשר ברצוננו לשנות או לעדכן את הנתונים במפת הגיבוב עבור מפתח נתון, עלינו להחליט כיצד לטפל במקרה בו למפתח קיים כבר ערך. אנו יכולים, למשל, להחליף את הערך הקיים בערך החדש, תוך התעלמות מוחלטת מהערך הקיים; או, אנו יכולים לשמור את הערך הקיים ולהתעלם מהערך החדש, ולהוסיף את הערך החדש רק אם למפתח _אין_ כבר ערך קיים; או, אנו יכולים לשלב את הערך הישן והערך החדש באופן כזה או אחר. בואו נראה כיצד לעשות כל אחד מאלה!

#### החלפת ערך

אם נכניס מפתח וערך למפת גיבוב, ואז נכניס את אותו המפתח בשנית עם ערך אחר, יוחלף הערך המשויך לאותו המפתח. למרות שהקוד ברישום 8-23 קורא ל-'insert' פעמיים, מפת הגיבוב תכיל רק צמד מפתח-ערך אחד, כיוון שבשתי הפעמים אנו מכניסים ערך עבור המפתח של הצוות הכחול.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
```

<span class="caption">רשימה 8-23: החלפת ערך קיים המשויך למפתח נתון</span>

קוד זה ידפיס `{"Blue": 25}`; הערך המקורי, '10', הוחלף.

<!-- Old headings. Do not remove or links may break. -->

<a id="only-inserting-a-value-if-the-key-has-no-value"></a>

#### הוספת מפתח וערך רק אם המפתח אינו קיים במפה

נוהג מקובל הוא לבדוק אם מפתח מסוים כבר קיים במפת הגיבוב, ולבצע את הפעולות הבאות: אם המפתח אכן קיים במפת הגיבוב, אין לבצע אף שינוי בערך הקיים; אך אם המפתח אינו קיים, יש להכניס למפה אותו ואת הערך המשויך אליו.

למפות גיבוב קיים API מיוחד למטרה זו בשם `entry`, שמקבל כפרמטר את המפתח שברצונכם לבדוק. ערך ההחזרה של מתודת ה-'entry' הוא מבחר בשם 'Entry' שמייצג ערך שייתכן וקיים. נניח שאנו רוצים לבדוק האם למפתח של הצוות הצהוב קיים ערך משויך. אם לא, אנחנו רוצים להכניס את הערך 50, ואותו הדבר עבור הצוות הכחול. בשימוש ה-API של 'entry', הקוד יראה כדוגמת רשימה 8-24.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
```

<span class="caption">רשימה 8-24: שימוש במתודה `entry` להוספת צמד רק אם למפתח הנתון לא קיים כבר ערך</span>

כאשר היא מופעלת על מבחר מטיפוס `Entry`, המתודה `or_insert` מוגדרת כמחזירה הפניה ברת-שינוי לערך המשויך למפתח של אותו המבחר, אם הוא אכן קיים. אם אינו קיים, המתודה תכניס את הפרמטר שהועבר לה כערך החדש המשויך למפתח זה, ותחזיר הפניה ברת-שינוי לערך החדש. טכניקה זו נקייה הרבה יותר מאשר כתיבת הלוגיקה התפעולית בעצמנו, ואף עובדת טוב יותר בשילוב בודק ההשאלה.

הקוד ברשימה 8-24 ידפיס `{"Yellow": 50, "Blue": 10}`. הקריאה הראשונה ל-'entry' תכניס את המפתח לצוות הצהוב עם הערך 50, כי לצוות הצהוב אין ערך קיים. עם זאת, הקריאה השנייה ל-'entry' לא תשנה את מפת הגיבוב, כיוון שהערך `10` כבר קיים עבור הצוות הכחול.

#### עדכון ערך בהתבסס על הערך הישן

מקרה נפוץ נוסף עבור מפות גיבוב הוא הצורך לאתר ערך של מפתח נתון, ולאחר מכן לעדכנו בהתבסס על הערך הקיים. לדוגמה, רשימה 8-25 מציגה קוד שסופר כמה פעמים כל מילה מופיעה בטקסט נתון. אנו משתמשים במפת גיבוב עם המילים כמפתחות, ומגדילים כל פעם את הערך המשויך לכל מילה בכדי לספור כמה פעמים הופיעה. אם זו הפעם הראשונה שאנו רואים מילה, נכניס עבורה את הערך 0.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
```

<span class="caption">רשימה 8-25: ספירת מופעי מילים באמצעות מפת גיבוב המאחסנת מילים כמפתחות, ואת הספירה עבורן כערכים משויכים </span>

קוד זה ידפיס `{"world": 2, "hello": 1, "wonderful": 1}`. יתכן שתראו את אותם צמדי מפתח-ערך מודפסים בסדר שונה: זכרו מהסעיף [“גישה לערכים במפת גיבוב”][access]<!-- ignore --> שאיטרציה על מפת גיבוב מתרחשת בסדר שרירותי.

המתודה `split_whitespace` מחזירה איטרטור של תתי-חיתוכים, מופרדים בתו רווח-לבן (whitespace), של הטקסט המאוחסן במשתנה `text`. המתודה `or_insert` מחזירה הפניה ברת-שינוי (`&mut V`) לערך המשויך למפתח שצוין. כאן אנו מאחסנים את ההפניה ברת-השינוי במשתנה `count`. כעת, כדי לעדכן ערך זה, עלינו תחילה לבצע דה-הפניה באמצעות אופרטור הכוכבית (`*`). ההפניה ברת-השינוי יוצאת מהמתחם בסוף לולאת ה-'for', כך שכל השינויים הללו בטוחים ומותרים על פי כללי ההשאלה.

### פונקציות גיבוב

כברירת מחדל, `HashMap` מסתמכת על פונקצית גיבוב בשם _SipHash_ שמעניקה הגנה מפני מתקפות מניעת שירות (DoS) המערבות טבלאות גיבוב[^siphash]<!-- ignore -->. זה אמנם לא אלגוריתם הגיבוב המהיר ביותר בנמצא, אך בתמורה לירידה בביצועים, מקבלים אבטחת נתונים טובה יותר. אם תבדקו את הקוד שלכם ותגלו שפונקציית הגיבוב המוגדרת כברירת-המחדל איטית מדי עבורכם, תוכלו לעבור לפונקציה אחרת על ידי ציון מגבב אחר. מגבב - _hasher_ - הוא טיפוס שמיישם את התכונה 'BuildHasher'. נדבר על תכונות וכיצד ליישם אותן בפרק 10. לא מן ההכרח שתידרשו לממש את פונקצית הגיבוב שלכם מאפס; קיימות ספריות רבות המספקות מימושי אלגוריתמי גיבוב נפוצים רבים. תוכלו למצוא אותן ב-[crates.io](https://crates.io/)<!-- ignore -->
[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)

## סיכום

וקטורים, מחרוזות, ומפות גיבוב מעניקות רבות מן הפונקציונליות הדרושה לאחסון, גישה, ועדכון נתונים. כעת יש בידיכם את כל הכלים הדרושים בכדי לפתור את התרגילים הבאים:

- בהינתן רשימה של מספרים שלמים, השתמשו בוקטור בכדי להחזיר את החציון (באוסף ממוין, זהו הערך במיקום האמצעי), ואת השכיח (הערך המופיע בתדירות הגבוהה ביותר; מפת גיבוב תעזור כאן) ברשימה.
- המרת מחרוזות לפיג לטין (Pig Latin): העיצור הראשון של כל מילה יועבר לסוף המילה, ולאחריו תתווסף התנועה "ay", כך שהמילה "first" תהפוך ל-”irst-fay”. עבור מילים שמתחילות בתנועה, יתווסף "hay" לסוף המילה ("apple" תהפוך כך ל-"apple-hay"). זכרו את מה שלמדתם אודות קידוד UTF-8!
- באמצעות מפת גיבוב ווקטורים, צרו ממשק טקסט שיאפשר למשתמש להוסיף שמות עובדים למחלקה בחברה. לדוגמה “,Add Sally to Engineering” או “Add Amir to Sales.” לאחר מכן, אפשר למשתמש לאחזר רשימה של כל האנשים במחלקה או כל האנשים בחברה לפי מחלקה, ממוינת בסדר אלפביתי.

תיעוד ה-API של הספרייה הסטנדרטית כולל שיטות המשויכות לוקטורים, למחרוזות, ולמפות גיבוב שיעזרו לכם.

אנחנו מגיעים כעת לדון בתוכניות מורכבות יותר, בהן פעולות עלולות להיכשל. זהו, אפוא, הזמן המושלם לדון בטיפול בשגיאות. נעשה זאת בפרק הבא!

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[access]: #accessing-values-in-a-hash-map
