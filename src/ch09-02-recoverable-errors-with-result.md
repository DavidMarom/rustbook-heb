## שגיאות ברות-שיקום ו-`Result`

רוב השגיאות אינן חמורות דיין כדי להצדיק את עצירת התכנית כליל. לעיתים, כאשר פונקציה נכשלת, סיבת הכישלון ניתנת לפירוש מועיל וניתן להגיב בצורה מתאימה. לדוגמא, אם מנסים לפתוח קובץ והפעולה נכשלת בגלל שהקובץ אינו קיים, יתכן שתרצו ליצור את הקובץ במקום לסיים את כל התהליך.

זכרו המסעיף ["טיפול בשגיאות אפשריות באמצעות `Result`"][handle_failure]<!--
ignore --> מפרק 2 שהמבחר

`Result` מוגדר כך שיש לו שני ווריאנטים, `Ok` ו- `Err`, כדלהלן:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

הטיפוסים `T` ו-`E` הם פרמטרי טיפוסים גנריים: נדון בג'נריקס ביתר פירוט בפרק 10. כל שאתם צריכים לדעת בשלב זה הוא כי `T` מייצג את טיפוס הערך שמוחזר במקרה של הצלחה בתוך הווריאנט `Ok`, בעוד `E` מייצג את טיפוס השגיאה שתוחזר במקרה של כשלון בתוך הווריאנט `Err`. כיוון של- `Result` יש את פרמטרי הטיפוסים הגנריים האלה, ניתן להשתמש בטיפוס `Result` ובפונקציות שמוגדרות עבורו בסיטואציות רבות בהן ערכי ההצלחה וערכי הכשלון בהם אנו מעוניינים שונים זה מזה.

הבה נקרא לפונקציה שיכולה להיכשל ולכן מחזירה ערך `Result`. ברשימה 9-3 אנו מנסים לפתוח קובץ.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
```

<span class="caption">רשימה 9-3: פתיחה של קובץ</span>

הטיפוס המוחזר מ-`File::open` הוא `Result<T, E>`. הפרמטר הגנרי `T` הוחלף על-ידי המימוש של `File::open` בטיפוס של ערך ההצלחה, דהיינו `std::fs::File`, שהוא מנהל קובץ. הטיפוס עבור `E`, שהוא טיפוס ערך השגיאה, הוא `std::io::Error`. טיפוס ערך מוחזר זה משמעו שקריאה לפונקציה `File::open` יכולה להצליח ולהחזיר מנהל קובץ ממנו נוכל לקרוא ולכתוב. הפונקציה יכולה גם להיכשל: למשל, אם הקובץ לא קיים, או אם אין לנו הרשאות מתאימות לגישה לקובץ. לפונקציה `File::open` צריכה להיות דרך לאמר לנו האם היא הצליחה או נכשלה, ובאותו זמן לתת לנו או מנהל לקובץ, או מידע אודות השגיאה. מידע זה הוא בדיוק מה שהמבחר `Result` מבטא.

במקרה בו הקריאה ל- `File::open` מצליחה, הערך במשתנה `greeting_file_result` יהיה מופע של `Ok` שבתוכו נמצא מנהל הקובץ. במקרה של כישלון, הערך ב- `greeting_file_result` יהיה מופע של `Err` ובתוכו מידע נוסף אודות השגיאה שארעה.

עלינו להוסיף את הקוד ברשימה 9-3 על מנת לנקוט בפעולות שונות בתלות בערך ש- `File::open` מחזירה. רשימה 9-4 מראה דרך אחת לטפל ב-`Result` תוך שימוש בכלי בסיסי -- ביטוי `match` בו דנו בפרק 6.

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}
```

<span class="caption">רשימה 9-4: שימוש בביטוי `match` על מנת לטפל בווריאנים של `Result` שיכולים להיות מוחזרים</span>

שימו לב, כמו המבחר `Option`, גם המבחר `Result`, והווריאנטים שלו, הובאו אל המתחם על-ידי הפרליוד, ולכן אין צורך לציין `Result::` לפני הווריאנטים `Ok` או `Err` בזרועות ה-`match`.

כאשר התוצאה היא `Ok`, קוד זה יחזיר, מתוך הווריאנט `Ok`, את הערך הפנימי `file`, ואז אנו מבצעים השמה של ערך זה למשתנה `greeting_file`. לאחר ה- `match`, ניתן להשתמש במנהל הקובץ כדי לקרוא ולכתוב.

הזרוע האחרת של ה- `match` מטפלת במקרה בו אנו מקבלים ערך `Err` מהקריאה ל-`File::open`. בדוגמא זו, בחרנו להשתמש בקריאה למאקרו `panic!`. במידה ואין קובץ בשם _hello.txt_ בתיקיה הנוכחית, ומריצים את הקוד, נראה את הפלט הבא מהקריאה למאקרו `panic!`:

```console
{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
```

כרגיל, פלט זה אומר לנו בדיוק מה השתבש.

### התאמות על שגיאות שונות

הקוד ברשימה 9-14 יכנס לפאניקה ללא תלות בסיבה לכשלון של `File::open`. אבל, אנחנו רוצים לנקוט בפעולות שונות עבור סיבות כשלון שונות: אם הקריאה ל- `File::open` נכשלה בגלל שהקובץ אינו קיים, נרצה ליצור את הקובץ ולהחזיר מנהל לקובץ החדש. אם `File::open` נכשלה מכל סיבה אחרת -- למשל, משום שלא היתה לנו הרשאה לפתיחת הקובץ -- עדיין נרצה שהקוד יכנס לפאניקה באותה דרך כמו שקרה ברשימה 9-4. לשם כך נוסיף ביטוי `match` פנימי, כמוצג ברשימה 9-5.

<span class="filename">Filename: src/main.rs</span>

<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}
```

<span class="caption">רשימה 9-5: טיפול בסוגים שונים של שגיאות בדרכים שונות</span>

הטיפוס של הערך ש- `File::open` מחזירה בתוך הווריאנט `Err` הוא `io::Error`, שהוא מבנה שמסופק על-ידי הספריה הסטנדרטית. למבנה זה יש את המתודה `kind` שלה ניתן לקרוא כדי לקבל ערך מטיפוס `io::ErrorKind`. המבחר `io::ErrorKind` מסופק על-ידי הספריה הסטנדרטית ויש לו ווריאנטים שמייצגים את סוגי השגיאות שעלולות להתרחש בעקבות פעולת `io`. הווריאנט בו אנו רוצים להשתמש הוא `ErrorKind::NotFound`, שמשמעותו היא שהקובץ שניסינו לפתוח אינו קיים. לכן, אנו מתאימים מול `greeting_file_result`, אבל יש לנו גם התאמה פנימית על `error.kind()`.

התנאי שאנו רוצים לבדוק בהתאמה הפנימית הוא האם הערך המוחזר על-ידי `error.kind()` הוא הווריאנט `NotFound` של המבחר `ErrorKind`. אם זה המצב, אנו מנסים ליצור את הקובץ באמצעות `File::create`. אבל, משום שגם `File::create` עלול להכשל, אנו צריכים זרוע שניה בביטוי ה-`match` הפנימי. כאשר לא ניתן ליצור את הקובץ, מודפסת הודעת שגיאה אחרת. הזרוע השניה של ה- `match` החיצוני נשארת ללא שינוי, כך שהתכנית תיכנס לפאניקה בעקבות כל שגיאה חוץ משגיאה הנובעת מכך שהקובץ אינו קיים.

> ### חלופות לשימוש ב-`match` עם `Result<T, E>`
>
> אנחנו מתעסקים כאן עם הרבה מאוד ביטויי `match`! ביטוי `match` הוא יעיל מאוד אבל גם מאוד פרימיטיבי. בפרק 13, תלמדו על סגורים, בהם משתמשים עם רבות מהמתודות המוגדרות עבור `Result<T, E>`. מתודות אלה יכולות להיות יותר תמציתיות `match` כאשר מטפלים בערכי `Result<T, E>`.
>
> לדוגמא, הינה דרך אחרת לכתוב את אותה הלוגיקה התפעולית מרשימה 9-4, הפעם תוך שימוש בסגורים ובמתודה `unwrap_or_else`:
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {:?}", error);
>             })
>         } else {
>             panic!("Problem opening the file: {:?}", error);
>         }
>     });
> }
> ```
>
> למרות שלקוד זה התנהגות זהה לקוד מרשימה 9-5, הוא אינו כולל אף לא ביטוי `match` אחד, הוא נקיא יותר, וקל יותר לקריאה. אתם מוזמנים לחזור לקוד זה אחרי שתקראו את פרק 13, ולאחר שתקראו על המתודה `unwrap_or_else` בתיעוד של הספריה הסטנדרטית. מתודות רבות נוספות, כדוגמת זו, יכולות להוביל לקוד נקיא מקינונים של ביטויי `match` כשכותבים קוד לטיפול בשגיאות.

### קיצורים לפאניקה בעקבות שגיאה: `unwrap` ו- `expect`

שימוש ב-`match` עובד היטב, אבל יכול להוביל לכתיבה רבת-מלל שאינה תמיד מתקשרת בבהירות את כוונת הקוד. לטיפוס `Result<T, E>` יש מתודות-עזר רבות שמוגדרות עבורו על מנת לבצע פעולות מגוונות. המתודה `unwrap` היא מתודת קיצור-דרך שממומשת בדיוק כמו ביטוי ה-`match` שכתבנו ברשימה 9-4. אם ערך ה-`Result` הוא הווריאנט `Ok`, אז `unwrap` תחזיר את הערך שבתוך ה-`Ok`. אם ערך ה-`Result` הוא הווריאנט `Err`, אז `unwrap` תקרא עבורנו למקרו `panic!`. הינה דוגמא ל- `unwrap` בפעולה:

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}
```

אם נריץ קוד זה כשהקובץ _hello.txt_ אינו קיים, נראה הודעת שגיאה מהקריאה ל- `panic!` שהמתודה `unwrap` בצעה:

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->

```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
```

באופן דומה, המתודה `expect` מאפשרת לנו לבחור את הודעת הפאניקה שתודפס. לשימוש ב- `expect` במקום ב- `unwrap`, בתוספת הודעות שגיאה מועילות, יש פוטנציאל גם לתקשר את כוונת הקוד וגם להקל על איתור מקורות פאניקה. התחביר של `expect` נראה כך:

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}
```

אנו משתמשים ב-`expect` לאותה המטרה בה אנו משתמשים ב-`unwrap`: על מנת להחזיר מנהל לקובץ או לקרוא למקרו `panic!`. הודעת השגיאה ש- `expect` מעביר לקריאה ל- `panic!` היא הפרמטר שאנו מעבירים ל- `expect`, והיא תחליף את הודעת ברירת המחדל של `panic!` בה `unwrap` משתמשת. כך זה נראה למעשה:

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->

```text
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
```

בקוד מוכן להשקה, רוב הראסטיונרים בוחרים להשתמש ב-`expect` ולא ב-`unwrap`, ולספק הקשר רחב יותר מדוע הפעולה צפויה תמיד להצליח. בדרך זו, אם ההנחות שלכם מתגלות כשגויות, יש בידכם יותר מידע בזמן איתור באגים.

### השנעת שגיאות

כאשר מימוש של פונקציה קורא לדבר מה שעלול להכשל, במקום לטפל בשגיאה בפונקציה עצמה, ניתן להחזיר את השגיאה לקוד הקורא כדי שהוא יוכל לחליט מה לעשות. טכניקה זו ידועה כשינוע של שגיאות והיא נותנת לקוד הקורא יותר שליטה, שכן יתכן שבקוד הקורא יש יותר מידע או לוגיקה תפעולית שמכתיבה כיצד יש לטפל בשגיאה, בעוד שבאזור בו נוצרה השגיאה, יש פחות מידע נגיש.

לדוגמא, רשימה 9-6 מציגה פונקציה שקוראת שם משתמש מקובץ. אם הקובץ אינו קיים או לא ניתן לקריאה, הפונקציה מחזירה שגיאות אלה לקוד שקרא לפונקציה.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}
```

<span class="caption">רשימה 9-6: פונקציה שמחזירה שגיאות לקוד הקורא תוך שימוש ב-`match`</span>

ניתן לכתוב פונקציה זו בצורה קצרה הרבה יותר, אבל נתחיל בביצוע ידני על מנת להבין טיפול בשגיאות; בסוף, נראה את הדרך הקצרה. הבה נתבונן תחילה בטיפוס הערך המוחזר של הפונקציה: `Result<String, io::Error>`. זאת אומרת שהפונקציה מחזירה ערך מטיפוס `Result<T, E>` בו הפרמטר הגנרי `T` הוחלף בטיפוס הקונקרטי `String`, והטיפוס הגנרי `E` הוחלף בטיפוס הקונקרטי `io::Error`.

אם פונקציה זו מצליחה ללא בעיות, הקוד שקורא לפונקציה יקבל ערך `Ok` ובתוכו מופע של `String` -- שם המשתמש שהפונקציה קראה מהקובץ. אם הפונקציה נתקלת בבעיות כלשהן, הקוד הקורא יקבל ערך `Err` ובתוכו מופע של `io::Error` שמכיל עוד מידע אודות הבעיות. בחרנו את `io::Error` כטיפוס הערך המוחזר מפונקציה זו כי זה הטיפוס של ערך השגיאה שמוחזר משתי הפעולות שעלולות להכשל להן אנו קוראים בגוף הפונקציה: הפונקציה `File::open` והמתודה `read_to_string`.

גוף הפונקציה מתחיל בקריאה לפונקציה `File::open`. אחר-כך, אנו מטפלים בערך ה- `Result` באמצעות `match` בדומה ל- `match` שברשימה 9-4. אם `File::open` מתבצע בהצלחה, מנהל הקובץ במשתנה התבנית `file` מקבל את הערך שבמשתנה בר-השינוי `username_file`, והפונקציה ממשיכה. במקרה של `Err`, במקום לקרוא ל- `panic!`, אנו משתמשים במילת המפתח `return` כדי לחזור מוקדם מהפונקציה ולהחזיר את ערך השגיאה מ- `File::open`, שעכשיו נמצא במשתנה התבנית `e`, בחזרה לקוד הקורא, בדמות ערך השגיאה המוחזר מפונקציה זו.

בצורה זו, אם יש לנו מנהל קובץ ב- `username_file`, הפונקציה תיצור מופע חדש של `String` במשתנה `username` ותקרא למתודה `read_to_string` על מנהל הקובץ ב- `username_file` כדי לקרוא את תוכן הקובץ לתוך `username`. המתודה `read_to_string` מחזירה `Result` גם היא כיוון שהיא עלולה להכשל, אפילו אם `File::open` הצליחה. לכן אנו צריכים ביטוי `match` נוסף כדי לטפל בערך `Result` זה: אם `read_to_string` מצליחה, אז הפונקציה שלנו הצליחה גם היא, ואנחנו מחזירים את שם המשתמש מהקובץ שנמצא ב-`username`, עטוף בתוך `Ok`. אם `read_to_string` נכשלה, אנו מחזירים את ערך השגיאה באותה דרך בה החזרנו את ערך השגיאה ב- `match` שטיפל בערך המוחזר של `File::open`. אולם, אין צורך לרשום `return` במפורש, שכן זהו הביטוי האחרון בפונקציה.

הקוד שקורא לקוד זה יטפל בקבלת או ערך `Ok` שמכיל שם משתמש, או ערך `Err` שמכיל ערך `io::Error`. הקוד הקורא הוא שמחלטי כיצד לטפל בערכים אלה. אם הקוד הקורא מקבל ערך `Err`, הוא יוכל לקרוא ל- `panic!` ולהקריס את התכנית, להשתמש בברירת מחדל עבור שם המשתמש, או לחפש את שם המשתמש במקום אחר מחוץ לקובץ, למשל. אין לנו מספיק מידע בדבר מה בדיוק הקוד הקורא מנסה לעשות, ולכן אנו משנעים את כל ההצלחות והכשלונות במעלה מחסנית הקריאות, שם הן ינוהלו.

תבנית זו של שינוע שגיאות היא כל-כך נפוצה בראסט שראסט מספקת את האופרטור `?` כדי להקל על התהליך.

#### קיצור דרך לשינוע שגיאות: האופרטור `?`

רשימה 9-7 מראה מימוש של `read_username_from_file` עם אותה הפונקציונאליות כמו ברשימה 9-6, אלה שמימוש `?`.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}
```

<span class="caption">רשימה 9-7: פונקציה שמחזירה שגיאות לקוד הקורא באמצעות האופרטור `?`</span>

סימן השאלה `?` הממוקם אחרי ערך ה-`Result` פועל כמעט באותו אופן כמו ביטויי ה- `match` שהגדרנו כדי לטפל `Result` ברשימה 9-6. אם ערך ה-`Result` הוא `Ok`, הערך בתוך ה- `Ok` יוחזר מהביטוי, והתכנית תמשיך בריצתה. אם הערך הוא `Err`, ערך `Err` זה יוחזר מהפונקציה בדיוק כאילו נעשה שימוש במילת המפתח `return`, וכך ערך השגיאה משונע מעלה לקוד הקורא.

ישנו הבדל בין מה שביטוי ה-`match` ברשימה 9-6 עושה, למה שהאופרטור `?` עושה: ערכי שגיאה עליהם מפעילים את האופרטור `?` מועברים דרך הפונקציה `from`, שמוגדרת בתכונה `From` שבספריה הסטנדרטית, שמשמשת כדי להמיר ערכים מטיפוס אחד לאחר. כאשר האופרטור `?` קורא לפונקציה `from`, טיפוס השגיאה שמתקבל מומר לטיפוס השגיאה בערך המוחזר של הפונקציה הנוכחית. תכונה זו שימושית כאשר פונקציה מחזירה טיפוס שגיאה אחד כדי לייצג את כל האופנים בהם הפונקציה יכולה להכשל, אפילו אם חלקים שלה יכולים להכשל בשל סיבות רבות אחרות.

לדוגמא, ניתן לשנות את הפונקציה `read_username_from_file` ברשימה 9-7 כך שתחזיר את טיפוס השגיאה המותאם `OurError`, אותו אנו מגדירים בעצמנו. אם נוסיף גם את המימוש `impl From<io::Error> for OurError` כדי לבנות מופע של `OurError` מ- `io::Error`, אז הפעלות האופרטור `?` בגוף של `read_username_from_file` יקראו ל- `from` וימירו את טיפוסי השגיאה ללא צורך להוסיף עוד קוד לפונקציה.

בהקשר של רשימה 9-7, האופרטור `?` בסוף הקריאה ל- `File::open` תחזיר את הערך בתוך ה-`Ok` למשתנה `username_file`. אם מתקבלת שגיאה `?` יחזור מוקדם מהפונקציה ויעביר כל ערך `Err` שהוא לקוד הקורא. אותו העקרון תקף עבור `?` בסוף הקריאה ל-`read_to_string`.

האופרטור `?` מונע את הצורך ליצור הרבה קוד סתמי והופך את המימוש של הפונקציה הזו לפשוט יותר. ניתן אפילו לקצר את הקוד עוד יותר על-ידי שרשור קריאות למתודות מייד אחרי ה-`?`, כמוצג ברשימה 9-8.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}
```

<span class="caption">רשימה 9-8: שרשור קריאות למתודות לאחר שימוש באופרטור `?`</span>

העברנו את יצירת המופע החדש של `String` ב- `username` לתחילת הפונקציה; חלק זה לא שונה. במקום ליצור את המשתנה `username_file`, שרשרנו את הקריאה ל- `read_to_string` ישירות על התוצאה של `File::open("hello.txt")?`. עדיין יש `?` בסוף הקריאה ל-`read_to_string`, ואנחנו עדיין מחזירים ערך `Ok` שמכיל `username` כאשר גם `File::open` וגם `read_to_string` מצליחים, במקום להחזיר שגיאות. הפונקציונאליות, שוב, זהה לזאת שברשימה 9-6 וברשימה 9-7; פה אנו רואים דרך שונה, יותר נעימה, להשיג את אותה ההתנהגות.

רשימה 9-9 מראה דרך לעשות זאת עוד יותר בקצרה באמצעות `fs::read_to_string`.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}
```

<span class="caption">רשימה 9-9: שימוש ב- `fs::read_to_string` במקום לפתוח קובץ, ואז לקרוא ממנו</span>

קריאת קובץ למחרוזת היא פעולה שכיחה למדי, ולכן הספריה הסטנדרטית מספקת את הפונקציה `fs::read_to_string` שפותחת קובץ, יוצרת מופע חדש של `String`, קוראת את תוכן הקובץ, מאכסנת את התוכן לתוך מופע ה-`String`, ומחזירה אותו. ההמנעות, לעיל, מהשימוש ב-`fs::read_to_string` סיפקה לנו הזדמנות להדגים בפירוט רב את מלאכת הטיפול בשגיאות בארסט.

#### מקומות בהם ניתן להשתמש באופרטור `?`

באופרטור `?` ניתן להשתמש רק בפונקציות בהן טיפוס הערך המוחזר קומפטבילי עם הערך עליו מפעילים את `?`. זאת משום שהאופרטור `?` מוגדר לבצע החזרה מוקדמת של ערך מהפונקציה, באותו אופן כמו ביטוי ה-`match` שהגדרנו ברשימה 9-6. ברשימה 9-6, ה-`match` השתמש בערך `Result`, והזרוע של ההחזרה המוקדמת החזריה ערך מטיפוס `Err(e)`. טיפוס הערך המוחזר של הפונקציה חייב להיות `Result` כדי להיות קומפטיבילי עם פקודת `return` זו.

ברשימה 9-10, הבה נתבונן בשגיאה שנקבל אם נשתמש באופרטור `?` בפונקציה `main` שבה טיפוס הערך המוחזר אינו קומפטבילי עם הטיפוס של הערך עליו אנו מפעילים את `?`:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}
```

<span class="caption">רשימה 9-10: ניסיון להשתמש ב-`?` בפונקציה `main` שמחזירה `()` לא יעבור קומפילציה</span>

קוד זה פותח את הקובץ, וזו פעולה שעלולה להכשל. האופרטור `?` פועל על ערך ה-`Result` שמוחזר על-ידי `File::open`, אבל הפונקציה `main` מחזירה ערך מטיפוס `()`, לא `Result`. כאשר נקמפל קוד זה, נקבל את הודעת השגיאה הבאה:

```console
{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}
```

שגיאה זו מבהירה שניתן להפעיל את האופרטור `?` בתוך פונקציות שמחזירואת `Result`, `Option`, או כל טיפוס אחר שמממש את `FromResidual`.

יש בידכם שתי אפשרויות כדי לפתור את הבעיה. אפשרות אחת היא לשנות את טיפוס הערך המוחזר של הפונקציה כך שהוא יהיה קומפטבילי עם הערך עליו אתם מפעילים את האופרטור `?`, כל עוד אין מגבלות שמונעות ממכם לעשות זאת. הטכניקה השניה היא להשתמש ב-`match` על אחת מהמתודות של `Result<T, E>` כדי לטפל ב-`Result<1>` בדרך נאותה.

הודעת השגיאה מזכירה שניתן להפעיל את `?` גם על ערכי `Option<T>`. כמו במקרה של הפעלת `?` על `Result`, ניתן להפעיל את `?` עם על `Option` בגוף של פונקציה שמחזירה `Option`. ההתנהגות של האופרטור `?` כאשר מפעילים אותו על `Option<T>` דומה להתנהגות כאשר הוא מופעל על `Result<T, E>`: אם הערך הוא `None`, ה- `None` יוחזר מהפונקציה בנקודה זו. אם הערך הוא `Some`, הערך הפנימי של ה- `Some` i יהיה הערך של הביטוי, והפונקציה תמשיך בריצה. ברשימה 9-11 יש דוגמא לפונקציה שמוצאת את התו האחרון של השורה הראשונה בטקסט נתון:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}
```

<span class="caption">רשימה 9-11: שימוש באופרטור `?` על ערך `Option<T>`</span>

פונקציה זו מחזירה `Option<char>` כיוון שיתכן ויש תו להחזרה, אבל יתכן גם שאין. קוד זה לוקח את חיתוך המחרוזת בארגומנט `text` וקורא עליו למתודה `lines`, שמחזירה איטרטור למעבר על שורות המחרוזת. משום שפונקציה זו רוצה לבחון את השורה הראשונה, היא קוראת ל-`next` על האיטרטור על מנת לקבל את הערך הראשון מהאיטרטור. אם `text` הוא מחרוזת ריקה, קריאה זו ל-`text` תחזיר `None`, ובמקרה זה `?` יגרום לעצירת הפונקציה והחזרת הערך `None` מ-`last_char_of_first_line`. אם `text` i אינה מחרוזת ריקה, `next` תחזיר ערך `Some` שמכיל חיתוך מחרוזת של השורה הראשונה ב-`text`.

האופרטור `?` ממצה את חיתוך המחרוזת, ואז ניתן לקרוא ל-`chars` על חיתוך זה כדי לקבל איטרטור על התווים שבו. אנו מעוניינים בתו האחרון בשורה ראשונה זו, ולכן אנו קוראים ל-`last` כדי להחזיר את הפריט האחרון באיטרטור. זהו ערך מטיפוס `Option` כיוון שיתכן שהשורה הראשונה היא מחרוזת ריקה, למשל אם `text` מתחיל עם שורה ריקה ולאחריה כמה שורות לא ריקות, כמו `"\nhi"`. אבל, אם יש תו אחרון בשורה הראשונה, הוא יוחזר בתוך הווריאנט `Some`. האופרטור `?` באמצע מאפשר לנו דרך תמציתית לבטא לוגיקה תפעולית זו, ובכך מתאפשר לנו לממש פונקציה זו בשורה בודדת. אם לא היינו משתמשים באופרטור `?` על `Option`, היה עלינו לממש את הלוגיקה התפעולית הרצויע תוך שימוש במתודות נוספות או עם ביטוי `match`.

שימו לב `?` על `Result` בפונקציה שמחזירה `Result`, וניתן להשתמש באופרטור `?` על `Option` בפונקציה שמחזירה `Option`, אבל לא ניתן לערבב אפשרויות אלה. האופרטור `?` לא ממיר אוטומטית בין `Result` ל-`Option`; במקרים כאלה, ניתן להשתמש במתודות כמו `ok` על `Result` או המתודה `ok_or` על `Option` כדי לבצע המרות בצורה מפורשת.

עד כה, כל פונקציות ה-`main` החזירו `()`. `main` היא פונקציה מיוחדת כיוון שהיא נקודת הפתיחה והסיום של תכניות הרצה, וישנן מגבלות על סוגי הערך המוחזר כדי לתכניות יהיו התנהגויות צפויות.

למרבה המזל, `main` יכולה להחזיר את הטיפוס `Result<(), E>`. ברשימה 9-12 יש קוד מרשימה 9-10, אבל שינינו את טיפוס הערך המוחזר של `main` להיות `Result<(), Box<dyn Error>>` והוספנו את הערך `Ok(())` בסוף. קוד זה עובר קומפילציה:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}
```

<span class="caption">רשימה 9-12: שינוי `main` כך שתחזיר `Result<(), E>` מאפשר שימוש באופרטור `?` על ערכי `Result`</span>

הטיפוס `Box<dyn Error>` הוא _אובייקט תכונה_, נושא בו נדון בסעיף ["שימוש באובייקטי תכונה שמאפשרים ערכים מטיפוסים שונים"][trait-objects]<!-- ignore --> בפרק 17. לעכשיו, תוכלו לחשוב על `Box<dyn Error>` כעל "כל סוג שהוא של שגיאה." שימוש ב- `?` על ערך `Result` בפונקציה `main` עם טיפוס השגיאה `Box<dyn Error>` מותר, כי הוא מאפשר לכל ערך `Err` להיות מוחזר מיידית. למרות שהגוף של פונקצית `main` זו תמיד יחזיר שגיאות מטיפוס `std::io::Error`, על-ידי ציון `Box<dyn Error>`, חותם זה ימשיך להיות תקף גם אם יוסף קוד נוסף, שמחזיר שגיאות אחרות, לגוף ה-`main`.

כאשר פונקצית `main` מחזירה `Result<(), E>`, קובץ ההרצה יסיים עם ערך `0` אם `main` מחזירה `Ok(())`, ויסיים עם ערך שונה מ-0 אם `main` החזירה ערך `Err`. קבצי הרצה שכתובים ב-C מחזירים שלמים כאשר הם מסיימים: תכניות שמסיימות בהצלחה מחזירות `0`, ותכניות בהן ארעה שגיאה מחזירות ערך שלם כלשהו שונה מ-`0`. גם ראסט מחזירה שלמים מקבצי הרצה על מנת לשמר תאימות עם מוסכמה זו.

הפונקציה `main` רשאית להחזיר כל טיפוס שמממש את [the `std::process::Termination` trait][termination]<!-- ignore -->, שכולל את הפונקציה `report` that returns an `ExitCode`. פנו לתיעוד של הספריה הסטנדרטית לעוד מידע אודות מימוש התכונה `Termination` עבור טיפוסים משלכם.

לאחר שדנו בפרטים של קריאה ל-`panic!` והחזרת `Result`, הבה נחזור לנושא של בחירה נאותה בין שתי אפשרויות אלה.

[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[termination]: ../std/process/trait.Termination.html
