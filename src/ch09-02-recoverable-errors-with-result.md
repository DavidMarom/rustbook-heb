## שגיאות ברות-שיקום ו-`Result`

רוב השגיאות אינן חמורות דיין כדי להצדיק את עצירת התכנית כליל. לעיתים, כאשר פונקציה נכשלת, סיבת הכישלון המוצגת בקונסולה מועילה מאוד באיתור ופתרון הבעיה. לדוגמה, אם מנסים לפתוח קובץ והפעולה נכשלת בגלל שהקובץ אינו קיים, יתכן ותרצו ליצור את הקובץ במקום לסיים את ריצת הקוד כולו.

זכרו מסעיף ["טיפול בשגיאות אפשריות באמצעות `Result`"][handle_failure]<!--
ignore --> מפרק 2 שהמבחר `Result` מוגדר כך שיש לו שני וריאנטים, `Ok` ו- `Err`, כדלהלן:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

הטיפוסים `T` ו-`E` הם פרמטרי טיפוסים גנריים: נדון בג'נריקס ביתר פירוט בפרק 10; כל שאתם צריכים לדעת בשלב זה הוא כי `T` מייצג את טיפוס הערך שמוחזר במקרה של הצלחה בתוך הווריאנט `Ok`, בעוד `E` מייצג את טיפוס השגיאה שתוחזר במקרה של כשלון, בתוך הווריאנט `Err`. כיוון ש-`Result` כולל את פרמטרי הטיפוסים הגנריים האלה, ניתן להשתמש בטיפוס `Result`, ובפונקציות המוגדרות עבורו, במצבים רבים בהם ערכי ההצלחה וערכי הכשלון הרצוים שונים זה מזה.

הבה נקרא לפונקציה שיכולה להיכשל ולכן מחזירה ערך `Result`. ברשימה 9-3 אנו מנסים לפתוח קובץ.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
```

<span class="caption">רשימה 9-3: פתיחה של קובץ</span>

הטיפוס המוחזר מ-`File::open` הוא `Result<T, E>`. הפרמטר הגנרי `T` הוחלף על-ידי המימוש של `File::open` בטיפוס של ערך ההצלחה, דהיינו `std::fs::File`, שהוא מנהל קובץ. הטיפוס עבור `E`, שהוא טיפוס ערך השגיאה, הוא `std::io::Error`. טיפוס ערך מוחזר זה משמעו שקריאה לפונקציה `File::open` יכולה להצליח ולהחזיר מנהל קובץ ממנו נוכל לקרוא ולכתוב. הפונקציה יכולה גם להיכשל: למשל, אם הקובץ לא קיים, או אם אין לנו הרשאות מתאימות לגישה לקובץ. לפונקציה `File::open` צריכה להיות דרך לומר לנו האם היא הצליחה או נכשלה, ובאותו זמן לתת לנו מנהל לקובץ, או לחלופין מידע אודות השגיאה שקרתה. מידע זה הוא בדיוק מה שמבטא המבחר `Result`.

במקרה בו הקריאה ל- `File::open` מצליחה, הערך במשתנה `greeting_file_result` יהיה מופע של `Ok` שבתוכו נמצא מנהל הקובץ. במקרה של כישלון, הערך ב- `greeting_file_result` יהיה מופע של `Err` ובתוכו מידע נוסף אודות השגיאה שארעה.

עלינו להוסיף את הקוד ברשימה 9-3 על מנת לנקוט בפעולות שונות בהתאם לערך ש- `File::open` מחזירה. רשימה 9-4 מראה דרך אחת לטפל ב-`Result` תוך שימוש בכלי בסיסי מוכר -- ביטוי `match` בו דנו בפרק 6.

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}
```


<span class="caption">רשימה 9-4: שימוש בביטוי `match` על-מנת לטפל בווריאנטים האפשריים של `Result` שעשויים להתקבל כערכי החזרה</span>

שימו לב, כמו המבחר `Option`, גם המבחר `Result` והווריאנטים שלו, הובאו אל המתחם על-ידי הפרליוד, ולכן אין צורך לציין `Result::` לפני הווריאנטים `Ok` או `Err` בזרועות ה-`match`.

כאשר התוצאה היא `Ok`, קוד זה יחזיר, מתוך הווריאנט `Ok`, את הערך הפנימי `file`. אז ניתן לבצע השמה של ערך זה למשתנה `greeting_file`. לאחר ביטוי ה- `match`, ניתן להשתמש במנהל הקובץ כדי לקרוא ולכתוב אל הקובץ אליו הוא משויך.

הזרוע האחרת של ה- `match` מטפלת במקרה בו אנו מקבלים ערך `Err` מהקריאה ל-`File::open`. בדוגמה זו, בחרנו להשתמש בקריאה למאקרו `panic!`. במידה ובתיקייה הנוכחית לא קיים קובץ בשם *hello.txt*, ואנו מריצים את הקוד, נראה את הפלט הבא שיתקבל מהקריאה למאקרו `panic!`:

```console
{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
```

כרגיל, פלט זה אומר לנו בדיוק מה השתבש.

### ביטויי match על שגיאות שונות

הקוד ברשימה 9-14 יכנס לפאניקה בגין כל כשלון של `File::open`. עם זאת, אנחנו רוצים לנקוט בפעולות שונות עבור סיבות כשלון שונות: אם הקריאה ל- `File::open` נכשלה בגלל שהקובץ אינו קיים, נרצה ליצור את הקובץ ולהחזיר מנהל לקובץ החדש. אך אם `File::open` נכשלה מכל סיבה אחרת -- למשל, משום שלא היתה לנו הרשאה לפתיחת הקובץ -- עדיין נרצה שהקוד יכנס לפאניקה כמו ברשימה 9-4. לשם כך נוסיף ביטוי `match` פנימי, כמוצג ברשימה 9-5.

<span class="filename">Filename: src/main.rs</span>

<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}
```


<span class="caption">רשימה 9-5: טיפול בסוגים שונים של שגיאות בדרכים שונות</span>

הטיפוס של הערך אותו מחזירה `File::open` בתוך הווריאנט `Err` הוא `io::Error`, שהוא מבנה שמסופק על-ידי הספריה הסטנדרטית. מבנה זה כולל את המתודה `kind`, לה ניתן לקרוא כדי לקבל ערך מטיפוס `io::ErrorKind`. המבחר `io::ErrorKind` מסופק גם הוא על-ידי הספריה הסטנדרטית, ויש לו וריאנטים המייצגים את סוגי השגיאות שעלולות לצוץ בעקבות פעולת `io`. הווריאנט בו אנו רוצים להשתמש הוא `ErrorKind::NotFound`, שמשמעותו היא שהקובץ שניסינו לפתוח אינו קיים. לכן, אנו מתאימים מול `greeting_file_result`, אבל יש לנו גם התאמה פנימית על `error.kind()`.

התנאי שאנו רוצים לבדוק בהתאמה הפנימית הוא האם הערך המוחזר על-ידי `error.kind()` הוא הווריאנט `NotFound` של המבחר `ErrorKind`. אם כן, אנו מנסים ליצור את הקובץ באמצעות `File::create`. אבל, משום שגם הקריאה ל-`File::create` עלולה להכשל, אנו נדרשים לזרוע שניה, בביטוי ה-`match` הפנימי. כאשר לא ניתן ליצור את הקובץ, מודפסת הודעת שגיאה אחרת. הזרוע השניה של ה- `match` החיצוני נותרת ללא שינוי, כך שהתכנית תיכנס לפאניקה בעקבות כל שגיאה, מלבד שגיאה הנובעת מכך שהקובץ אינו קיים.

> ### חלופות לשימוש ב-`match` עם `Result<T, E>`
> 
> אנחנו מתעסקים כאן עם הרבה מאוד ביטויי `match`! ביטוי `match` הוא יעיל מאוד, אך גם פרימיטיבי מאוד. בפרק 13 תלמדו על סגורים (closures), בהם משתמשים בשילוב רבות מהמתודות המוגדרות עבור הטיפוס `Result<T, E>`. מתודות אלה יכולות להיות יותר תמציתיות מביטויי `match` כאשר מטפלים בערכי  `Result<T, E>`.
> 
> לדוגמה, הנה דרך אחרת לכתוב את אותה הלוגיקה מרשימה 9-4, הפעם תוך שימוש בסגורים ובמתודה  `unwrap_or_else`:
> 
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
> 
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
> 
> fn main() {
>     let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {:?}", error);
>             })
>         } else {
>             panic!("Problem opening the file: {:?}", error);
>         }
>     });
> }
> ```
> 
> למרות שקוד זה מתנהג באופן זהה לקוד מרשימה 9-5, הוא אינו כולל אף לא ביטוי `match`  אחד; הוא נקי יותר, וקל יותר לקריאה. אתם מוזמנים לחזור לקוד זה אחרי שתקראו את פרק 13, ולאחר שתקראו על המתודה  `unwrap_or_else` בתיעוד של הספריה הסטנדרטית. מתודות רבות נוספות, כדוגמת זו, יכולות להוביל לקוד נקי מביטויי `match` מקוננים כשכותבים קוד לטיפול בשגיאות.

### קיצורים לפאניקה בעקבות שגיאה: `unwrap` ו- `expect`

שימוש ב-`match` עובד היטב, אבל עלול להפיק קוד רב-מלל שאינו מעביר תמיד בבירור את כוונת הקוד. לשם כך, לטיפוס `Result<T, E>` יש מתודות-עזר רבות המאפשרות פונקציונליות שקולה בניסוח קצר וברור יותר. כך, המתודה `unwrap` היא מתודת קיצור-דרך שממומשת בדיוק כמו ביטוי ה-`match` שכתבנו ברשימה 9-4. אם ערך ה-`Result` הוא הווריאנט `Ok`, אז `unwrap` תחזיר את הערך שבתוך ה-`Ok`. אם ערך ה-`Result` הוא הווריאנט `Err`, אז `unwrap` תקרא עבורנו למאקרו `panic!`. הנה דוגמה ל- `unwrap` בפעולה:

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}
```

אם נריץ קוד זה כשהקובץ *hello.txt* אינו קיים, נראה הודעת שגיאה מהקריאה ל- `panic!` שביצעה המתודה `unwrap`:

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->

```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
```

באופן דומה, המתודה `expect` מאפשרת לנו לנסח את ההודעה שתודפס בעת הפאניקה. בכדי לתקשר בבירור את כוונת הקוד וגם להקל על איתור מקורות הבעיה, כדאי יהיה להשתמש ב- `expect` במקום ב- `unwrap`, ולהוסיף הודעות שגיאה מועילות. התחביר של `expect` נראה כך:

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}
```

אנו משתמשים ב-`expect` לאותה המטרה לשמה אנו משתמשים ב-`unwrap`: על מנת להחזיר מנהל לקובץ, או לחלופין לקרוא למקרו `panic!`. הודעת השגיאה ש- `expect` מקבלת כפרמטר תחליף את הודעת ברירת המחדל שידפיס `panic!`. כך זה נראה למעשה:

<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->

```text
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
```

בקוד מוכן להשקה, רוב הראסטיונרים בוחרים להשתמש ב-`expect` ולא ב-`unwrap`, ולספק באמצעותה הקשר רחב יותר מדוע הפעולה צפויה תמיד להצליח. כך, אם ההנחות שלכם מתגלות כשגויות, יהיה בידיכם יותר מידע בזמן איתור באגים.

### השנעת שגיאות

כאשר מימוש של פונקציה קורא לדבר מה שעלול להכשל, במקום לטפל בשגיאה בפונקציה עצמה, ניתן להחזיר את השגיאה לקוד הקורא כדי שהוא יוכל לחליט מה לעשות. טכניקה זו ידועה כשינוע של שגיאות (error propagation) והיא מעניקה לקוד הקורא שליטה רבה יותר, שכן יתכן שהקוד הקורא מכיל מידע מועיל או לוגיקה תפעולית שמכתיבה כיצד יש לטפל בשגיאה, בעוד שבאזור בו נוצרה השגיאה, קיים פחות מידע נגיש.

לדוגמא, רשימה 9-6 מציגה פונקציה שקוראת שם משתמש מקובץ. אם הקובץ אינו קיים או לא ניתן לקריאה, הפונקציה מחזירה שגיאות אלה לקוד שקרא לפונקציה.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}
```


<span class="caption">רשימה 9-6: פונקציה שמחזירה שגיאות לקוד הקורא תוך שימוש ב-`match`</span>

ניתן לכתוב פונקציה זו בצורה קצרה הרבה יותר, אבל נתחיל בביצוע ידני על מנת להבין כיצד מתבצע טיפול בשגיאות; לאחר מכן, נראה את הדרך הקצרה. הבה נתבונן תחילה בטיפוס הערך המוחזר של הפונקציה: `Result<String, io::Error>`. זאת אומרת שהפונקציה מחזירה ערך מטיפוס `Result<T, E>` בו הפרמטר הגנרי `T` הוחלף בטיפוס הקונקרטי `String`, והטיפוס הגנרי `E` הוחלף בטיפוס הקונקרטי `io::Error`.

אם פונקציה זו מצליחה, הקוד שקורא לפונקציה יקבל ערך `Ok` ובתוכו מופע של `String` -- שם המשתמש שהפונקציה קראה מהקובץ. אם הפונקציה נתקלת בבעיות כלשהן, הקוד הקורא יקבל ערך `Err` ובתוכו מופע של `io::Error` שמכיל מידע נוסף אודות הבעיות. בחרנו את `io::Error` כטיפוס הערך המוחזר מפונקציה זו, כי זה הטיפוס של ערך השגיאה שמוחזר משתי הפעולות העלולות-להיכשל להן אנו קוראים בגוף הפונקציה: הפונקציה `File::open` והמתודה `read_to_string`.

גוף הפונקציה מתחיל בקריאה לפונקציה `File::open`. אחר-כך, אנו מטפלים בערך ה- `Result` באמצעות `match`, בדומה ל- `match` ברשימה 9-4. אם `File::open` מתבצעת בהצלחה, מנהל הקובץ במשתנה התבנית `file` מקבל את הערך שבמשתנה בר-השינוי `username_file`, והפונקציה ממשיכה בפעולתה. במקרה של `Err`, במקום לקרוא ל- `panic!`, אנו משתמשים במילת המפתח `return` כדי לחזור מוקדם מהפונקציה ולהחזיר את ערך השגיאה מ- `File::open`, שכעת במשתנה התבנית `e`, בחזרה לקוד הקורא, בדמות ערך השגיאה המוחזר מפונקציה זו.
באופן זה, אם התקבל מנהל קובץ במשתנה `username_file`, הפונקציה תיצור מופע חדש של `String` בשם `username`, תקרא למתודה `read_to_string` על מנהל הקובץ שבתוך `username_file` כדי לקרוא את תוכן הקובץ, ותשמור את המידע שבתוכו לתוך המשתנה `username`. שימו לב שכיוון שהמתודה `read_to_string` יכולה אף היא להיכשל, גם היא מחזירה `Result`. לכן אנו נדרשים לביטוי `match` נוסף כדי לטפל בערך `Result` הזה.
בסופו של דבר, אם המתודה `read_to_string` הצליחה, הפונקציה שלנו הצליחה גם היא, ואנחנו מחזירים את שם המשתמש מהקובץ שנמצא ב-`username`, עטוף בתוך הווריאנט `Ok`. ואם `read_to_string` נכשלה, אנו מחזירים את ערך השגיאה באותה הדרך בה החזרנו את ערך השגיאה ב-`match` הקודם, שטיפל בערך שחזר מ-`File::open`. כזכור, כיוון שזהו הביטוי האחרון בפונקציה, אין צורך לרשום `return` במפורש.
הקוד שקורא לקוד זה ידרש לטפל בערך `Ok` שמכיל שם משתמש, או בערך `Err` שמכיל ערך `io::Error`. הקוד הקורא הוא זה שעליו להחליט כיצד לטפל בערכים אלה. אם הקוד הקורא מקבל ערך `Err`, הוא יוכל למשל לקרוא ל- `panic!` ולהביא לקריסת התכנית; או, להשתמש בברירת מחדל כלשהי עבור שם המשתמש; או, לחפש את שם המשתמש במקום אחר מחוץ לקובץ. אין אנו יודעים בדיוק מה הקוד הקורא מנסה לעשות, ולכן אנו משנעים את כל ההצלחות והכשלונות במעלה מחסנית הקריאות, שם הן ינוהלו.

תבנית זו של שינוע שגיאות היא כה נפוצה בראסט שראסט מספקת את האופרטור `?` כדי להקל על התהליך.

#### קיצור דרך לשינוע שגיאות: האופרטור `?`

רשימה 9-7 מציגה מימוש של `read_username_from_file` עם אותה הפונקציונאליות כמו ברשימה 9-6 בגרסה מקוצרת עם האופרטור `?`.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}
```

<span class="caption">רשימה 9-7: פונקציה שמחזירה שגיאות לקוד הקורא באמצעות האופרטור `?`</span>

סימן השאלה `?` הממוקם אחרי ערך ה-`Result` פועל כמעט באותו אופן כמו ביטויי ה- `match` שהגדרנו כדי לטפל במבחר `Result` ברשימה 9-6. אם ערך ה-`Result` הוא `Ok`, יוחזר מהביטוי הערך שבתוך ה- `Ok`, והתכנית תמשיך בריצתה. אך אם הערך הוא `Err`, ערך `Err` זה יוחזר מהפונקציה בדיוק כאילו נעשה שימוש במילת המפתח `return`, וכך ערך השגיאה משונע מעלה לקוד הקורא.

עם זאת, קיים הבדל בין מה שעושה ביטוי ה-`match` ברשימה 9-6, למה שעושה האופרטור `?`: ערכי שגיאה עליהם מפעילים את האופרטור `?` מועברים דרך הפונקציה `from`, שמוגדרת בתכונה `From` שבספריה הסטנדרטית, שביכולתה להמיר ערכים מטיפוס אחד לטיפוס אחר. כאשר האופרטור `?` קורא לפונקציה `from`, טיפוס השגיאה שמתקבל מומר לטיפוס השגיאה המוגדר כערך ההחזרה של הפונקציה הנוכחית. תכונה זו שימושית כאשר פונקציה מחזירה טיפוס שגיאה אחד כדי לייצג את כל האופנים בהם הפונקציה יכולה להכשל, אפילו אם חלקים שלה יכולים להכשל בשל סיבות רבות אחרות.

לדוגמה, ניתן לשנות את הפונקציה `read_username_from_file` ברשימה 9-7 כך שתחזיר את טיפוס השגיאה המותאם `OurError`, אותו אנו מגדירים בעצמנו. אם נוסיף גם את המימוש `impl From<io::Error> for OurError` כדי לבנות מופע של `OurError` מ- `io::Error`, אז הפעלות האופרטור `?` בגוף של `read_username_from_file` יקראו ל- `from` וימירו את טיפוסי השגיאה בעצמם, מבלי שנידרש להוסיף קוד לפונקציה.

בהקשר של רשימה 9-7, האופרטור `?` שבסוף הקריאה ל- `File::open` יחזיר את הערך בתוך הווריאנט `Ok` למשתנה `username_file`. אך אם מתקבלת שגיאה, `?` יחזור מוקדם מהפונקציה, ויעביר כל ערך `Err` שהתקבל לקוד הקורא. אותו העקרון תקף עבור `?` שבסוף הקריאה ל-`read_to_string`.

האופרטור `?` מונע הופעת קוד תבניתי סתמי, והופך את המימוש של הפונקציה לפשוט יותר. ניתן אפילו לקצר את הקוד עוד יותר על-ידי שרשור קריאות למתודות מיד לאחר ה-`?`, כמוצג ברשימה 9-8.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}
```

<span class="caption">רשימה 9-8: שרשור קריאות למתודות לאחר שימוש באופרטור `?`</span>

העברנו את יצירת המופע החדש של `String` ב- `username` לתחילת הפונקציה; כאן אין שינוי. לאחר מכן, במקום ליצור את המשתנה `username_file`, שרשרנו את הקריאה ל- `read_to_string` ישירות לתוצאה של `File::open("hello.txt")?`. עדיין קיים `?` בסוף הקריאה ל-`read_to_string`, ואנחנו עדיין מחזירים ערך `Ok` שמכיל `username` כאשר גם `File::open` וגם `read_to_string` מצליחים, במקום להחזיר שגיאות. גם כאן, הפונקציונאליות זהה לזאת שברשימה 9-6 וברשימה 9-7. ההבדל הוא שכאן אנו רואים דרך שונה, יותר נעימה, להשיג את אותה ההתנהגות.

רשימה 9-9 מראה דרך לעשות זאת עוד יותר בקצרה באמצעות `fs::read_to_string`.

<span class="filename">Filename: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}
```

<span class="caption">רשימה 9-9: שימוש ב- `fs::read_to_string` כחלופה לפתיחת וקריאת קובץ</span>

קריאת קובץ למחרוזת היא פעולה שכיחה למדי, ולכן הספריה הסטנדרטית מספקת את הפונקציה `fs::read_to_string` שפותחת קובץ, יוצרת מופע חדש של `String`, קוראת את תוכן הקובץ, מאחסנת את התוכן לתוך מופע מטיפוס `String`, ומחזירה אותו. ההימנעות, לעיל, מהשימוש ב-`fs::read_to_string` סיפקה לנו הזדמנות להדגים בפירוט רב את מלאכת הטיפול בשגיאות בראסט.

#### מקומות בהם ניתן להשתמש באופרטור `?`

באופרטור `?` ניתן להשתמש רק בפונקציות בהן טיפוס הערך המוחזר תואם לערך עליו מפעילים את `?`. זאת משום שהאופרטור `?` מוגדר לבצע החזרה מוקדמת של ערך מהפונקציה, בדיוק כמו ביטוי ה-`match` שהגדרנו ברשימה 9-6. ברשימה 9-6, ביטוי ה-`match` עושה שימוש בערך `Result`, והזרוע של ההחזרה המוקדמת החזירה ערך מטיפוס `Err(e)`. טיפוס הערך המוחזר של הפונקציה חייב להיות `Result` כדי לתאום לפקודת `return` זו.

הבה נתבונן ברשימה 9-10. כאן מופיעה השגיאה שנקבל אם נשתמש באופרטור `?` בפונקציה `main`, בה טיפוס הערך המוחזר אינו תואם לטיפוס הערך עליו אנו מפעילים את האופרטור `?`:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}
```

<span class="caption">רשימה 9-10: ניסיון להשתמש ב-`?` בפונקציה `main` שמחזירה `()` לא יעבור קומפילציה</span>

קוד זה פותח את הקובץ, וזו פעולה שעלולה להכשל. האופרטור `?` פועל על ערך ה-`Result` שמוחזר על-ידי `File::open`, אבל הפונקציה `main` מוגדרת כמחזירה ערך מטיפוס `()`, לא `Result`. כאשר נקמפל קוד זה, נקבל את הודעת השגיאה הבאה:

```console
{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}
```

שגיאה זו מבהירה שניתן להפעיל את האופרטור `?` בתוך פונקציות שמחזירות `Result`, `Option`, או כל טיפוס אחר שמממש את התכונה `FromResidual`.

עומדות בפניכם שתי אפשרויות כדי לפתור את הבעיה. כל עוד אין מגבלות שמונעות זאת מכם, אפשרות אחת תהיה לשנות את טיפוס הערך המוחזר של הפונקציה כך שיהיה תואם לערך עליו אתם מפעילים את האופרטור `?`. האפשרות השניה היא להשתמש ב-`match` על אחת מהמתודות של `Result<T, E>` כדי לטפל ב-`Result<1>` בדרך נאותה.

הודעת השגיאה מזכירה שניתן להפעיל את `?` גם על ערכי `Option<T>`. כמו במקרה של הפעלת `?` על `Result`, ניתן להפעיל את `?` על `Option` בגוף של פונקציה שמחזירה `Option`. ההתנהגות של האופרטור `?` כאשר מפעילים אותו על `Option<T>` דומה להתנהגות כאשר הוא מופעל על `Result<T, E>`: אם הערך הוא `None`, ה- `None` יוחזר מהפונקציה בנקודה זו. אם הערך הוא `Some`, הערך הפנימי של ה- `Some` i יהיה הערך של הביטוי, והפונקציה תמשיך בריצה. רשימה 9-11 מציגה דוגמה לפונקציה שמוצאת את התו האחרון של השורה הראשונה בטקסט נתון:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}
```

<span class="caption">רשימה 9-11: שימוש באופרטור `?` על ערך `Option<T>`</span>

פונקציה זו מחזירה `Option<char>` כיוון שיתכן וקיים תו להחזרה, אבל יתכן גם שאין. קוד זה מקבל את חיתוך המחרוזת בארגומנט `text` וקורא עליו למתודה `lines`, שמחזירה איטרטור המאפשר מעבר על שורות המחרוזת. משום שפונקציה זו רוצה לבחון את השורה הראשונה, היא קוראת ל-`next` על האיטרטור על מנת לקבל את הערך הראשון מהאיטרטור. אם `text` הוא מחרוזת ריקה, קריאה זו ל-`text` תחזיר `None`, ובמקרה זה `?` יגרום לעצירת הפונקציה והחזרת הערך `None` מ-`last_char_of_first_line`. אם `text` i אינה מחרוזת ריקה, `next` תחזיר ערך `Some` שמכיל חיתוך מחרוזת של השורה הראשונה ב-`text`.

האופרטור `?` מגיש לנו את חיתוך המחרוזת הרצוי, ועליו אנו יכולים לקרוא למתודה `chars` בכדי לקבל איטרטור על התווים שבו. כיוון שאנו מעוניינים בתו האחרון שבשורה ראשונה זו, אנו קוראים ל-`last` כדי להחזיר את הפריט האחרון באיטרטור. זהו ערך מטיפוס `Option`, כיוון שיתכן שהשורה הראשונה היא מחרוזת ריקה, כגון מקרה שבו `text` מתחיל עם שורה ריקה ולאחריה כמה שורות לא ריקות, כמו `"\nhi"`. אבל, אם יש תו אחרון בשורה הראשונה, הוא יוחזר בתוך הווריאנט `Some`. האופרטור `?` באמצע מאפשר לנו דרך תמציתית לבטא לוגיקה תפעולית זו, ובכך מתאפשר לנו לממש פונקציה זו בשורה בודדת. אם לא היינו משתמשים באופרטור `?` על `Option`, היה עלינו לממש את הלוגיקה התפעולית הרצויה תוך שימוש במתודות נוספות, או באמצעות ביטוי `match`.

שימו לב שניתן להשתמש ב-`?` על `Result` בפונקציה שמחזירה `Result`, וניתן להשתמש באופרטור `?` על `Option` בפונקציה שמחזירה `Option`, אבל לא ניתן לערבב אפשרויות אלה. האופרטור `?` לא ממיר אוטומטית בין `Result` ל-`Option`; במקרים כאלה, ניתן להשתמש במתודות כמו `ok` על `Result` או המתודה `ok_or` על `Option` כדי לבצע המרות באופן מפורש.

עד כה, כל פונקציות ה-`main` החזירו `()`. `main` היא פונקציה מיוחדת כיוון שהיא נקודת הפתיחה והסיום של תכניות בעת הריצה. בכדי להבטיח שתכניות ראסט יתנהגו באופן צפוי, ראסט מטילה מגבלות על סוגי הערך המוחזר מפונקצית `main`.

עם זאת, למרבה המזל, `main` יכולה להחזיר את הטיפוס `Result<(), E>`. ברשימה 9-12 מופיע הקוד מרשימה 9-10, אבל שינינו את טיפוס הערך המוחזר של `main` ל-`Result<(), Box<dyn Error>>` והוספנו את הערך `Ok(())` בסופה. קוד זה עובר קומפילציה:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}
```

<span class="caption">רשימה 9-12: שינוי `main` כך שתחזיר `Result<(), E>` מאפשר שימוש באופרטור `?` על ערכי `Result`</span>

הטיפוס `Box<dyn Error>` הוא _אובייקט תכונה_, נושא בו נדון בסעיף ["שימוש באובייקטי תכונה שמאפשרים ערכים מטיפוסים שונים"][trait-objects]<!-- ignore --> בפרק 17. לעכשיו, תוכלו לחשוב על `Box<dyn Error>` כעל "כל סוג שהוא של שגיאה." שימוש ב- `?` על ערך `Result` בפונקציה `main` עם טיפוס השגיאה `Box<dyn Error>` מותר, כי הוא מאפשר לכל ערך `Err` להיות מוחזר מיידית. למרות שהגוף של פונקצית `main` זו תמיד יחזיר שגיאות מטיפוס `std::io::Error`, על-ידי ציון `Box<dyn Error>`, חותם זה ימשיך להיות תקף גם אם יתווסף לגוף ה-`main` קוד שמחזיר שגיאות אחרות.

כאשר פונקצית `main` מחזירה `Result<(), E>`, קובץ ההרצה יסיים עם ערך `0` אם `main` מחזירה `Ok(())`, ויסיים עם ערך שונה מ-0 אם `main` מחזירה ערך מווריאנט `Err`. קבצי הרצה שכתובים בשפת C מחזירים שלמים כאשר הם מסיימים: תכניות שמסיימות בהצלחה מחזירות `0`, ותכניות בהן ארעה שגיאה מחזירות ערך שלם כלשהו שונה מ-`0`. בהתאם למוסכמה זו, גם ראסט מחזירה שלמים מקבצי הרצה.

הפונקציה `main` רשאית להחזיר כל טיפוס שמממש את [the `std::process::Termination` trait][termination]<!-- ignore -->, שכולל את הפונקציה `report` that returns an `ExitCode`. פנו לתיעוד של הספריה הסטנדרטית למידע נוסף אודות מימוש התכונה `Termination` עבור טיפוסים משלכם.

לאחר שדנו בפרטים של קריאה ל-`panic!` והחזרת `Result`, הבה נחזור לנושא של בחירה נאותה בין שתי אפשרויות אלה.

[handle_failure]: ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result
[trait-objects]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[termination]: ../std/process/trait.Termination.html