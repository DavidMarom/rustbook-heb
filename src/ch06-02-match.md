<!-- Old heading. Do not remove or links may break. -->

<a id="the-match-control-flow-operator"></a>

## המבנה התחבירי `match` לבקרת זרימה

לראסט יש מבנה תחבירי עוצמתי מאוד שנקרא `match` , שמאפשר לכם להשוות ערך נתון מול סדרה של דפוסים ולהריץ את פיסת הקוד המתאימה לערך. דפוסים יכולים להיות מורכבים מערכים מפורשים, שמות משתנים, תווים כלליים (wildcards), ודברים רבים אחרים; [פרק 18][ch18-00-patterns]<!-- ignore --> מכסה את כל הסוגים השונים של דפוסים, ודרך פעולתם. מקור הכח של `match` הוא יכולת הביטוי של הדפוסים, והעובדה שהקומפיילר מוודא שכל הסיטואציות האפשריות מטופלות עבור הערך הנידון.

חשבו על ביטוי `match` כמו על מכונה למיון מטבעות: מטבעות מחליקים במורד משפך עם חורים בגדלים שונים, וכל מטבע נופל לתוך החור הראשון שלתוכו הוא מתאים. באותו אופן, ערכים עוברים דרך כל דפוס ב-`match`, והדפוס הראשון שלתוכו ערך מסוים "מתאים," מופנה לבלוק הקוד המשוייך לדפוס, לשימושו בזמן הריצה.

אם כבר אנחנו מדברים על מטבעות, הבה נבנה דוגמה סביבם לשימוש ב-`match`! אנחנו יכולים לכתוב פונקציה שמקבלת מטבע לא ידוע (נניח מסדרת המטבעות הסטנדרטית בארצות-הברית), וכמו מכונת הספירה, קובעת איזה מטבע זה, ומחזירה את ערכו בסנטים. רשימה 6-3 מציגה זאת:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-03/src/main.rs:here}}
```

<span class="caption">רשימה 6-3: מבחר וביטוי `match` שבו הדפוסים הם הווריאנטים של המבחר</span>

הבה נפרוט את ה-`match` בפונקציה `value_in_cents`. ראשית, לאחר מילת המפתח `match` מופיע ביטוי, שבמקרה זה הוא הערך `coin`. זה נראה מאוד דומה לביטוי התנאי ב- `if`, אבל יש הבדל גדול: עם `if` על התנאי להיות מוערך לערך בוליאני, אך כאן הוא יכול להיות מכל טיפוס שהוא. הטיפוס של `coin` בדוגמה זו הוא המבחר `Coin` שאותו הגדרנו בשורה הראשונה.

לאחר מכן מגיעות זרועות ה- `match`. לזרוע יש שני חלקים: דפוס וקוד. הזרוע הראשונה תואמת לדפוס שהוא הערך `Coin::Penny` ולאחריו האופרטור `=>` שמפריד בין הדפוס לבין הקוד להרצה. הקוד במקרה זה הוא פשוט הערך `1`. כל זרוע מופרדת מהבאה אחריה ע"י פסיק.

כאשר ביטוי ה- `match` רץ, הוא משווה את הערך שהוא תוצאת הביטוי עליו מוגדר ה- `match` אל מול הדפוס בכל זרוע, לפי הסדר בו הן מופיעות. אם דפוס מסוים תואם את הערך, הקוד המשוייך לדפוס זה יבוצע. אם הדפוס אינו תואם את הערך, הקוד ממשיך אל הזרוע הבאה, בדומה לפעולת מכונת מיון מטבעות. ניתן כמובן להוסיף זרועות כפי הצורך: ברשימה 6-3, ל-`match` יש ארבע זרועות.

הקוד המשוייך לכל זרוע הוא ביטוי, והערך שהוא תוצאת הביטוי בזרוע התואמת הוא הערך שמוחזר עבור ביטוי ה-`match` כולו.

אם הקוד בזרוע מסויימת הוא קצר, כמו למשל ברשימה 6-3, שם כל זרוע פשוט מחזירה ערך, לרוב לא נעשה שימוש בסוגריים מסולסלים. לעומת זאת, אם רוצים להריץ כמה שורות קוד בזרוע מסויימת, אז חייבים להשתמש בסוגריים מסולסלים, ובמקרה זה הפסיק המפריד בין זרועות הוא אופציונאלי. למשל, הקוד הבא מדפיס “Lucky penny!” בכל פעם שהמתודה נקראת עם הערך `Coin::Penny`, אבל עדיין מחזיר את הערך האחרון של הבלוק, דהיינו `1`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-08-match-arm-multiple-lines/src/main.rs:here}}
```

### דפוסים שנקשרים לערכים

תכונה שימושית נוספת של זרועות match היא שהן יכולות להיקשר לחלקים של הערך שמותאם לדפוס. תכונה זו מקנה דרך להפיק ערכים מתוך וריאנטים של מבחר.

כדוגמה, הבה נשנה את אחד הווריאנטים של המבחר כך שיאכסן בתוכו דאטה. ב-1999 עד 2008, ארצות-הברית הנפיקה מטבעות של רבע-דולר בעיצוב שונה של אחד הצדדים לכל אחת מ-50 המדינות. לשאר המטבעות היו עיצובים אחידים, כך שרק למטבעות רבע-דולר יש ערך נוסף זה. ניתן להוסיף מידע זה למבחר שלנו ע"י שינוי הווריאנט `Quarter` כך שיכיל ערך `UsState`, כפי שעשינו ברשימה 6-4.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-04/src/main.rs:here}}
```

<span class="caption">רשימה 6-4: המבחר `Coin` בו הווריאנט `Quarter` מאכסן ערך בשם `UsState`</span>

הבה נדמיין שחברים שלנו מנסים לאסוף מטבעות רבע-דולר מכל 50 המדינות. בעודנו ממיינים את הכסף הקטן שלנו לפי סוג מטבע, נשים לב גם לשם המדינה המשוייכת לכל רבע-דולר, וכך אם נמצא מטבע שלחברים שלנו עוד אין באוסף, הם יוכלו להוסיף אותו.

בביטוי ההתאמה עבור קוד זה, נוסיף לדפוס משתנה בשם `state` שתואם לערכים של הווריאנט `Coin::Quarter`. כאשר `Coin::Quarter` מותאם, המשתנה `state` ייקשר לערך של שם המדינה המשוייך למטבע רבע-דולר זה. כך נוכל להשתמש ב-`state` בקוד עבור הזרוע הרלוונטית, בצורה הבאה:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-09-variable-in-pattern/src/main.rs:here}}
```

לו היינו קוראים ל- `value_in_cents(Coin::Quarter(UsState::Alaska))` אז המשתנה `coin` יקבל את הערך `Coin::Quarter(UsState::Alaska)`. כאשר אנו משווים ערך זה מול זרועות ההתאמה, אף אחת מהן לא מותאמת עד שמגיעים ל- `Coin::Quarter(state)`. בשלב זה, הקישור עבור `state` יהיה לערך `UsState::Alaska`. ואז ניתן להשתמש בביטוי `println!`, וכך לקבל גישה לשם המדינה, שהוא הערך הפנימי בווריאנט `Quarter` של המבחר `Coin`.

### התאמה עם `<Option<T`

בסעיף הקודם, כאשר השתמשנו ב- `Option<T>`, רצינו לקרוא את הערך הפנימי מטיפוס `T` שבתוך `Some`. ניתן גם לטפל ב-`Option<T>` באמצעות `match`, כפי שעשינו עם המבחר `Coin`! במקום להשוות מטבעות, אנו נשווה ווריאנטים של `Option<T>`, אבל האופן בו ביטוי ה- `match` עובד לא משתנה.

נניח שאנחנו רוצים לכתוב פונקציה שלוקחת `Option<i32>` ומוסיפה אחד לערך הפנימי, במידה ויש כזה. אם אין ערך פנימי, אז הפונקציה צריכה להחזיר את הערך `None` ולא לנסות לבצע פעולות.

הודות ליכולות של `match` פונקציה זו מאוד קלה לכתיבה, והיא נראית כמו שמוצג ברשימה 6-5.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:here}}
```

<span class="caption">רשימה 6-5: פונקציה שמשתמשת בביטוי `match` על ערך מטיפוס `Option<i32>`</span>

הבה נבחן את הריצה הראשונה של `plus_one` בפירוט מסויים. כאשר אנו קוראים ל-`plus_one(five)`, המשתנה `x` שבגוף הפונקציה `plus_one` יכיל את הערך `Some(5)`. אז נשווה זאת מול כל אחת מזרועות ההתאמה:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

הערך `Some(5)` לא מותאם לדפוס `None` ולכן אנו ממשיכים לזרוע הבאה:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:second_arm}}
```

האם `Some(5)` מותאם ל- `Some(i)`? כן, בהחלט! יש לנו את אותו הווריאנט. הערך `i` מקושר לערך שנמצא בתוך ה- `Some`, ולכן `i` מקבל את הערך `5`. הקוד בזרוע זו של ההתאמה מבוצע, ולכן אנו מוסיפים 1 לערך ב- `i` ויוצרים ערך `Some` חדש ובו הערך הפנימי `6`.

עכשיו, הבה נבדוק את הקריאה השניה ל- `plus_one` מרשימה 6-5, שם `x` שווה ל-`None`. אנחנו נכנסים ל- `match` ומשווים לזרוע הראשונה:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

יש לנו התאמה! אין שום ערך להוסיף לו דבר, ולכן התכנית עוצרת ומחזירה את הערך `None` שבצד ימין של האופרטור `=>`. מכיוון שהזרוע הראשונה הותאמה, לא מתבצע נסיון להתאים לשאר הזרועות.

שילוב של `match` עם מבחרים הוא יעיל בסיטואציות רבות. אתם תתקלו בדפוס תכנות זה לא מעט בקוד ראסט: `match` כנגד מבחר, קשירת משתנה לדאטה פנימי, ואז הרצת קוד בהתאם. זה מצריך קצת מחשבה בהתחלה, אבל ברגע שתתרגלו לזה, לא תבינו איך הסתדרתם בלי. זו טכניקה אהובה בקרב מתכנתי ראסט.

### התאמות חייבות למצות את כל האפשרויות

ישנו היבט אחר של `match` בו עלינו לדון: ככלל, הדפוסים המפורטים בזרועות חייבים יחדיו למצות את כל האפשרויות. כלומר, לא יתאפשר מצב בו עשוי להתקבל ערך כלשהו כאשר אין זרוע המסוגלת להתאים לו ולטפל בו. הקומפיילר לא יאפשר זאת. קחו למשל את הגרסה הזו של הפונקציה `plus_one`, יש בה באג והיא לא עוברת קומפילציה:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/src/main.rs:here}}
```

לא טיפלנו במקרה שהערך הוא `None`, ולכן הקוד יגרום לבאג. למרבה המזל, זהו באג שראסט יודעת לתפוס. אם ננסה לקמפל את הקוד הזה, נקבל את השגיאה הזו:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt}}
```

ראסט יודעת שלא כיסינו את כל האפשרויות שהמשתנה עליו מבוצעת ההתאמה יכול לקבל, ואפילו יודעת איזה דפוס שכחנו! התאמות בראסט חייבות להיות _ממצות_: עלינו למצות את כל האפשרויות, עד האחרונה, על מנת שהקוד יהיה תקף. ביחוד במקרה של `Option<T>`, כאשר ראסט לא מאפשרת לנו שלא לטפל מפורשות במקרה בו הערך הוא `None`. היא לא מאפשרת לנו מלהניח שיש לנו ערך כאשר עלול להתקבל .null כך הופכת ראסט את טעות ביליון הדולר לבלתי-אפשרית.

### דפוסים תופסי-כל (catch-all) ושומר המקום (placeholder) `_`

בשימוש במבחרים, יש באפשרותינו לנקוט בפעולות יחודיות עבור ערכים ספציפיים, ולפעול באמצעות ברירת מחדל עבור כל הערכים האחרים. כך למשל, נניח שאנו מיישמים משחק בו, אם מגלגלים 3 בקוביות, השחקן לא זז, ובמקום זאת מקבל כובע מסוגנן חדש; אם מגלגלים 7, השחקן מאבד כובע; עבור שאר הערכים, השחקן מתקדם על הלוח לפי המספר על הקוביות. הנה יישום של הלוגיקה הזו באמצעות `match`, בו תוצאת זריקת הקוביות מקודדת ישירות במקום כערך משני, וכל שאר הלוגיקה מיוצגת על-ידי פונקציות (ללא יישום של גוף הפונקציות, כיוון שלמטרות הדוגמה אין בכך צורך):

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-15-binding-catchall/src/main.rs:here}}
```

עבור שתי הזרועות הראשונות, הדפוסים הם הערכים המפורשים `3` ו-`7`. עבור הזרוע האחרונה שמכסה את כל שאר האפשרויות, הדפוס הוא המשתנה שבחרנו לקרוא בשם `other`. הקוד שרץ בזרוע `other` משתמש במשתנה הזה על-ידי העברתו לפונקציה `move_player`.

קוד זה עובר קומפילציה אפילו שלא מנינו את כל הערכים ש-`u8` יכול לקבל, וזאת משום שהדפוס האחרון יותאם לכל ערך שלא הופיע מפורשות. דפוס תופס-כל זה עונה לדרישה שכל ביטוי `match` חייב להיות ממצה. שימו לב שעלינו למקם את הזרוע הכוללת הזאת כזרוע האחרונה, כיוון שהזרועות מוערכות לפי סדר הופעתן בקוד. במידה ונמקם זרוע כוללת מוקדם יותר, שאר הזרועות לא ירוצו אף-פעם. למרבה המזל, ראסט תזהיר אותנו במקרה בו אנו מוסיפים זרועות לאחר זרוע כוללת!

לראסט יש גם דפוס בו ניתן להשתמש כאשר אנו רוצים דפוס תופס-כל, אבל לא רוצים _להשתמש_ בערך עצמו: .`_` זהו דפוס מיוחד המותאם לכל ערך שהוא, אך לא נקשר לערך הזה. כך אנו אומרים לראסט שאנחנו לא עומדים להשתמש בערך עצמו, וכך ראסט לא תפיק אזהרה אודות ערך שאינו בשימוש.

הבה נשנה את חוקי המשחק: עכשיו, אם מגלגלים כל תוצאה חוץ מ-3 או 7, יש לגלגל שוב. עכשיו אין צורך להשתמש בערך במקרה הכולל, ולכן אנחנו יכולים לשנות את הקוד שלנו להשתמש ב-`_` במקום בשם המשתנה `other`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-16-underscore-catchall/src/main.rs:here}}
```

גם דוגמה זו עונה לדרישה למצות את כל האפשרויות, כיוון שאנחנו מתעלמים מפורשות מכל הערכים בזרוע האחרונה; לא שכחנו דבר.

לבסוף, נשנה את חוקי המשחק פעם נוספת כך ששום דבר לא קורה אם מגלגלים כל מספר זולת 3 או 7. נוכל לבטא זאת באמצעות שימוש בערך unit (הרצף הריק עליו דיברנו בסעיף [“The Tuple Type”][tuples]<!-- ignore --> ) כקוד המשוייך לזרוע `_`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-17-underscore-unit/src/main.rs:here}}
```

כאן, אנו אומרים לראסט באופן מפורש שאנחנו לא הולכים להשתמש באף ערך שלא הותאם בזרוע קודמת, וגם שבמקרה כזה אנחנו לא מעוניינים להריץ קוד כלל.

נוסיף להעמיק בדפוסים ובהתאמות [בפרק 18][ch18-00-patterns]<!-- ignore -->. בשלב זה נעבור הלאה לדבר על התחביר `if let`, שהוא שימושי בסיטואציות בהן ביטוי `match` הוא סבוך שלא לצורך.

[tuples]: ch03-02-data-types.html#the-tuple-type
[ch18-00-patterns]: ch18-00-patterns.html
[ch18-00-patterns]: ch18-00-patterns.html
