<!-- Old heading. Do not remove or links may break. -->
<a id="the-match-control-flow-operator"></a>

## המבנה התחבירי `match` לבקרת זרימה

לראסט יש מבנה תחבירי עצמתי מאוד שנקרא `match` שמאפשר לכם להשוות ערך מול סדרה של דפוסים ולהריץ קוד בהתאם לדפוס שמותאם לערך. דפוסים יכולים להיות מורכבים מערכים מפורשים, שמות משתנים, תווים כלליים (wildcards), ודברים רבים אחרים; [Chapter 18][ch18-00-patterns]<!-- ignore --> מכסה את כל הסוגים השונים של דפוסים, ודרך פעולתם. מקור הכח של `match` הוא יכולת הביטוי של הדפוסים והעובדה שהקומפיילר מוודא שכל הסיטואציות האפשריות עבור הערך הרלוונטי מטופלות.

חשבו על ביטוי `match` כמו על מכונה למיון מטבעות: מטבעות מחליקים במורד משפך עם חורים בגדלים שונים, וכל מטבע נופל לתוך החור הראשון שלתוכו הוא מתאים. באותה דרך, ערכים עוברים דרך כל דפוס ב-`match`, והדפוס הראשון שלתוכו ערך מסוים "מתאים", מופנה לבלוק הקוד המשוייך לדפוס לשימושו בזמן הריצה.

אם כבר אנחנו מדברים על מטבעות, הבה נבנה דוגמא סביבם לשימוש ב-`match`! אנחנו יכולים לכתוב פונקציה שמקבלת מטבע לא ידוע (נניח מסדרת המטבעות הסטנדרטית בארצות הברית), בדרך דומה למכונת הספירה, קובעת איזה מטבע זה ומחזירה את ערכו בסנטים, כפי שמוצג ברשימה 6-3.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-03/src/main.rs:here}}
```


<span class="caption">רשימה 6-3: מבחר וביטוי `match` שבו הדפוסים הם הווריאנטים של המבחר</span>

הבה נפרוט את ה-`match` בפונקציה `value_in_cents`. ראשית, לאחר מילת המפתח `match` מופיע ביטוי, שבמקרה זה הוא הערך `coin`. זה נראה מאוד דומה לביטוי התנאי ב- `if`, אבל יש הבדל גדול: עם `if` על התנאי להיות מוערך לערך בוליאני, אבל כאן הוא יכול להיות מכל טיפוס שהוא. הטיפוס של `coin` בדוגמא זו הוא המבחר `Coin` שאותו הגדרנו בשורה הראשונה.

אח"כ מגיעות זרועות ה- `match`. לזרוע יש שני חלקים: דפוס וקוד. לזרוע הראשונה כאן יש את הדפוס שהוא הערך `Coin::Penny` ולאחריו האופרטור `=>` שמפריד בין הדפוס לבין הקוד להרצה. הקוד במקרה זההוא פשוט הערך `1`. כל זרוע מופרדת מהבאה אחריה ע"י פסיק.

כאשר ביטוי ה- `match` רץ, הוא משווה את הערך שהוא תוצאת הביטוי עליו ה- <0>match</0> מוגדר כנגד הדפוס בכל זרוע, לפי סדרן. אם דפוס תואם את הערך, אז הקוד המשוייך לדפוס זה יבוצע. אם הדפוס אינו תואם את הערך, אז הביצוע זורם אל הזרוע הבאה, בדומה לפעולת מכונת מיון מטבעות. ניתן להוסיף זרועות כפי הצורך: ברשימה 6-3, ל-`match` יש ארבע זרועות.

הקוד המשוייך לכל זרוע הוא ביטוי, והערך שהוא תוצאת הביטוי בזרוע התואמת הוא הערך שמוחזר עבור על ביטוי ה-`match`.

אם הקוד בזרוע מסויימת הוא קצר, כמו למשל ברשימה 6-3 שם כל זרוע פשוט מחזירה ערך, אז בדר"כ לא משתמשים בסוגריים מסלוסלות. אם רוצים להריץ כמה שורות קוד בזרוע מסויימת, אז חייבים להשתמש בסוגריים מסולסלים, ובמקרה זה הפסיק המפריד בין זרועות הוא אופציונאלי. למשל, הקוד הבא מדפיס “Lucky penny!” בכל פעם שהמתודה נקראת עםא הערך `Coin::Penny`, אבל עדיין מחזיר את הערך האחרון של הבלוק, `1`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-08-match-arm-multiple-lines/src/main.rs:here}}
```

### דפוסים שנקשרים לערכים

תכונה שימושית נוספת של זרועות match היא שהן יכולות להיקשר לחלקים של הערך שמותאם לדפוס. הינה כיצד להפיק ערכים מתוך ווריאנטים של מבחר.

כדוגמא, הבה נשנה את אחד הווריאנטים של המבחר כך שיאכסן בתוכו דאטה. ב-1999 עד 2008, ארצות הברית הנפיקה מטבעות של רבע-דולר בעיצוב שונה של אחד הצדדים לכל אחת מ-50 המדינות. לשאר המטבעות היו עיצובים אחידים, כך שרק למטבעות רבע-דולר יש ערך נוסף זה. ניתן להוסיף מידע זה למבחר שלנו ע"י שינוי הווריאנט `Quarter` כך שיכיל ערך `UsState`, כפי שעשינו ברשימה 6-4.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-04/src/main.rs:here}}
```


<span class="caption">רשימה 6-4: המבחר `Coin` בו הווריאנט `Quarter` מאכסן ערך `UsState`</span>

הבה נדמיין שחברים שלנו מנסים לאסוף מטבעות רבע-דולר מכל 50 המדינות. בעודנו ממיינים את הכסף הקטן שלנו לפי סוג מטבע, נשים לב גם לשם המדינה המשוייכת לכל רבע-דולר, וכך אם נמצא מטבע שלחברים שלנו עוד אין באוסף, הם יוכלו להוסיף אותו.

בביטוי ההתאמה עבור קוד זה, נוסיף לדפוס משתנה בשם `state` שתואם לערכים של הווריאנט `Coin::Quarter`. כאשר `Coin::Quarter` מותאם, המשתנה `state` ייקשר לערך של שם המדינה המשוייך למטבע רבע-דולר זה. כך נוכל להשתמש ב-`state` בקוד עבור הזרוע הרלוונטית, בצורה הבאה:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-09-variable-in-pattern/src/main.rs:here}}
```

לו היינו קוראים ל- `value_in_cents(Coin::Quarter(UsState::Alaska))` אז המשתנה `coin` יקבל את הערך `Coin::Quarter(UsState::Alaska)`. כאשר אנו משווים ערך זה מול זרועות ההתאמה, אף אחת מהן לא מותאמת עד שמגיעים ל- `Coin::Quarter(state)`. בשלב זה, הקישור עבור `state` יהיה לערך `UsState::Alaska`. ואז ניתן להשתמש בביטוי `println!`, וכך לקבל גישה לשם המדינה, שהוא הערך הפנימי בווריאנט `Quarter` של המבחר `Coin`.

### התאמה עם `Option<T>`

בסעיף הקודם רצינו לקרוא את הערך הפנימי מטיפוס `T` שבתוך `Some` כאשר השתמשנו ב- `Option<T>`; ניתן גם לטפל ב- `Option<T>` באמצעות `match`, כפי שעשינו עם המבחר `Coin`! במקום להשוות מטבעות, אנו נשווה ווריאנטים של `Option<T>`, אבל האופן בו ביטוי ה- `match` עובד לא משתנה.

נניח שאנחנו רוצים לכתוב פונקציה שלוקחת `Option<i32>` ומוסיפה אחד לערך הפנימי, במידה ויש כזה. אם אין ערך פנימי, אז הפונקציה צריכה להחזיר את הערך `None` ולא לנסות לבצע פעולות.

הודות ליכולות של `match` פונקציה זו מאוד קלה לכתיבה, והיא נראית כמו שמוצג ברשימה 6-5.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:here}}
```


<span class="caption">רשימה 6-5: פונקציה שמשתמשת בביטוי `match` על ערך מטיפוס `Option<i32>`</span>

הבה נבחן את הריצה הראשונה של `plus_one` בפירוט מסויים. כאשר אנו קוראים ל-`plus_one(five)`, המשתנה `x` שבגוף הפונקציה `plus_one` יכיל את הערך `Some(5)`. אז אנחנו משווים זאת מול כל אחת מזרועות ההתאמה:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

הערך `Some(5)` לא מותאם לדפוס `None` ולכן אנו ממשיכים לזרוע הבאה:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:second_arm}}
```

האם `Some(5)` מותאם ל- `Some(i)`? כן, בהחלט! יש לנו את אותו הווריאנט. הערך `i` מקושר לערך שנמצא בתוך ה- `Some`, ולכן `i` מקבל את הערך `5`. הקוד בזרוע זו של ההתאמה מבוצעת, ולכן אנו מוסיפים 1 לערך ב- `i` ויוצרים ערך `Some` חדש ובו הערך הפנימי `6`.

עכשיו, הבה נבדוק את הקריאה השניה ל- `plus_one` מרשימה 6-5, שם `x` שווה ל-`None`. אנחנו נכנסים ל- `match` ומשווים לזרוע הראשונה:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

יש לנו התאמה! אין שום ערך להוסיף לו דבר, ולכן התכנית עוצרת ומחזירה את הערך `None` שבצד ימין של האופרטור `=>`. מכיוון שהזרוע הראשונה הותאמה, לא מתבצע נסיון להתאים לשאר הזרועות.

שילוב של `match` עם מבחרים הוא יעיל בסיטאציות רבות. אתם תתקלו בדפוס תכנות זה רבות בקוד ראסט: `match` כנגד מבחר, קישור משתנה לדאטה פנימי, ואז הרצת קוד בהתאם. זה מצריך קצת מחשבה בהתחלה, אבל ברגע שתתרגלו לזה, לא תבינו איך הסתדרתם בלי זה. זה באופן עקבי תכונה חביב על משתמשים.

### התאמות חייבות למצות

ישנו אספק אחר של `match` עליו עלינו לדון: הדפוסים על פני כל הזרועות חייבים למצות את כל האפשרויות. קחו למשל את הגרסה הזו של הפונקציה `plus_one`, יש בה באג והיא לא עוברת קומפילציה:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/src/main.rs:here}}
```

לא טיפלנו במקרה שהערך הוא `None`, ולכן הקוד יגרום לבאג. למרבה המזל, זהו באג שראסט יודעת לתפוס. אם ננסה לקמפל את הקוד הזה, נקבל את השגיאה הזו:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt}}
```

ראסט יודעת שלא כיסינו את כל האפשרויות שהמשתנה עליו ההאמה מבוצעת יכול לקבל, ואפילו יודעת איזה דפוס שכחנו! התאמות בראסט חייבות להיות *ממצות*: עלינו למצות את כל האפשרויות עד האחרונה שבהן על מנת שהקוד יהיה תקף. ביחוד במקרה של `Option<T>`, כאשר ראסט מונעת מאיתנו מלשכוח לטפל מפורשות במקרה שהערך הוא `None`, היא שומרת עלינו מלהניח שיש לנו ערך כאשר ייתכן שיש לנו null, וכך הופכת את טעות ביליון הדולר מהסעיף הקודם לבלתי אפשרית.

### דפוסים תופסי-כל (catch-all) ואוחז המקום (placeholder) `_`

תוך שימוש במבחרים, ניתן לנקוט בפעולות יחודיות עבור ערכים ספציפיים, ולפעול באמצעות ברירת מחדל עבור כל הערכים האחרים. למשל, במקרה בו אנו מיישמים משחק בו אם מגלגלים 3 בקוביות, השחקן לא זז, ובמקום זאת מקבל כובע מסוגנן חדש. אם מגלגלים 7, השחקן מאבד כובע. לכל שאר הערכים, השחקן מתקדם על הלוח לפי המספר על הקוביות. הינה יישום של הלוגיקה הזו באמצעות `match`, בו תוצאת זריקת הקוביות מקודדת ישירות במקום כערך משני, וכל שאר הלוגיקה מיוצגת ע"י פונקציות ללא יישום של גופן כיוון שיישום כזה הוא מעבר למטרת הדוגמא:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-15-binding-catchall/src/main.rs:here}}
```

עבור שתי הזרועות הראשונות, הדפוסים הם הערכים המפורשים `3` ו-`7`. עבור הזרוע האחרונה שמכסה את כל שאר האפשרויות, הדפוס הוא המשתנה שבחרנו לקרוא בשם `other`. הקוד שרץ בזרוע `other` משתמש במשתנה הזה ע"י העברתו לפונקציה `move_player`.

קוד זה עובר קומפילציה אפילו שלא מנינו את כל הערכים ש-`u8` יכול לקבל, וזאת משום שהדפוס האחרון יותאם לכל ערך שלא הופיע מפורשות. דפוס תופס-כל זה עונה לדרישה שכל ביטוי `match` חייב להיות ממצה. שימו לב שעלינו למקם את הזרוע הכוללת הזאת כזרוע האחרונה מכיוון שהזרועות מוערכות לפי סדרן. במידה ונמקם זרוע כוללת מוקדם יותר, שאר הזרועות לא ירוצו אף-פעם, ולכן ראסט תזהיר אותנו במקרה בו אנו מוסיפים זרועות לאחר זרוע כוללת!

לראסט יש גם דפוס בו ניתן להשתמש כאשר אנו רוצים דפוס תופס-כל אבל לא רוצים *להשתמש* בערך עצמו שבדפוס: `_` הוא דפוס מיוחד שמותאם לכל ערך שהו אבל לא נקשר לערך הזה. בצורה זו אנו אומרים לראסט שאנחנו לא עומדים להשתמש בערך עצמו, וכך ראסט לא תזהיר אותנו אודות ערך שאינו בשימוש.

הבה נשנה את חוקי המשחק: עכשיו, אם מגלגלים כל תוצאה חוץ מ-3 או 7, יש לגלגל שוב. עכשיו אין צורך להשתמש בערך במקרה הכולל, ולכן אנחנו יכולים לשנות את הקוד שלנו להשתמש ב-`_` במקום בשם המשתנה `other`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-16-underscore-catchall/src/main.rs:here}}
```

גם דוגמא זו עונה לדרישה למצות את כל האפשרויות, כיוון שאנחנו מתעלמים מפורשות מכל הערכים בזרוע האחרונה; לא שכחנו דבר.

לבסוף, נשנה את חוקי המשחק פעם נוספת כך ששום דבר נוסף לא קורה בתורך אם מגלגלים כל מספר חוץ מ-3 או 7. נוכל לבטא זאת באמצעות שימוש בערך unit (הרצף הריק עליו דיברנו בסעיף [“The Tuple Type”][tuples]<!-- ignore --> ) כקוד המשוייך לזרוע `_`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-17-underscore-unit/src/main.rs:here}}
```

כאן, אנו אומרים לראסט באופן מפורש שאנחנו לא הולכים להשתמש באף ערך שלא הותאם בזרוע קודמת, וגם שבמקרה זה אנחנו לא מעוניינים להריץ קוד כלל.

נוסיף להעמיק בדפוסים ובהתאמות [בפרק 18][ch18-00-patterns]<!-- ignore -->. בשלב זה נעבור הלאה לדבר על התחביר `if let`, שהוא שימושי בסיטואציות בהן ביטוי `match` סבוך שלא לצורך.

[tuples]: ch03-02-data-types.html#the-tuple-type
[ch18-00-patterns]: ch18-00-patterns.html
[ch18-00-patterns]: ch18-00-patterns.html
