## מסלולים להפניה לעצם בתוך עץ המודולים

כדי להראות לראסט היכן נמצא עצם מסויים בעץ המודולים, ניתן להשתמש במסלול באותה הדרך בה משתמשים במסלול כאשר מנווטים את מערכת הקבצים. בכדי לקרוא לפונקציה, עלינו לדעת את המסלול אליה.

מסלול יכול להיות באחת משתי צורות:

* *מסלול אבסולוטי* הוא המסלול המלא, החל ממכולת הבסיס; עבור קוד ממכולה חיצונית, המסלול המלא מתחיל עם שם המכולה, ועבור קוד מהמכולה הנוכחית, שם המסלול מתחיל במילה `crate`.
* *מסלול יחסי* מתחיל מהמודול הנוכחי ומשתמש ב- `self`, `super`, או מציין כלשהו במודול הנוכחי.

במסלולים אבסולוטיים ויחסיים כאחד משתמשים במציינים המופרדים ע"י נקודותיים כפולות (`::`).

הבה נחזור לרשימה 7-1, ונניח שאנו רוצים לקרוא לפונקציה `add_to_waitlist`. עלינו לענות על השאלה: מהו המסלול אל הפונקציה `add_to_waitlist`? רשימה 7-3 מכילה את תוכן רשימה 7-1 בהסרת כמה פונקציות ומודולים.

נראה שתי דרכים לקרוא לפונקציה `add_to_waitlist` מתוך הפונקציה החדשה `eat_at_restaurant` שמוגדרת בבסיס המכולה. מסלולים אלה נכונים, אבל נותרה עוד בעיה אחת שמונעת מדוגמא זו לעבור קומפילציה כמו שהיא. נסביר מדוע בעוד כמה רגעים.

הפונקציה `eat_at_restaurant` היא חלק מה-API של מכולת הספריה שלנו, ולכן אנו מסמנים אותה במילת המפתח `pub`. בסעיף ["חשיפת מסלולים באמצעות מילת המפתח `pub`"][pub]<!-- ignore --> , נדון בפירוט בשימוש ב-`pub`.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}
```


<span class="caption">רשימה 7-3: קריאה לפונקציה `add_to_waitlist` תוך שימוש במסלולים אבסולוטיים</span>

בפעם הראשונה בה אנו קוראים לפונקציה `add_to_waitlist` ב- `eat_at_restaurant`, אנו משתמשים במסלול אבסולוטי. הפונקציה `add_to_waitlist` מוגדרת באותה המכולה כמו `eat_at_restaurant`, ולכן ניתן להשתמש במילת המפתח `crate` כתחילת המסלול. ואז אנו משרשרים את שמות המודולים בעודנו עושים את דרכנו אל `add_to_waitlist`. תוכלו לדמיין מערכת קבצים עם אותו המבנה: נציין את המסלול `/front_of_house/hosting/add_to_waitlist` כדי להריץ את התכנית `add_to_waitlist`; שימוש בשם `crate` כדי לציין את בסיס המכולה כנקודת ההתחלה שקול לשימוש מתוך המעטפת ב- `/` כדי לציין את בסיס מערכת הקבצים כנקודת ההתחלה.

בפעם השניה בה אנו קוראים ל-`add_to_waitlist` ב-`eat_at_restaurant`, אנו משתמשים במסלול יחסי. המסלול מתחיל ב-`front_of_house`, שם המודול שמוגדר בעץ המודולים באותה הרמה בה `eat_at_restaurant` מוגדר. המקבילה בעולם מערכת הקבצים במקרה זה תהיה שימוש במסלול `front_of_house/hosting/add_to_waitlist`. התחלת מסלול בשם של מודול משמעה שהמסלול יחסי.

הבחירה באם להשתמש במסלול יחסי או אבסולוטי היא החלטה שתקבלו בהתאם לפרוייקט, והיא תלויה בסבירות שתעבירו הגדרת עצם זה או אחר בנפרד או ביחד עם הקוד שמשתמש בעצם הזה. למשל, אם נעביר את המודול `front_of_house` ואת הפונקציה `eat_at_restaurant` לתוך מודול בשם `customer_experience`, נאלץ לעדכן את המסלול האבסולוטי ל- `add_to_waitlist`, אבל המסלול היחסי לא ישתנה. לאומת זאת, במידה ונעביר את הפונקציה `eat_at_restaurant` בנפרד לתוך מודול בשם `dining`, המסלול האבסולוטי לקריאה של `add_to_waitlist` לא ישתנה, בעוד שאת המסלול היחסי יהיה צריך לעדכן. ההעדפה שלנו באופן כללי היא לציין מסלולים אבסולוטיים מכיוון שיותר סביר שנרצה להעביר הגדרות קוד וקריאות לעצמים באופן בלתי תלוי זה בזה.

הבה ננסה לקמפל את הקוד מרשימה 7-3 ונגלה מדוע נכשל! השגיאה שנקבל מוצגת ברשימה 7-4.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
```


<span class="caption">רשימה 7-4: שגיאות קומפילציה בעקבות בניית הקוד ברשימה 7-3</span>

הודעות השגיאה מתריאות שהמודול `hosting` הוא פרטי. במילים אחרות, אנו משתמשים במסלולים הנכונים עבור המודול `hosting` והפונקציה `add_to_waitlist`, אבל ראסט לא מאפשרת לנו להשתמש בהם בגלל שאין לה גישה לחלקים הפרטיים. כברירת מחדל, כל העצמים בראסט (פונקציות, מתודות, מבחרים, מודולים, וקבועים) הם פרטיים בפני מודולי-אב. אם תרצו להפוך עצם כמו פונקציה או מבנה לפרטי, שימו אותו במודול.

עצמים במודול-אב לא יכולים להשתמש בעצמים פרטיים בתוך מודולי-בנים שלכם, אבל עצמים במודולי-בנים יכולים להשתמש בעצמים הנמצאים במודולי-האב שלהם (לכל דורותיהם). זאת משום שמודולי-בנים גוללים ומחביאים את פרטי היישומים שלהם, אבל מודולי-בנים יכולים לראות את הקונטקסט בו הם מוגדרים. כדי להמשיך עם המטפורה, חשבו על חוקי הפרטיות כעל מה שמתרחש בחלק המשרדי של מסעדה: מה שקורה שם הוא פרטי ביחס ללקוחות המסעדה, אבל המנהלים יכולים לראות ולעשות כרצונם במסעדה שתחת אחריותם.

ראסט בוחרת לתפעל את מערכת המודולים בצורה זו, וכך הסתרת פרטי היישומים הפנימיים היא ברירת המחדל. באופן זה ניתן לדעת אילו חלקים של הקוד ניתן לשנות ללא תופעות לוואי בעבור קוד חיצוני. אבל, ראסט מאפשרת לחשוף חלקים פנימיים של קוד במודולי-בנים למודולי-אב ע"י שימוש במילת המפתח `pub` כדי להפוך אותם לפומביים.

### חשיפת מסלולים באמצעות מילת המפתח `pub`

הבה נשוב לשגיאה מרשימה 7-4 שאמרה לנו שהמודול `hosting` הוא פרטי. אנחנו רוצים שלפונקציה `eat_at_restaurant` ממודול-האב תהיה גישה לפונקציה `add_to_waitlist` במודול-הבן, ולכן נסמן את המודול `hosting` במילת המפתח `pub`, כפי שאנו מראים ברשימה 7-5.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}
```


<span class="caption">רשימה 7-5: הכרזה על המודול `hosting` כפומבי באמצעות מילת המפתח `pub` בכדי לאפשר שימוש מתוך `eat_at_restaurant`</span>

לרוע המזל, הקוד ברשימה 7-5 עדיין גורר שגיאה, כפי שרואים ברשימה 7-6.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
```


<span class="caption">רשימה 7-6: שגיאות קומפילציה בעקבות בניית הקוד מרשימה 7-5</span>

מה קורה פה? הוספת מילת המפתח `pub` לפני ההכרזה `mod hosting` הופכת את המודול לפומבי. עם שינוי זה,  ניתן לגשת ל- `front_of_house`, ולכן אפשר לגשת ל-`hosting`. אבל, *תוכן* המודול `hosting` עדיין פרטי; הפיכת המודול לפומבי לא הופכת את תוכנו לפומבי. הוספת מילת המפתח `pub` לפני הכרזה על מודול מאפשרת לקוד במודולי-האב שלו להתייחס אליו, אבל לא לגשת לקוד הפנימי שלו. מכיוון שמודולים הם כלי קיבול (containers), לא מתאפשרות יותר מידי פעולות רק מהפיכת המודול לפומבי; עלינו ללכת רחוק יותר ולבחור להפוך לפחות אחד מהעצמים בתוך המודול לפומבי גם כן.

השגיאות ברשימה 7-6 אומרות שהפונקציה `add_to_waitlist` היא פרטית. כללי הפרטיות תקפים למבנים, מבחרים, פונקציות, ומתודות, וכן למודולים.

הבה נהפוך גם את הפונקציה `add_to_waitlist` לפומבית ע"י הוספת מילת המפתח `pub` לפני ההכרזה על הפונקציה, כמוצג ברשימה 7-7.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}
```


<span class="caption">רשימה 7-7: הוספת מילת המפתח `pub` ל-`mod hosting` ול-`fn add_to_waitlist` מאפשרת לנו לקרוא לפונקציה `eat_at_restaurant`</span>

כעת הקוד כן יעבור קומפילציה! כדי לראות מדוע הוספת מילת המפתח `pub` מאפשרת לנו להשתמש במסלולים אלה ב-`add_to_waitlist` בהתייחס לכללי הפרטיות, הבה נתבונן בשני המסלולים: האבסולוטי והיחסי.

במסלול האבסולוטי אנו מתחילים עם `crate`, בסיס עץ המודולים של המכולה שלנו. המודול `front_of_house` מוגדר בבסיס המכולה. בעוד ש-`front_of_house` אינו פומבי, כיוון שהפונקציה `eat_at_restaurant` מוגדרת באותו מודול כמו `front_of_house` (ז"א ש-`eat_at_restaurant` ו-`front_of_house` הם אחים), ניתן להתייחס ל-`front_of_house` מתוך `eat_at_restaurant`. הבא בתור הוא המודול `hosting`, המסומן עם `pub`. אנו יכולים לגשת אל מודול-האב של `hosting`, ולכן יש לנו גישה ל- `hosting`. לבסוף, הפונקציה `add_to_waitlist` מסומנת עם `pub` ואנו יכולים לגשת אל מודול-האב שלה, ולכן הקריאה לפונקציה מצליחה!

במסלולים יחסיים, הלוגיקה המנחה זהה למקרה של מסלולים אבסולוטיים למעט הצעד הראשון: במקום להתחיל מבסיס המכולה, המסלול מתחיל מ-`front_of_house`. המודול `front_of_house` מוגדר באותו המודל כמו `eat_at_restaurant`, ולכן המסלול היחסי המתחיל במודול בו מוגדר `eat_at_restaurant`, עובד. ואז, בגלל ש-`hosting` ו-`add_to_waitlist` מסומנים כ-`pub`, שאר המסלול עובד, והקריאה לפונקציה תקפה!

כאשר אתם מתכננים לשתף את מכולת הספריה שלכם כך שפרוייקטים אחרים יוכלו להשתמש בקוד, זכרו שה- API הוא החוזה שלכם עם המשתמשים של המכולה שלכם והוא קובע כיצד הם יכולים להשתמש בקוד שלכם. ישנם שיקולים מרובים סביב ארגון שינויים ל-API על מנת להקל על משתמשים להסתמך על המכולה שלכם. שיקולים אלה הם מחוץ להשג ידו של הספר; אם אתם מתעניינים בנושא זה, פנו ל-[The Rust API Guidelines][api-guidelines].

> #### התנהלות מיטבית בעבודה עם חבילות הכוללות מכולה בינארית ומכולת ספריה
> 
> כבר הזכרנו שחבילה יכולה להכיל גם קובץ  *src/main.rs*  כבסיס למכולה בינארית וגם קובץ  *src/lib.rs* כבסיס למכולת ספריה, ושתי המכולות ישתפו את שם החבילה כברירת מחדל. באופן טיפוסי, לחבילות כאלה, הכוללות גם מכולת ספריה וגם מכולה בינארית, יהיה רק את הקוד המינימלי הדרוש במכולה הבינארית כדי להתחיל את ההרצה שקוראת לקוד ממכולת הספריה. כך מתאפשר לפרוייקטים אחרים להפיק את מירב הפונקציונאליות שהחבילה מאפשרת, זאת משום שהקוד שבמכולת הספריה ניתן לשיתוף.
> 
> יש להגדיר את עץ המודולים בקובץ *src/lib.rs*. בדרך זו ניתן להשתמש  בכל עצם פומבי במכולה הבינארית ע"י התחלת מסלול עם שם החבילה. המכולה הבינארית הופכת להיות משתמש של ספרית המכולה, בדומה לדרך בה מכולה חיצונית לחלוטין היתה יכולה להשתמש במכולת הספריה: אך ורק תוך שימוש ב-API הפומבי. תכונה זו מסייעת בתכנון ה-API בצורה טובה; אתם, המתכנתים, אינכם רק הכותבים, אלא גם המשתשמים!
> 
> [בפרק 12][ch12]<!-- ignore --> נדגים התנהלות ארגונית זו באמצעות תכנית שורת-פקודה שתכלול מכולה בינארית וגם מכולת ספריה.

### מסלולים יחסיים המתחילים עם `super`

ניתן לבנות מסלולים יחסיים המתחילים במודול-האב, במקום במודול הנוכחי או במכולת הבסיס, ע"י שימוש ב-`super` בתחילת המסלול. נוהל זה שקול, במערכת הקבצים, להתחלת מסלול עם התחביר `..`. שימוש ב-`super` מאפשר לפנות לעצם שאנחנו יודעים שנמצא במודול-האב, וכך יכול להקל על ארגון מחדש של עץ המודולים כאשר המודול מקושר הדוקות למודול-האב, אבל מודול-האב עלול להיות מועבר למקום אחר בעץ המודולים בשלב עתידי כלשהו.

התבוננו בקוד ברשימה 7-8, שממדל מצב בו שף מקבל הזמנה שגויה ומביא אותה בעצמו ללקוח. הפונקציה `fix_incorrect_order`, המוגדרת במודול `back_of_house`, קוראת לפונקציה `deliver_order`, המוגדרת במודול-האב, ע"י ציון המסלול אל `deliver_order` ומתחיל עם `super`:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}
```


<span class="caption">רשימה 7-8: קריאה לפונקציה תוך שימוש במסלול יחסי המתחיל עם `super`</span>

הפונקציה `fix_incorrect_order` נמצאת במודול `back_of_house`, ולכן ניתן להשתמש ב- `super` על מנת לגשת למודול-האב של `back_of_house`, שבמקרה זה הוא `crate`, דהיינו הבסיס. מכאן, אנו מחפשים את `deliver_order`, ומוצאים אותו. מצויין! אנחנו מצפים בסבירות גבוהה שהמודול `back_of_house` והפונקציה `deliver_order` ישארו באותו יחס אחד אל השני, ושבמקרה של ארגון מחדש של עץ המודולים, הם יועברו יחדיו. על כן, השימוש ב- `super` מבטיח שיהיו לנו פחות מקומות בהם יהיה צורך לעדכן את הקוד בעתיד במידה וקוד זה יועבר למודול אחר.

### הפיכת מבנים ומבחרים לפומביים

ניתן גם להשתמש ב-`pub` כדי לסמן מבנים ומבחרים כפומביים, אבל ישנם כמה דגשים בנוגע לשימוש ב-`pub` עם מבנים ומבחרים. שימוש ב-`pub` לפני הגדרה של מבנה הופך את המבנה לפומבי, אבל שדות המבנה נשארים פרטיים. לגבי כל שדה ושדה ניתן לקבוע אם יישאר פרטי או יהפוך לפומבי. ברשימה 7-9 הגדרנו את המבנה `back_of_house::Breakfast` להיות פומבי עם שדה פומבי בשם `toast` ושדה פרטי בשם `seasonal_fruit`. מצב זה ממדל את המקרה בו במסעדה הלקוח יכול לבחור את סוג הלחם שמגיע עם הארוחה, אבל השף מחליט איזה פירות מלווים את הארוחה, וזאת בהתבסס על זמינות הפירות לפי העונה והמלאי. הפירות הזמינים משתנים במהירות, ולכן הלקוחות לא יכולים לבחור את הפירות, או אפילו לראות איזה פירות הם יקבלו.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}
```


<span class="caption">רשימה 7-9: מבנה עם שדות פרטיים ושדות פומביים</span>

בגלל שהשדה `toast` במבנה `back_of_house::Breakfast` הוא פומבי, אנחנו יכולים לכתוב ולקרוא לשדה `toast` שבמבנה `eat_at_restaurant` באמצעות תחביר הנקודה. שימו לב שלא ניתן להשתמש בשדה `seasonal_fruit` שבמבנה `eat_at_restaurant` בגלל ש-`seasonal_fruit` הוא פרטי. נסו להסיר את סימון ההערה בשורה שמשנה את ערך השדה `seasonal_fruit` וראו איזו הודעת שגיאה תקבלו!

בנוסף, שימו לב שמכיוון שב-`back_of_house::Breakfast` יש שדה פרטי, המבנה צריך לספק פונקציה משוייכת פומבית שבונה מופע של `Breakfast` (במקרה שלנו קראנו לפונקציה כזו `summer`). לו `Breakfast` לא היתה מספקת פונקציה כזו, לא היינו יכולים ליצור מופע של `Breakfast` ב-`eat_at_restaurant` משום שאין אפשרות לבצע השמה של ערך לשדה הפרטי `seasonal_fruit` אשר ב-`eat_at_restaurant`.

בניגוד לכך, אם מכריזים על מבחר כפומבי, אז כל הווריאנטים שלו פומביים גם הם. צריך למקם את `pub` רק לפני מילת המפתח `enum`, כפי שרואים ברשימה 7-10.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}
```


<span class="caption">רשימה 7-10: ציון מבחר כפומבי הופך לפומביים את כל הווריאנטים שלו</span>

בגלל שהפכנו את המבחר `Appetizer` לפומבי, ניתן להשתמש בווריאנטים `Soup` ו-`Salad` ב-`eat_at_restaurant`.

מבחרים אינם יעילים במיוחד אם הווריאנטים שלהם אינם פומביים; זה יהיה מציק אם נצטרך לבאר את כל הווריאנטים של המבחר ב-`pub`, ולכן ברירת המחדל היא לחסוך מאיתנו עבודה מיותרת זו. מבנים הם שימושיים לרוב גם כאשר השדות שלהם לא פומביים, ולכן עבור שדות של מבנים חל החוק הקפדני לפיו הכל פרטי כברירת מחדל, אלא אם מבואר אחרת ע"י `pub`.

ישנו עוד מצב אחד המערב את `pub` שעליו עוד לא דיברנו, וזה מביא אותנו לתכונה האחרונה של מערכת המודולים: מילת המפתח `use`. תחילה נעבור על `use` בפני עצמו, ואז נראה עיצד לשלב בין `pub` ל-`use`.

[pub]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
[api-guidelines]: https://rust-lang.github.io/api-guidelines/
[ch12]: ch12-00-an-io-project.html
