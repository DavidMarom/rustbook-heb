## טיפוסי דאטה

כל ערך בראסט הוא _מטיפוס דאטה_ מסוים, המבאר לקומפיילר של ראסט על איזה סוג דאטה מדובר וכיצד לעבוד עימו. אנו נתבונן בשני טיפוסי דאטה: סקלארי ומורכב.

זכרו שראסט היא שפה עם _טיפוסים סטטיים_ (statically typed), זאת אומרת שהיא חייבת לדעת בזמן הקומפילציה מהם הטיפוסים של כל המשתנים. ברוב המקרים הקומפיילר יכול להסיק, בהתבסס על הערך וכיצד אנחנו משתמשים בו, באיזה טיפוס אנחנו רוצים להשתמש. במקרים בהם מתאים יותר מטיפוס אחד, כמו למשל כשהמרנו טיפוס `String` לטיפוס נומרי בעזרת `parse` בסעיף ["השוואת הניחוש למספר הסודי"]()<!-- ignore --> בפרק 2, אנו נדרשים להוסיף הבארת טיפוס מפורשת, כך:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

במידה ולא נוסיף את הבארת הטיפוס `: u32` כמוצג בקוד לעיל, ראסט תציג את השגיאה הבאה, הדורשת מאיתנו לבאר לקומפיילר באיזה טיפוס אנחנו רוצים להשתמש:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

אתם תראו הבארות טיפוס שונות עבור טיפוסי דאטה אחרים.

### טיפוסים סקלארים

טיפוס _סקלארי_ מייצג ערך יחידי. לראסט יש ארבעה טיפוסים סקלארים ראשיים: מספרים שלמים, מספרי נקודה-צפה, משתנים בוליאנים, ומשתני תווים. יתכן שאתם מזהים טיפוסים אלה משפות תכנות אחרות. הבה נראה כיצד הם עובדים בראסט.

#### טיפוסי שלמים

מספר _שלם_ הוא מספר ללא חלק שברי. בפרק 2 השתמשנו בטיפוס שלם, דהיינו הטיפוס `u32`. הכרזת הטיפוס הזו מציינת שהערך המקושר למשתנה צריך להיות שלם לא מסומן, קרי משתנה חיובי. טיפוסי שלמים מסומנים, כלומר שלמים המסוגלים לייצג גם ערכים שליליים, מתחילים באות `i` במקום באות `u` . כך או כך, מספרים שלמים דורשים 32 ביטים בכדי לייצגם בזיכרון.
טבלה 3-1 מציגה את טיפוסי השלמים המובנים בראסט. ניתן להשתמש בכל אחד מאלה על מנת להכריז על הטיפוס של ערך שלם.

<span class="caption">טבלה 3-1: טיפוסי שלמים בראסט</span>

| גודל    | מסומן   | לא מסומן |
| ------- | ------- | -------- |
| 8 ביט   | `i8`    | `u8`     |
| 16 ביט  | `i16`   | `u16`    |
| 32 ביט  | `i32`   | `u32`    |
| 64 ביט  | `i64`   | `u64`    |
| 128 ביט | `i128`  | `u128`   |
| ארכ     | `isize` | `usize`  |

כל סוג מבין סוגי השלמים הללו יכול להיות מסומן או לא-מסומן, ויש לו גודל מפורש. האפשרויות _מסומן_ ו-_לא מסומן_ מתייחסות כאמור לשאלה האם המספר המיוצג עשוי להיות שלילי. כלומר, אם המשתנה השלם אותו אנו מגדירים נדרש לייצג מספר שלילי, הרי צריך שיהיה לו סימן; אך אם אנו יכולים להיות בטוחים שהמספר המיוצג יהיה תמיד אי-שלילי, ניתן להגדיר את המשתנה ללא-סימן. הדבר דומה לכתיבת מספרים על דף: כאשר הסימן חשוב, כותבים סימן פלוס או מינוס; אבל כאשר מובטח שהמספר אי-שלילי, אז אין צורך לכתוב שום סימן. מספרים מסומנים מאוכסנים בהצגת [השלמת שתים][twos-complement].

כל אחד מהסוגים הלא מסומנים יכול לאכסן מספרים בין (2<sup>n - 1</sup>)- עד 2<sup>n - 1</sup> - 1 (כולל), כאשר _n_ הוא מספר הביטים אותם דורש סוג המשתמש. כך ש-`i8` יכול לאכסן מספרים בין (2<sup>7</sup>)- ל- 1- 2<sup>7</sup> , ז"א בין 128- ל-127. סוגים לא מסומנים יכולים לאכסן מספרים מ-0 עד 1- 2<sup>n</sup> , כך ש- `u8` יכול לאכסן מספרים מ-0 עד 1- 2<sup>8</sup> , דהיינו בין 0 ל-255.

יש לשים לב שגדלי הטיפוסים `isize` ו- `usize` תלויים בארכיטקטורה של המחשב עליו רצה התכנית (הטבלה מציגה זו באמצעות הקיצור "ארכ"): 64 ביט אם אתם על ארכיטקטורת 64-ביט, ו-32 ביט אם אתם על ארכיטקטורת 32-ביט.

ניתן לרשום שלמים מפורשים בכל אחת מהצורות המוצגות בטבלה 3-2. שימו לב שעבור מספרים מפורשים שיכולים להתאים לכמה טיפוסים מספריים, ניתן להשתמש בסיומת טיפוס, כמו `57u8`, כדי לציין את הטיפוס. ניתן גם להשתמש בתו `_` במספרים מפורשים כדי ליצור הפרדה ויזואלית ולהקל על קריאת המספר, למשל `1_000`, מייצג את אותו הערך כמו `1000`.

<span class="caption">טבלה 3-2: שלמים מפורשים בראסט</span>

| מספרים מפורשים   | דוגמא         |
| ---------------- | ------------- |
| דסימלי           | `98_222`      |
| הקסדסימלי        | `0xff`        |
| אוקטלי           | `0o77`        |
| בינארי           | `0b1111_0000` |
| בייט (`u8` בלבד) | `b'A'`        |

אם כן, כיצד תדעו באיזה טיפוס שלם להשתמש? אם אתם לא בטוחים, ברירות המחדל של ראסט הן לרוב מקום טוב להתחיל בו: ברירת המחדל לטיפוס מספר שלם הוא `i32`. הסיטואציה העיקרית בה משתמשים ב- `isize` או `usize` היא כאשר משתמשים במשתנה כדי לגשת לסוג כלשהו של אוסף.

> ##### גלישות שלמים
>
> נניח שיש לכם משתנה מטיפוס `u8` שיכול לאחסן ערכים בין 0 ל-255. אם תנסו לשנות את המשתנה לערך מחוץ לתחום, כמו 256, תתרחש _גלישת שלמים_ (integer overflow), ושתוביל בתורה לאחת משתי התנהגויות: כאשר מקמפלים ב- debug mode, ראסט מבצעת בדיקות לגלישת שלמים שגורמות לתכנית להיכנס _לפאניקה_ (panic) בזמן הריצה במידה ומתרחשת גלישה. ראסט משתמשת במונח _פאניקה_ לתאר מצב בו תכנית עצרה בטרם עת תוך הנפקת הודעת שגיאה; אנחנו נדון בעקרונות הפאניקה לעומק בסעיף ["שגיאות סופניות ושימוש ב- `panic!`"][unrecoverable-errors-with-panic]<!-- ignore --> בפרק 9.
>
> כאשר מקמפלים ב-release mode עם הדגל `--release`, ראסט _לא_ כוללת בדיקות לגלישת שלמים שגורמות לפאניקה. במקום זאת, אם מתרחשת גלישה, ראסט מבצעת _גלילה בהשלמת שתים_ (two's complement wrapping). בקצרה, ערכים גדולים מהערך המקסימלי שהטיפוס יכול להכיל "נגללים מסביב" אל הערך הקטן ביותר שהטיפוס יכול להכיל. במקרה של הטיפוס `u8`, הערך 256 הופך ל-0, הערך 257 הופך ל-1, וכן הלאה. התכנית לא תיכנת לפאניקה, אבל המשתנה יכיל ערך שהוא כנראה לא מה שאתם מצפים לו. הסתמכות על ההתנהגות של גלילה במקרה של גלישת שלמים נחשבת לטעות.
>
> על מנת לטפל מפורשות במקרים של גלישה, ניתן להשתמש במשפחות הבאות של מתודות המסופקות ע"י הספריה הסטנדרטית עבור טיפוסים נומריים בסיסיים:
>
> - גלילה בכל המצבים עם המתודות `wrapping_*`, כמו למשל `wrapping_add`.
> - החזרת הערך `None` במקרה של גלישה באמצעות המתודות `checked_*`.
> - החזרת הערך ומידע בוליאני המציין אם ארעה גלישה באמצעות המתודות `overflowing_*`.
> - ספיגה בערך המינימלי או המקסימלי באמצעות המתודות `saturating_*`.

#### טיפוסי נקודה-צפה

לראסט יש שני טיפוסים בסיסיים עבור _מספרי נקודה-צפה_, שאינם אלא מספרים עם נקודה עשרונית. טיפוסי הנקודה הצפה של ראסט הם `f32` u-`f64`, שהם בגודל 32 ביט ו-64 ביט, בהתאמה. טיפוס ברירת המחדל הוא `f64` משום שעל מעבדים מודרנים מהירות העבודה איתו שווה, פחות או יותר, ל-`f32` אבל הוא מספק דיוק רב יותר. כל טיפוס נקודה-צפה הוא טיפוס מסומן בהגדרתו.

הינה דוגמא המראה מספרי נקודה-צפה בפעולה:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

מספרי נקודה-צפה מיוצגים לפי הסטנדרט IEEE-754. הטיפוס `f32` מספק ציפה בדיוק יחיד, בעוד `f64` מספק ציפה בדיוק כפול.

#### פעולות נומריות

ראסט תומכת בפעולות המתמטיות הבסיסיות להן תצפו עבור על הטיפוסים: חיבור, חיסור, כפל, חילוק, ושארית. חלוקת מספר בשלמים מעגלת לשלם הקרוב לכיוון 0. הקוד הבא מראה שימוש בכל אחת מהפעולות הנומריות כחלק מפקודת `let`:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

כל ביטוי בפקודות אלה משתמש באופרטור מתמטי ועובר הערכה לכדי תוצאה אחת, והיא זו שמקושרת למשתנה. [Appendix B][appendix_b]<!-- ignore --> מכיל רשימה של כל האופרטורים שראסט מספקת.

#### הטיפוס בוליאן (boolean)

כברוב שפות התכנות, למשתנה בוליאני בראסט יש שני ערכים אפשרים: `true` ו-`false`. משתנים בולאינים הם בגודל של בייט אחד. הטיפוס בוליאן בראסט מצויין ע"י `bool`. לדוגמא:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

הדרך הנפוצה להשתמש בערכים בוליאנים היא באמצעות ביטויי תנאי, כגון ביטויי `if`. נראה כיצד ביטויי `if` מתנהגים בראסט בסעיף ["בקרת זרימה"][control-flow]<!-- ignore --> .

#### טיפוס התו

הטיפוס `char` של ראסט הוא הטיפוס האלפביתי הבסיסי ביותר של השפה. הינה כמה דוגמאות להכרזות של ערכי `char`:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

שימו לב שאנו מציינים ערכי `char` מפורשים באמצעות גרש בודד, בניגוד למחרוזות מפורשות, עבורן אנו משתמשים בגרשיים כפולים. הטיפוס `char` של ראסט הוא בגודל של 4 בייטים והוא מייצג ערך יוניקוד סקלארי (Unicode Scalar Value), ולכן יכול לייצג הרבה יותר תווים מאשר רק ASCII. אותיות מנוקדות; תווים בסינית, יפנית, וקוריאנית; אמוג'י; ותווי רווח בעלי אורך אפסי הם כולם ערכי `char` אפשריים בראסט. ערכי יוניקוד סקלאריים נעים בטווחים שבין `U+0000` ל-`U+D7FF` ובין `U+E000` ל- `U+10FFFF`, כולל ערכי הקצה. אבל, ביוניקוד המושג "תו" לא באמת קיים, ולכן האינטואיציה הרגילה בדבר מהו "תו" עלולה שלא לעלות בקנה אחד עם המושג של `char` בראסט. אנו נדון בנושא זה בפירוט בסעיף ["אכסון טקסט מקודד UTF-8 באמצעות מחרוזות"][strings]<!-- ignore --> בפרק 8.

### טיפוסים מורכבים

_טיפוסים מורכבים_ יכולים לאגד כמה ערכים לטיפוס יחיד. לראסט יש שני טיפוסים מורכבים בסיסיים: רצפים (tuples) ומערכים (arrays).

#### טיפוס הרצף

_רצף_ הינו דרך כללית לאגד יחדיו כמה ערכים בני טיפוסים שונים לטיפוס מורכב אחד. לרצפים הם בעלי אורך קבוע; מרגע שהוכרזו בגודל מסוים, הם לא יכולים להתרחב או להתכווץ.

ניתן ליצור רצף על ידי כתיבת רשימה של ערכים המופרדים בפסיקים, בין זוג סוגריים עגולים. לכל מיקום ברצף יש טיפוס, והטיפוסים של הערכים השונים ברצף לא חייבים להיות זהים. לדוגמא הבאה הוספנו ביאורי טיפוסים (אופציונאלים):

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

המשתנה `tup` נקשר לרצף כולו כי רצף נחשב כאלמנט מורכב בודד. על מנת לגשת אל הערכים המרכיבים את הרצף, ניתן להשתמש בהתאמת דפוס כדי לפרק את ערך הרצף, כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

תכנית זו יוצרת רצף וקושרת אותו למשתנה `tup`. לאחר מכן נעשה שימוש בהתאמת דפוס ביחד עם `let` כדי לקחת את `tup` ולהפריד אותו לשלושה משתנים נפרדים, `x`, `y`, ו- `z`. תהליך זה נקרא _פירוק_ (destructuring) כיוון שהוא מפרק רצף יחיד לשלושה חלקים. לבסוף, התכנית מדפיסה את הערך של `y`, שהוא `6.4`.

ניתן גם לגשת לרכיב ברצף ישירות ע"י שימוש בנקודה (`.`) ולאחריה ציון אינדקס הערך אליו מעוניינים לגשת. לדוגמא:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

תכנית זו יוצרת את הרצף `x` ואז ניגשת לכל אחד מהרכיבים שבו תוך שימוש באינדקסים שלהם. כמו ברוב שפות התכנות, האינדקס הראשון ברצף הוא 0.

לרצף ללא כל ערכים יש שם מיוחד: _unit_. גם את הערך הזה וגם את הטיפוס שלו כותבים בצורה `()` והוא מייצג גם ערך ריק וגם טיפוס ריק. במידה ולא מוחזר מהם אחר מפורשות, ביטויים מחזירים באופן סמוי את הערך*unit* .

#### טיפוס המערך

דרך נוספת לאגד מספר ערכים היא באמצעות _מערכים_ (arrays). בניגוד לרצפים, כל האלמנטים במערך חייבים להיות מאותו טיפוס. שלא כמו מערכים בשפות אחרות, בראסט למערכים יש אורך קבוע.

אנחנו כותבים את הערכים במערך כרשימה מופרדת ע"י פסיקים בתוך סוגרים מרובעים:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

מערכים הם שימושיים כאשר אתם רוצים שהדאטה שלכם יהיה על המחסנית (stack) ולא על הערימה (heap) (אנו נדון במחסנית ובערימה [בפרק 4][stack-and-heap]<!-- ignore -->) או כאשר אתם רוצים לוודא שתמיד יש מספר קבוע של אלמנטים. אבל, מערכים אינם גמישים כמו הטיפוס וקטור. _וקטור_ (vector) הוא טיפוס אוסף דומה המסופק ע"י הספריה הסטנדרטית והוא _כן_ יכול לשנות את גודלו. אם אתם לא בטוחים אם להשתמש במערך או בוקטור, רוב הסיכויים שאתם צריכים להשתמש בוקטור. [Chapter 8][vectors]<!-- ignore --> דן בווקטורים ביתר פירוט.

אבל, מערכים הם עוצמתיים יותר כאשר יודעים שמספר האלמנטים ישאר קבוע. לדוגמא, אם אתם משתמשים בשמות החודשים בתכנית שלכם, סביר להשתמש במערך ולא בוקטור כיוון שאתם יודעים שהוא תמיד יכיל 12 אלמנטים:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
```

את טיפוס המערך נכתוב באמצעות סוגריים מרובעים תוך ציון הטיפוס של כל האלמנטים, נקודה-פסיק, ואז מספר האלמנטים במערך, בצורה הבאה:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

כאן `i32` הוא הטיפוס של כל אלמנט. המספר `5` שמופיע לאחר הנקודה-פסיק מציין שהמערך כולל חמישה אלמנטים.

ניתן גם לאתחל מערך כך שיכיל ערך מסויים עבור כל האלמנטים ע"י ציון הערך ההתחלתי, ולאחריו נקודה-פסיק, ואז את אורך המערך בסוגריים מרובעים, כפי שמוצג כאן:

```rust
let a = [3; 5];
```

המערך ששמו `a` מכיל `5` אלמנטים וכולם יאותחלו לערך `3`. כתיב זה משיג את אותה מטרה כמו כתיבת `let a = [3, 3, 3, 3, 3];` פשוט באופן קצר יותר.

##### גישה לאלמנטים במערך

מערך הוא מקשה אחת של זיכרון בגודל ידוע וקבוע שניתן להקצות על זיכרון המחסנית. ניתן לגשת לאלמנטים במערך ע"י שימוש באינדקסים, כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

בדוגמא זו, המשתנה `first` יקבל את הערך `1` כיוון שזהו הערך באינדקס `[0]` במערך. המשתנה `second` יקבל את הערך `2` מהאינדקס `[1]` במערך.

##### גישת לא תקינה לאלמנטים במערך

הבה נראה מה קורה אם מנסים לגשת לאלמנט הנמצא מעבר לגבולות המערך. נניח שנריץ את הקוד הבא, הדומה למשחק ניחוש המספר מפרק 2, כדי לקבל אינדקס למערך מהמשתמש:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

הקוד עובר קומפילציה בהצלחה. אם תריצו את הקוד באמצעות `cargo run` ותקלידו `0`, `1`, `2`, `3`, או `4`, אז התכנית תדפיס את הערך הנמצא במערך באינדקס הנתון. אם, במקום זאת, תקלידו מספר מעבר לסוף המערך, כמו `10`, אז תקבלו פלט כזה:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

התכנית הסתיימה בשגיאת _ריצה_ בנקודה בה נעשה שימוש בערך לא תקני באינדקס למערך. התכנית יצאה עם הודעת שגיאה ולא ביצעה את פקודת ה- `println!` האחרונה. כאשר מנסים לגשת לאלמנט באמצעות אינדקס, ראסט תבדוק שהאינדקס שסיפקתם קטן מאורך המערך. אם האינדקס גדול או שווה לאורך, ראסט תיכנס לפאניקה. בדיקה זו חייבת להתבצע בזמן הריצה, במיוחד במקרה זה, כיוון שהקומפיילר לא יכול לדעת איזה ערך המשתמש יקליד בזמן הריצה00.

זו דוגמא לעקרונות בטיחות הזיכרון של ראסט בפעולה. בשפות סף רבות סוג זה של בדיקות לא נעשה, ואז שימוש באינדקס לא תקני מוביל לגישה לא תקינה לזיכרון. ראסט מגינה עליכם מפני שגיאות שכאלה ע"י עצירה מיידית של התכנית במקום לאפשר גישה לזיכרון, ולהמשיך. פרק 9 ידון עוד בטיפול בשגיאות בראסט וכיצד ניתן לכתוב קוד קריא ובטוח, שגם לא נכנס לפאניקה וגם לא מאפשר גישה לא-תקינה לזיכרון.

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[appendix_b]: appendix-02-operators.md
