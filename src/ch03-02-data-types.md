## טיפוסי דאטה

כל ערך בראסט הוא *מטיפוס דאטה* מסוים, וזה אומר לראסט על איזה סוג דאטה מדובר, וכך ראסט יודעת איך לעבוד עם הדאטה. אנו נתבונן בשני טיפוסי דאטה: סקלארי ומורכב.

זכרו שראסט היא שפה עם *טיפוסים סטטיים* (statically typed), ז"א שהיא חייבת לדעת בזמן הקומפילציה מהם הטיפוסים של כל המשתנים. ברוב המקרים הקומפיילר יכול להסיק, בהתבסס על הערך וכיצד אנחנו משתמשים בו, באיזה טיפוס אנחנו רוצים להשתמש. במקרים בהם מתאים יותר מטיפוס אחד, כמו למשל כשהמרנו טיפוס `String` לטיפוס נומרי בעזרת `parse` בסעיף ["השוואת הניחוש למספר הסודי"]()<!-- ignore --> בפרק 2, חייבים להוסיף הבארת טיפוס, כך:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

במידה ולא נוסיף את הבארת הטיפוס `: u32` כמוצג בקוד לעיל, ראסט תציג את השגיאה הבאה, שמשמעה שצריך לספק לקומפיילר מידע נוסף כדאי שהוא ידע באיזה טיפוס אנחנו רוצים להשתמש:

```console
{{#include ../listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt}}
```

אתם תראו הבארות טיפוס שונות עבור טיפוסי דאטה אחרים.

### טיפוסים סקלארים

טיפוס *סקלארי* מייצג ערך יחיד. לראסט יש ארבעה טיפוסים סקלארים ראשיים: שלמים, מספרי נקודה-צפה, בוליאנים, ותווים. יתכן שאתם מזהים טיפוסים אלה משפות תכנות אחרות. הבה נראה מיד כיצד הם עובדים בראסט.

#### טיפוסי שלמים

מספר *שלם* הוא מספר ללא חלק שברי. בפרק 2 השתמשנו בטיפוס שלם, דהיינו הטיפוס `u32`. הכרזת הטיפוס הזו מציינת שהערך המקושר למשתנה צריך להיות שלם לא מסומן (טיפוסי שלמנים מסומנים מתחילים עם `i` במקום `u`) שלוקח 32 ביטים בזיכרון. טבלה 3-1 מציגה את טיפוסי השלמים המובנים בראסט. ניתן להשתמש בכל אחד מאלה על מנת להכריז על הטיפוס של ערך שלם.

<span class="caption">טבלה 3-1: טיפוסי שלמים בראסט</span>

| אורך    | מסומן   | לא מסומן |
| ------- | ------- | -------- |
| 8 ביט   | `i8`    | `u8`     |
| 16 ביט  | `i16`   | `u16`    |
| 32 ביט  | `i32`   | `u32`    |
| 64 ביט  | `i64`   | `u64`    |
| 128 ביט | `i128`  | `u128`   |
| ארכ     | `isize` | `usize`  |

כל סוג יכול להיות מסומן או לא מסומן, ויש לו אורך מפורש. *Signed* and *unsigned* refer to whether it’s possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned). It’s like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign; however, when it’s safe to assume the number is positive, it’s shown with no sign. Signed numbers are stored using [two’s complement][twos-complement]<!-- ignore
--> ***.

כל אחד מהסוגים הלא מסומנים יכול לאכסן מספרים בין -(2<sup>n - 1</sup>) עד 2<sup>n - 1</sup> - 1 (כולל), כאשר *n* הוא מספר הביטים בו הסוג משתמש. כך ש-`i8` יכול לאכסן מספרים בין -(2<sup>7</sup>) ל-2<sup>7</sup> - 1, ז"א בין -128 ל-127. סוגים לא מסומנים יכולים לאכסן מספרים מ-0 עד 2<sup>n</sup> - 1, כך ש- `u8` יכול לאכסן מספרים מ-0 עד 2<sup>8</sup> - 1, דהיינו בין 0 ל-255.

בנוסף, הטיפוסים `isize` ו- `usize` תלויים בארכיטקטורה של המחשב עליו התכנית רצה, וזה מסומן בטבלה באמצעות "ארכ": 64 ביט אם אתם על ארכיטקטורת 64-ביט ו-32 ביט אם אתם על ארכיטקטורת 32-ביט.

ניתן לרשום שלמים מפורשים בכל אחת מהצורות המוצגות שטבלה 3-2. שימו לב שעבור מספרים מפורשים שיכולים להתאים לכמה טיפוסים נומריים, ניתן להשתמש בסיומת טיפוס, כמו `57u8`, כדי לציין את הטיפוס. ניתן גם להשתמש בסימן מספרים מפורשים `_` במספרים מפורשים כדי ליצור הפרדה ויזואלית ולהקל על קריאת המספר, למשל `1_000`, אשר מייצג את אותו ערך כמו `1000`.

<span class="caption">טבלה 3-2: שלמים מפורשים בראסט</span>

| מספרים מפורשים   | דוגמא         |
| ---------------- | ------------- |
| דסימלי           | `98_222`      |
| הקסדסימלי        | `0xff`        |
| אוקטלי           | `0o77`        |
| בינארי           | `0b1111_0000` |
| בייט (`u8` בלבד) | `b'A'`        |

אם כן, כיצד תדעו באיזה טיפוס שלם להשתמש? אם אתם לא בטוחים אז בדר"כ ברירות המחדל של ראסט הן מקום טוב להתחיל בו: ברירת המחדל לטיפוס מספר שלם הוא `i32`. הסיטואציה העיקרית בה משתמשים ב- `isize` או `usize` היא כאשר משתמשים במשתנה כדי לגשת לסוג כלשהו של אוסף.

> ##### גלישות בשלמים
> 
> נניח שיש לכם משתנה מטיפוס  `u8` שיכול לאכסן ערכים בין 0 ל-255. אם תנסו לשנות את המשתנה לערך מחוץ לתחום, כמו 256, תתרחש *גלישת שלמים * (integer overflow), וזו תוביל לאחת משתי התנהגויות. כאשר מקמפיילים ב-  dubug mode, ראסט מבצעת בדיקות לגלישת שלמים שגורמות לתכנית להיכנס *לפאניקה* (panic) בזמן הריצה במידה ומתרחשת גלישה. ראסט משתמשת במונח *פאניקה* לתאר מצב בו תכנית עצרה עם שגיאה; אנחנו נדון בעקרונות הפאניקה יותר לעומק בסעיף ["שגיאות סופניות ושימוש ב-  `panic!`"][unrecoverable-errors-with-panic]<!-- ignore --> בפרק 9.
> 
> כאשר מקמפיילים ב-release mode עם הדגל `--release`, ראסט *לא* כוללת בדיקות לגלישת שלמים שגורמות לפאניקה. במקום זאת, אם מתרחשת גלישה, ראסט מבצעת *גלילה בהשלמת שתים* (two's complement wrapping). בקצרה, ערכים גדולים מהערך המקסימלי שהטיפוס יכול להכיל "נגללים מסביב" אל הערך הקטן ביותר שהטיפוס יכול להכיל. במקרה של הטיפוס  `u8`, הערך 256 הופך ל-0, הערך 257 הופך ל-1, וכן הלאה. התכנית לא תיכנת לפאניקה, אבל המשתנה יכיל ערך שהוא כנראה לא מה שאתם מצפים לו. הסתמכות על ההתנהגות של גלילה במקרה של גלישת שלמים נחשבת טעות.
> 
> על מנת לטפל מפורשות במקרים של גלישה, ניתן להשתמש במשפחות הבאות של מתודות המסופקות ע"י הספריה הסטנדרטית עבור טיפוסים נומריים בסיסיים:
> 
> * גלילה בכל המצבים עם המתודות `wrapping_*`, כמו למשל `wrapping_add`.
> * החזרת הערך `None` במקרה של גלישה באמצעות המתודות `checked_*`.
> * החזרת הערך ומידע בוליאני המציין אם ארעה גלישה באמצעות המתודות `overflowing_*`.
> * ספיגה בערך המינימלי או המקסימלי באמצעות המתודות `saturating_*`.

#### טיפוסי נקודה-צפה

לראסט יש שני טיפוסים בסיסיים עבור *מספרי נקודה-צפה*, שהם מספרים עם נקודה עשרונית. טיפוסי הנקודה הצפה של ראסט הם `f32` u-`f64`, שהם באורך 32 ביט ו-64 ביט, בהתאמה. טיפוס ברירת המחדל הוא `f64` משום שעל מעבדים מודרנים מהירות העבודה איתו שווה, פחות או יותר, ל-`f32` אבל הוא מספק דיוק רב יותר. כל טיפוס נקודה-צפה הוא מסומן.

הינה דוגמא המראה מספרי נקודה-צפה בפעולה:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-06-floating-point/src/main.rs}}
```

מספרי נקודה-צפה מיוצגים לפי הסטנדרט IEEE-754. הטיפוס `f32` מספק ציפה בדיוק יחיד, בעוד `f64` מספק ציפה בדיוק כפול.

#### פעולות נומריות

ראסט תומכת בפעולות המתמטיות הבסיסיות להן תצפו עבור על הטיפוסים: חיבור, חיסור, כפל, חילוק, ושארית. חלוקה בשלמים מעגלת לשלם הקרוב לכיוון 0. הקוד הבא מראה שימוש בכל אחת מהפעולות הנומריות כחלק מפקודת `let`:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-07-numeric-operations/src/main.rs}}
```

כל ביטוי בפקודות אלה משתמש באופרטור מתמטי ועובר הערכה לכדי תוצאה אחת, והיא זו שמקושרת למשתנה. [Appendix B][appendix_b]<!-- ignore --> ***.

#### הטיפוס בוליאן (boolean)

כברוב שפות התכנות, למשתנה בוליאני בראסט יש שני ערכים אפשרים: `true` ו-`false`. משתנים בולאינים הם בגודל של בייט אחד. הטיפוס בוליאן בראסט מצויין על `bool`. לדוגמא:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-08-boolean/src/main.rs}}
```

הדרך הנפוצה להשתמש בערכים בוליאנים היא באמצעות ביטויי תנאי, כגון ביטויי `if`. אנחנו נראה כיצד ביטויי `if` עובדים בראסט בסעיף ["בקרת זרימה"][control-flow]<!-- ignore --> .

#### טיפוס התו

הטיפוס `char` של ראסט הוא הטיפוס האלפבתי הבסיסי ביותר של השפה. הינה כמה דוגמאות להכרזות של ערכי `char`:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-09-char/src/main.rs}}
```

שימו לב שאנו מציינים ערכי `char` מפורשים באמצעות גרש בודד, בניגוד למחרוזות מפורשות, עבורן אנו משתמשים בגרשיים כפולים. הטיפוס `char` של ראסט הוא בגודל של 4 בייטים והוא מייצג ערך יוניקוד סקלארי (Unicode Scalar Value), ולכן יכול לייצג הרבה יותר תווים מאשר רק ASCII. אותיות מנוקדות; תווים בסינית, יפנית, וקוריאנית; אמוג'י; ותווי רווח אפס-אורך הם כולם ערכי `char` אפשריים בראסט. ערכי יוניקוד סקלאריים נעים בטווחים שבין `U+0000` ל-`U+D7FF` ובין `U+E000` ל- `U+10FFFF`, כולל הקצוות. אבל, ביוניקוד המושג "תו" לא באמת קיים, ולכן האינטואיציה הרגילה בדבר מהו "תו" עלולה לא לעלות בקנה אחד עם המושג של `char` בראסט. אנו נדון בנושא זה בפירוט בסעיף ["אכסון טקסט מקודד UTF-8 באמצעות מחרוזות"][strings]<!-- ignore --> בפרק 8.

### טיפוסים מורכבים

*טיפוסים מורכבים* יכולים לאגד כמה ערכים לטיפוס יחיד. לראסט יש שני טיפוסים מורכבים בסיסיים: רצפים (tuples) ומערכים (arrays).

#### טיפוס הרצף

*רצף* הינו דרך כללית לאגד יחדיו כמה ערכים מכל מיני טיפוסים לטיפוס מורכב אחד. לרצפים יש אורך קבוע; מרגע שהוכרזו הם לא יכולים לגדול או להתכווץ בגודלם.

יוצרים רצף ע"י כתיבת רשימה של ערכים בין סוגריים, המופרדת בפסיקים. לכל מיקום ברצף יש טיפוס, והטיפוסים של הערכים השונים ברצף לא חייבים להיות זהים. לדוגמא הבאה הוספנו ביאורי טיפוסים (אופציונאלים):

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-10-tuples/src/main.rs}}
```

המשתנה `tup` נקשר לרצף כולו כי רצף נחשב כאלמנט מורכב בודד. על מנת לגשת אל הערכים המרכיבים את הרצף, ניתן להשתמש בהתאמת דפוס כדי לפרק את ערך הרצף, כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-11-destructuring-tuples/src/main.rs}}
```

תכנית זו קודם כל יוצרת רצף וקושרת אותו למשתנה `tup`. לאחר מכן נעשה שימוש בהתאמת דפוס ביחד עם `let` כדי לקחת את `tup` ולהפוך אותו לשלושה משתנים נפרדים, `x`, `y`, ו- `z`. תהליך זה נקרא *פירוק* (destructuring) כיוון שהוא מפרק רצף יחיד לשלושה חלקים. לבסוף, התכנית מדפיסה את הערך של `y`, שהוא `6.4`.

ניתן גם לגשת לרכיב ברצף ישירות ע"י שימוש בנקודה (`.`) ולאחריה האינדקס של הערך אליו מעוניינים לגשת. לדוגמא:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-12-tuple-indexing/src/main.rs}}
```

תכנית זו יוצרת את הרצף `x` ואז ניגשת לכל אחד מהרכיבים שבו תוך שימוש באידקסים שלהם. כמו ברוב שפות התכנות, האינדקס הראשון ברצף הוא 0.

לרצף ללא כל ערכים יש שם מיוחד: *unit*. גם את הערך הזה וגם את הטיפוס שלו כותבים בצורה `()` והוא מייצג גם ערך ריק וגם טיפוס ריק. ביטויים מחזירים באופן סמוי את הערך <0>unit</0> במידה והם לא מחזירים ערך אחר באופן מפורש.

#### טיפוס המערך

דרך נוספת לאגד מספר ערכים היא באמצעות *מערכים* (arrays). בניגוד לרצפים, כל האלמנטים במערך חייבים להיות מאותו טיפוס. שלא כמו מערכים בשפות אחרות, בראסט למערכים יש אורך קבוע.

אנחנו כותבים את הערכים במערך כרשימה מופרדת ע"י פסיקים בתוך סוגרים מרובעים:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-13-arrays/src/main.rs}}
```

מערכים הם שימושיים כאשר אתם רוצים שהדאטה שלכם יהיה על המחסנית (stack) ולא על הערימה (heap) (אנו נדון במחסנית ובערימה [בפרק 4][stack-and-heap]<!-- ignore -->) או כאשר אתם רוצים לוודא שתמיד יש מספר קבוע של אלמנטים. אבל, מערכים אינם גמישים כמו הטיפוס וקטור. *וקטור* (vector) הוא טיפוס אוסף דומה המסופק ע"י הספריה הסטנדרטית והוא *כן* יכול לשנות את גודלו. אם אתם לא בטוחים אם להשתמש במערך או בוקטור, רוב הסיכויים שאתם צריכים להשתמש בוקטור. [Chapter 8][vectors]<!-- ignore --> ***.

אבל, מערכים הם יותר עצמתיים כאשר יודעים שמספר האלמנטים לא יצטרך להשתנות. לדוגמא, אם אתם משתמשים בשמות החודשים*** בתכנית שלכם, סביר להשתמש במערך ולא בוקטור כיוון שאתם יודעים שהוא תמיד יכיל 12 אלמנטים:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

את הטיפוס של מערך כותבים באמצעות סוגריים מרובעים עם הטיפוס של כל האלמנטים, נקודה-פסיק, ואז מספר האלמנטים במערך, בצורה הבאה:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

כאן `i32` הוא הטיפוס של כל אלמנט. המספר `5` שמופיע לאחר הנקודה-פסיק מציין שהמערך כולל חמישה אלמנטים.

ניתן גם לאתחל מערך כך שיכיל ערך מסויים עבור כל האלמנטים ע"י ציון הערך ההתחלתי, ולאחריו נקודה-פסיק, ואז את אורך המערך בסוגריים מרובעים, כפי שמוצג כאן:

```rust
let a = [3; 5];
```

המערך ששמו `a` מכיל `5` אלמנטים וכולם יאותחלו לערך `3`. כתיב זה משיג את אותה מטרה כמו כתיבת `let a = [3, 3, 3, 3, 3];`, פשוט בצורה מקוצרת יותר.

##### גישה לאלמנטים במערך

מערך הוא מקשה אחת של זיכרון בגודל ידוע וקבוע שניתן להקצות על המחסנית. ניתן לגשת לאלמנטים במערך ע"י שימוש באינדקסים, כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-14-array-indexing/src/main.rs}}
```

בדוגמא זו, המשתנה בשם `first` יקבל את הערך `1` כיוון שזהו הערך באינדקס `[0]` במערך. המשתנה ששמו `second` יקבל את הערך `2` מהאינדקס `[1]` במערך.

##### גישת לא תקינה לאלמנטים במערך

הבה נראה מה קורה אם מנסים לגשת לאלמנט במערך מעבר לסוף המערך. נניח שנריץ את הקוד הבא, הדומה למשחק ניחוש המספר מפרק 2, כדי לקבל אינדקס למערך מהמשתמש:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,panics
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access/src/main.rs}}
```

הקוד עובר קומפילציה בהצלחה. אם תריצו את הקוד באמצעות `cargo run` ותקלידו `0`, `1`, `2`, `3`, או `4`, אז התכנית תדפיס את הערך הנמצא במערך באינדקס הנתון. אם, במקום זאת, תקלידו מספר מעבר לסוף המערך, כמו `10`, אז תקבלו פלט כזה:

<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->

```console
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

התכנית הסתיימה בשגיאת *ריצה* בנקודה בה נעשה שימוש בערך לא תקני באינדקס למערך. התכנית יצאה עם הודעת שגיאה ולא ביצעה את פקודת ה- `println!` האחרונה. כאשר מנסים לגשת לאלמנט באמצעות אינדקס, ראסט תבדוק שהאינדקס שסיפקתם קטן מאורך המערך. אם האינדקס גדול או שווה לאורך, ראסט תיכנס לפאניקה. בדיקה זו חייבת להתבצע בזמן הריצה, במיוחד במקרה זה, כיוון שהקומפיילר לא יכול לדעת איזה ערך המשתמש יקליד כאשר הקוד ירוץ אח"כ.

זו דוגמא לעקרונות בטיחות הזיכרון של ראסט בפעולה. בשפות סף רבות סוג זה של בדיקות לא נעשה, ואז שימוש באינדקס לא תקני מובילה לגישה לא תקינה לזיכרון. ראסט מגינה עליכם מפני שגיאות שכאלה ע"י עצירה מיידית של התכנית במקום לאפשר גישה לזיכרון, ולהמשיך. פרק 9 ידון עוד אודות טיפול בשגיאות בראסט וכיצד ניתן לכתוב קוד קריא ובטוח שגם לא נכנס לפאניקה וגם לא מאפשר גישה לא תקינה לזיכרון.
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number

[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement
[control-flow]: ch03-05-control-flow.html#control-flow
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[stack-and-heap]: ch04-01-what-is-ownership.html#the-stack-and-the-heap
[vectors]: ch08-01-vectors.html
[unrecoverable-errors-with-panic]: ch09-01-unrecoverable-errors-with-panic.html
[appendix_b]: appendix-02-operators.md
