## אחסון טקסט בקידוד UTF-8 כמחרוזת

דיברנו מעט על מחרוזות בפרק 4, אבל כעת נדון בהן לעמקן. ראסטיונרים מסתבכים לרוב עם מחרוזות משלוש סיבות: ראשית, הנטייה של ראסט לחשוף מראש שגיאות אפשריות; שנית, היות מחרוזות מבנה נתונים מסובך יותר ממה שמתכנתים רבים נוטים לחשוב; ושלישית, קידוד UTF-8. כאשר אתה מגיע משפות תכנות אחרות, סיבות אלו עלולות לשלוב יחדיו לכדי קושי אמיתי.

אנו דנים כאן במחרוזות בהקשר של אוספים כיוון שמחרוזות בראסט אינם אלא אוסף של בתים (bytes), בתוספת מתודות שימושיות המאפשרות לבצע מניפולציה על אותם בתים כאשר הם מתפרשים כטקסט. בחלק זה נדון בפעולות על הטיפוס `String` שניתן לבצע על כל סוג אוסף, כגון יצירה, עדכון, וקריאה. נדון גם בדרכים בהן 'String' שונה מאוספים אחרים, כלומר כיצד גישה באינדקס ל-'String' היא מורכבת יותר ממה שנדמה, עקב האופן השונה-בתכלית בו אנשים ומחשבים מפרשים נתוני 'String'.

### מהי מחרוזת?

תחילה נגדיר למה אנחנו מתכוונים במונח _מחרוזת_. בבסיס השפה, לראסט יש רק סוג מחרוזת אחד, וזהו חיתוך המחרוזת `str`, הנפוץ לרוב בצורתו המושאלת `&str`. בפרק 4, דיברנו על _חיתוכי מחרוזות_, שאינם אלא הפניות לנתוני מחרוזת בקידוד UTF-8, המאוחסנים במקום כזה או אחר בזיכרון. מחרוזות מפורשות (string literals), למשל, מאוחסנות בבינארי של התוכנית, ונחשבות לחיתוכי מחרוזת.

הטיפוס `String`, מסופק על ידי הספרייה הסטנדרטית של ראסט, ואינו מקודד בשפת הליבה. זהו טיפוס מחרוזת בקידוד UTF-8 המסוגל לשנות את גודלו, ושניתן לשינוי ולבעלות. כאשר ראסטיונרים מדברים על "מחרוזות", ייתכן שהם מתייחסים לטיפוס `String` או לטיפוס 'str&' של חיתוך המחרוזת. למרות שסעיף זה עוסק בעיקר בטיפוס `String`, שני הטיפוסים נמצאים בשימוש תדיר בספרייה הסטנדרטית של ראסט, ושניהם מקודדים בפורמט UTF-8.

### יצירת מחרוזת חדשה

רבות מאותן פעולות הזמינות לשימוש עם `Vec<T>` זמינות גם עם `String`. הרי, `String` למעשה ממומשת כעטיפה סביב וקטור של בתים בתוספת ערבויות, הגבלות, ויכולות נוספות. דוגמה לפונקציה שפועלת באופן דומה עבור `Vec<T>` ו-`String` היא הפונקציה `new` היוצרת מופע חדש, כפי שמציגה רשימה 8-11.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

<span class="caption">רשימה 8-11: יצירת `String` חדשה וריקה</span>

שורה זו יוצרת מחרוזת ריקה חדשה בשם `s`, אליה נוכל לטעון נתונים. לעתים קרובות, יהיו לנו נתונים התחלתיים איתם נרצה להתחיל את המחרוזת. לשם כך, אנו משתמשים במתודה 'to_string'. זוהי מתודה הזמינה עבור כל טיפוס המיישם את תכונת ה-'Display', בכלל זאת מחרוזות מפורשות. רשימה 8-12 מציגה שתי דוגמאות.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

<span class="caption">רשימה 8-12: שימוש בשיטת `to_string` ליצירת `String` ממחרוזת מפורשת </span>

קוד זה יוצר מחרוזת המכילה את התוכן `initial contents`.

נוכל גם להשתמש בפונקציה `String::from` כדי ליצור `String` ממחרוזת מפורשת. הקוד ברשימה 8-13 שקול לקוד מרשימה 8-12 שמשתמש ב-'to_string'.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

<span class="caption">רשימה 8-13: שימוש בפונקציה `String::from` כדי ליצור `String` ממחרוזת מפורשת </span>

מכיוון שמחרוזות משמשות לכל-כך הרבה דברים, אנחנו יכולים להשתמש בשלל ממשקי API גנריים המספקים לנו אפשרויות רבות. חלקם עשוים להיראות מיותרים, אך כולם ראויים! במקרה זה, `String::from` ו-`to_string` מבצעים את אותה הפעולה, כך שבחירתכם תהיה בעיקרה סוגיה של סגנון וקריאות.

יש לזכור שמחרוזות מקודדות בקידוד UTF-8, כך שנוכל לכלול בהן נתונים רבים המקודדים כיאות, כפי שמציגה רשימה 8-14.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

<span class="caption">רישום 8-14: אחסון ברכות בשפות שונות במחרוזות</span>

כל אלה הם ערכי `String` חוקיים.

### עדכון מחרוזת

`String` יכולה לגדול והתוכן שלה יכול להשתנות, בדיוק כמו `Vec<T>` לאחר שדוחפים לתוכו נתונים נוספים. כמו-כן, ניתן להשתמש באופרטור `+` או במאקרו `format!` כדי לשרשר זה לזה כמה ערכי `String`.

#### הוספה לסוף מחרוזת עם המתודות `push_str` ו-`push`

אנו יכולים לצרף חיתוך מחרוזת לסוף `String` קיים באמצעות המתודה `push_str`, ובכך להגדילו. רשימה 8-15 מדגימה זאת.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

<span class="caption">רשימה 8-15: צירוף חיתוך מחרוזת ל-`String` עם מתודת `push_str`</span>

בתום שתי שורות אלה, `s` יכיל את `foobar`. מתודת `push_str` מקבלת כארגומנט חיתוך מחרוזת, כיוון שלא בהכרח נרצה לקחת בעלות על הפרמטר המועבר. לדוגמה, ברשימה 8-16, אנו רוצים להיות מסוגלים להשתמש ב-'s2' גם לאחר הוספת התוכן שלו ל-'s1'.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

<span class="caption">רשימה 8-16: שימוש בחיתוך מחרוזת לאחר צירוף התוכן שלו ל`String`</span>

אם מתודת `push_str` לקחה בעלות על `s2`, לא נוכל להדפיס את הערך שלה בשורה האחרונה. עם זאת, קוד זה עובד כפי שהיינו מצפים!

המתודה `push` לוקחת תו בודד כפרמטר ומוסיפה אותו ל-`String`. רשימה 8-17 מוסיף את האות "l" למחרוזת `s` באמצעות המתודה `push`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

<span class="caption">רשימה 8-17: הוספת תו אחד לערך `String` באמצעות `push`</span>
כתוצאה מכך, `s` תכיל `lol`.

#### שרשור עם האופרטור `+` או המאקרו `format!`

לעתים קרובות נרצה לשרשר שתי מחרוזות קיימות. אחת הדרכים לעשות זאת היא להשתמש באופרטור `+`, כפי שמציגה רשימה 8-18.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

<span class="caption">רשימה 8-18: שימוש באופרטור `+` לשרשור שני ערכי `String` לערך `String` חדש</span>

המחרוזת `s3` תכיל את `Hello, world!`. הסיבה מדוע `s1` כבר לא תקף לאחר השרשור, ומדוע השתמשנו בהפניה ל-`s2`, נעוצה בחותם המתודה שנקראת מאחורי הקלעים בעת השימוש באופרטור `+`. האופרטור `+` קורא למתודת `add`, שהחותם שלה נראה בערך כך:

```rust,ignore
fn add(self, s: &str) -> String {
```

בספרייה הסטנדרטית, תראה את המתודה `add` מוגדרת באמצעות ג’נריקס וטיפוסים משויכים. בדוגמה כאן, החלפנו אותם בטיפוסים קונקרטיים, שזה מה שמתרחש בפועל כשאנחנו משתמשים בשיאה הזו עם ערכי `String`. נדון בהרחבה בטיפוסים גנריים בפרק 10. ובכל זאת, חותם זה נותן לנו את הרמזים הדרושים כדי לפענח את החלקים המורכבים באופרטור `+`.

ראשית, הארגומנט `s2` מופיע עם `&`, כלומר אנו מוסיפים _הפניה_ של המחרוזת השנייה למחרוזת הראשונה. הסיבה לכך נעוצה בפרמטר `s` בפונקציה `add`: אנו יכולים להוסיף רק `&str` ל`String`; אנחנו לא יכולים להוסיף שני ערכי `String` ביחד. אבל רגע - הטיפוס של `&s2` הוא `&String, לא `&str`, כפי שצוין בפרמטר השני של 'add'. אם כך, מדוע רשימה 8-18 לא גוררת שגיאת קומפילציה?

הסיבה שמתאפשר לנו להשתמש ב-`&s2` בקריאה ל-`add` היא שהקומפיילר יכול _להכריח_ את הארגומנט `&String` לטיפוס `&str`. כאשר אנו קוראים למתודת `add`, ראסט מפעילה _כפיית דה-הפניה_, אשר הופכת כאן את `&s2` ל-`&[..]s2`. נדון עוד בכפיית דה-הפניה בפרק 15. כיוון ש-`add` אינה לוקחת בעלות על הפרמטר `s2`, `s2` יהיה עדיין טיפוס `String` חוקי לאחר הפעולה.

שנית, אנו יכולים לראות בחותם ש-'add' לוקחת בעלות על `self`, מכיוון של-`self` _אין_ `&`. פירוש הדבר שהבעלות על `s1` ברשימה 8-18 תועבר בקריאה ל-`add`, והמשתנה `s1` לא יהיה תקף עוד לאחר-מכן. אז למרות שההצהרה `let s3 = s1 + &s2;` נדמית כאילו שתי המחרוזות יועתקו אל תוך מחרוזת חדשה, ההצהרה למעשה לוקחת בעלות על `s1`, מצרפת עותק עם התוכן של `s2`, ואז מחזירה בעלות על התוצאה. במילים אחרות, זה נראה כאילו נוצר כאן עותק חדש, אך לא זה מה שמתרחש. זהו מימוש יעיל יותר מהעתקה.

ובכל זאת - אם אנו נדרשים לשרשר מחרוזות מרובות, האופרטור `+` הופך למסורבל:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

בשלב זה, ערכו של 's' יהיה 'tic-tac-toe'. עם כל התווים `+` ו-`"`, קשה לראות מה קורה. במקום זאת, אם נידרש לשילוב מחרוזות מורכב יותר, נוכל להשתמש במאקרו `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

קוד זה גם מגדיר את `s` כ-`tic-tac-toe`. המאקרו `format!` פועל בדומה ל-`println!`, אך במקום להדפיס את הפלט למסך, הוא מחזיר `String` עם התוכן. גרסת הקוד עם '!format' קלה הרבה יותר לקריאה, והקוד שנוצר על ידי המאקרו '!format' משתמש בהפניות כך שהקריאה הזו לא לוקחת בעלות על אף אחד מהפרמטרים שלה.

### גישה למחרוזת באמצעות אינדקס

בשפות תכנות רבות אחרות, גישה ישירה לתווים בודדים במחרוזת באמצעות ציון אינדקס היא פעולה חוקית ונפוצה. עם זאת, בראסט, הניסיון לגשת לחלקים של `String` באמצעות תחביר אינדקס יפיק שגיאה. התבוננו בקוד הלא-תקין ברשימה 8-19.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

<span class="caption">רשימה 8-19: ניסיון להשתמש בתחביר אינדקס עם מחרוזת</span>

קוד זה יפיק את השגיאה הבאה:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

השגיאה וההערה מספרים את הסיפור כולו: מחרוזות בראסט אינן תומכות בתחביר אינדקס. אבל מדוע לא? כדי לענות על השאלה הזו, עלינו לדון בדרך בה ראסט מאחסנת מחרוזות בזיכרון.

#### ייצוג פנימי

כאמור, הטיפוס `String` אינו אלא עטיפה על הטיפוס `Vec<u8>`. הבה נתבונן במספר מחרוזות דוגמה ברשימה 8-14. כולן מקודדות כראוי בקידוד UTF-8. ראשית, זו:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

במקרה זה, ערכו של `len` יהיה 4, מה שאומר שהווקטור המאחסן את המחרוזת "Hola" הוא באורך 4 בתים. בקידוד UTF-8, כל אחת מהאותיות הללו דורשת 1 בייט. השורה הבאה, לעומת זאת, עשויה להפתיע אותך. (שים לב שהמחרוזת הזו מתחילה באות הקירילית הגדולה Ze, לא בספרה הערבית 3.)

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

בתשובה לשאלה מה אורך המחרוזת, תתפתו אולי לומר 12; למעשה, התשובה של ראסט היא 24: זה מספר הבתים שנדרש כדי לקודד "Здравствуйте" בקידוד UTF-8. זאת כיוון שכל ערך סקלארי של יוניקוד במחרוזת זו דורש 2 בתים של אחסון. לכן, אינדקס לבתים של מחרוזת מעין זו לא יהיה תואם תמיד לערך יוניקוד סקלארי חוקי. כדי להבין זאת טוב יותר, התבוננו בקוד הלא-תקין הזה:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

אנחנו כבר יודעים ש-`answer` לא יהיה `З`, האות הראשונה. בקידוד UTF-8, ערך הבית הראשון של `З` הוא `208`, וערך הבית השני הוא `151`, כך שנראה שערכו של `answer` צריך להיות למעשה `208`. אך `208` אינו ערך חוקי בפני עצמו; סביר להניח שהחזרת '208' אינה מה שהמשתמש היה רוצה לו היה מבקש את האות הראשונה של המחרוזת הזו. עם זאת, אלו הנתונים היחידים שיש לראסט באינדקס 0. גם אם המחרוזת מכילה רק אותיות לטיניות, משתמשים בדרך כלל לא רוצים לקבל את ערך הבייטים עצמם: לו `&"hello"[0]` היה קוד חוקי, הוא היה מחזיר `104`, לא `h`.

התשובה, אם כן, היא שכדי להימנע מהחזרת ערך בלתי-צפוי שעלול להוליד בהמשך באגים קשים-לתיקון, ראסט מסרבת-מראש לקמפל את הקוד הזה. בכך היא מונעת אי-הבנות כאלה כבר בשלב מוקדם של תהליך הפיתוח.

#### בתים וערכים סקלאריים ואשכולות גרפמה! אללי!

נקודה נוספת לגבי UTF-8 היא שלמעשה, מנקודת המבט של ראסט, ישנן שלוש דרכים אפשריות להסתכל על מחרוזות: כבתים, כערכים סקלרים, וכאשכולות גרפמה (שאלו הדבר הקרוב ביותר למה שהיינו מכנים _אותיות_).

אם נסתכל על המילה ההינדית "नमस्ते" הכתובה בסקריפט Devanagari, היא מאוחסנת כוקטור של ערכי 'u8' שנראה כך:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

מדובר ב-18 בתים, ובסופו של יום, כך מחשבים מאחסנים נתונים אלה. אם נסתכל עליהם כערכי יוניקוד סקלאריים, שהוא סוג קידוד התווים בשפת ראסט, בתים אלה יראו כך:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

יש כאן שישה ערכי 'char', אבל הרביעי והשישי אינם אותיות: הם סימנים דיאקריטיים שאין להם מובן בפני עצמם. לבסוף, אם נסתכל עליהם כאשכולות גרפמה, נקבל מה שניתן להחשיב כארבע האותיות המרכיבות את המילה ההינדית:

```text
["न", "म", "स्", "ते"]
```

ראסט מספקת דרכים שונות לפרש את נתוני המחרוזת הגולמיים, כך שכל תוכנית תוכל לבחור את הפרשנות הדרושה לה, לא משנה איזו שפה אנושית מייצגים הנתונים.

סיבה אחרונה שראסט לא מאפשרת לנו לגשת ל-`String` באמצעות אינדקס היא שגישה באינדקס צפויה לדרוש זמן קבוע (O(1)). אך לא ניתן להבטיח ביצועים אלה עבור הטיפוס `String`. ראסט הרי תצטרך לעבור על תוכן המחרוזת, מתחילתה ועד לאינדקס המבוקש, בכדי לקבוע כמה תווים חוקיים קיימים.

### חיתוך מחרוזות

אינדקס למחרוזת הוא לעתים קרובות רעיון רע מכיוון שלא ברור מה צריך להיות סוג ההחזרה של גישה באמצעות אינדקס: האם ערך בתים, האם תו, אשכול גרפמה, או חיתוך מחרוזת. אם אתה באמת צריך להשתמש באינדקסים כדי ליצור חיתוכי מחרוזות, ראסט תבקש ממך להיות מדויק יותר בבקשתך.

במקום לגשת לאינדקס באמצעות `[]` עם מספר בודד, אתה יכול להשתמש ב-`[]` עם טווח כדי ליצור פרוסת מחרוזת המכילה בתים מסוימים:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

כאן, `s` יהיה מטיפוס `&str` שמכיל את 4 הבתים הראשונים של המחרוזת. קודם ציינו שכל אחד מהתווים האלה היה בן 2 בתים, מה שאומר ש-'s' יהיה 'Зд'.

אם היינו מנסים לחתוך רק חלק מהבתים של תו מסוים, נניח עם משהו כגון `&hello[0..1]`, ראסט היתה נכנסת לפאניקה בזמן הריצה, ממש כאילו ניגשנו לאינדקס לא-חוקי בוקטור:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

בבואכם ליצור חיתוכי מחרוזת, נקטו במשנה זהירות, כי פעולה זו עלולה להביא לקריסת התוכנית.

### מתודות לאיטרציה על מחרוזות

הדרך הטובה ביותר לפעול על חיתוכי מחרוזות היא לציין במפורש האם אתם מעוניינים בתווים או בבתים. עבור ערכי יוניקוד סקלארים בודדים, השתמשו במתודת `chars`. קריאה ל-`chars` ב-"Зд" מפרידה ומחזירה שני ערכים מסוג `chars`, ואתם יכולים לחזור על התוצאה בכדי לגשת לכל פריט בתורו:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

קוד זה ידפיס את הפלט הבא:

```text
З
д
```

לחלופין, המתודה `bytes` תחזיר ערכי בתים גולמיים, אם זה מה שאתם רוצים:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

קוד זה ידפיס את ארבעת הבתים המרכיבים מחרוזת זו:

```טקסט
208
151
208
180
```

הקפידו לזכור שערכי יוניקוד סקלארים חוקיים עשויים להיות מורכבים מיותר מבית אחד.

קבלת אשכולות גרפמה ממחרוזות, בדומה לדוגמת Devanagari, היא מורכבת יותר. לכן, פונקציונליות זו אינה כלולה בספרייה הסטנדרטית. אם זו הפונקציונליות הנדרשת לכם, תוכלו למצוא מכולות מתאימות ב-[crates.io](https://crates.io/)<!-- ignore -->.

### מחרוזות אינן כה פשוטות

לסיכום, מחרוזות הן נושא מורכב. שפות תכנות שונות עושות בחירות שונות כיצד להנגיש את המורכבות הזו למתכנת. ראסט בחרה להפוך את הטיפול הנכון בנתוני 'מחרוזת' להתנהגות ברירת-המחדל של כל תכנית, מה שאומר שמתכנתים צריכים להשקיע מעט יותר מחשבה בטיפול בנתוני UTF-8. פשרה זו אמנם חושפת יותר מן המורכבות הפנימית של מחרוזות ביחס לשפות תכנות אחרות, אך מאידך, היא חוסכת מכם טיפול אפשרי בשגיאות שעלולות לצוץ מאוחר הרבה יותר במחזור חיי הפיתוח.

החדשות הטובות הן שהספרייה הסטנדרטית מציעה פונקציונליות רבה לטיפוסים `String` ו-`&str`, הנועדה בדיוק כדי לטפל במצבים מורכבים אלו בצורה נכונה. הקפידו לבדוק את התיעוד של מתודות שימושיות כמו `contains` לחיפוש במחרוזת, או `replace` להחלפת חלקים קיימים של מחרוזת במחרוזת אחרת.

הבה נעבור למשהו קצת פחות מורכב: מפות גיבוב!
