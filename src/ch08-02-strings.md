## אחסון טקסט בקידוד UTF-8 כמחרוזת

דיברנו מעט על מחרוזות בפרק 4, אבל כעת נדון בהן לעמקן. ראסטיונרים מסתבכים לרוב עם מחרוזות משלוש סיבות: ראשית, הנטייה של ראסט לחשוף שגיאות אפשריות; שנית, היות מחרוזות מבנה נתונים מסובך יותר ממה שמתכנתים רבים נוטים לחשוב, ושלישית, קידוד UTF-8. כאשר אתה מגיע משפות תכנות אחרות, סיבות אלו עלולות להשתלב לכדי קושי אמיתי.

אנו דנים כאן במחרוזות בהקשר של אוספים כיוון שמחרוזות מיושמות כאוסף של בתים (bytes), בתוספת מתודות שימושיות המעניקות פונקציונליות שימושית כאשר אותם בתים מתפרשים כטקסט. בחלק זה נדון בפעולות על `מחרוזת` שיש לכל סוג אוסף, כגון יצירה, עדכון וקריאה. נדון גם בדרכים שבהן 'מחרוזת' שונה מאוספים האחרים, כלומר כיצד אינדקס ל'מחרוזת' הופך למורכב יותר ממה שנדמה, בעקבות האופן השונה-בתכלית בו בו אנשים ומחשבים מפרשים נתוני 'מחרוזת'.

### מה זה מחרוזת?

תחילה נגדיר למה אנחנו מתכוונים במונח _מחרוזת_. בבסיס השפה, לראסט יש רק סוג מחרוזת אחד, וזהו חיתוך המחרוזת `str`, נפוץ לרוב כלל בצורתו המושאלת `&str`. בפרק 4, דיברנו על _חיתוכי מחרוזות_, שאינם אלא הפניות לנתוני מחרוזת מקודדים ב-UTF-8 המאוחסנים במקום כזה או אחר בזיכרון. מחרוזות מפורשות (string literals), למשל, מאוחסנים בבינארי של התוכנית, ולכן נחשבים הם חיתוכי מחרוזת.

הטיפוס `String`, מסופק על ידי הספרייה הסטנדרטית של ראסט, ואינו מקודד בשפת הליבה. זהו טיפוס מחרוזת בקידוד UTF-8 המסוגל לשנות את גודלו, ושניתן לשינוי ולבעלות. כאשר ראסטיונרים מדברים על "מחרוזות", ייתכן שהם מתייחסים לטיפוס `String` או לטיפוס '&str' של חיתוך המחרוזת. למרות שסעיף זה עוסק בעיקר בטיפוס `String`, שני הטיפוסים נמצאים בשימוש תדיר בספרייה הסטנדרטית של ראסט, ושניהם מקודדים בפורמט UTF-8.

### יצירת מחרוזת חדשה

רבות מאותן פעולות הזמינות לשימוש עם `Vec<T>` זמינות גם עם `String`, כיוון ש- `String` ממומשת למעשה כעטיפה סביב וקטור של בתים בתוספת ערבויות, הגבלות ויכולות נוספות. דוגמה לפונקציה שפועלת באותו אופן עם `Vec<T>` ו-`String` היא הפונקציה `new` המאפשרת יצירת מופע חדש, כפי שמציגה ברשימה 8-11.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

<span class="caption">רשימה 8-11: יצירת `String` חדשה וריקה</span>

שורה זו יוצרת מחרוזת ריקה חדשה בשם `s`, אליה נוכל לטעון נתונים. לעתים קרובות, יהיו לנו נתונים ראשוניים שברצוננו להתחיל איתם את המחרוזת. לשם כך, אנו משתמשים במתודה 'to_string', שזמינה עבור כל טיפוס המיישם את תכונת ה-'Display', כפי שעושות מחרוזות מפורשות. רשימה 8-12 מציגה שתי דוגמאות.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

<span class="caption">רשימה 8-12: שימוש בשיטת `to_string` ליצירת `String` ממחרוזת מפורשת </span>

קוד זה יוצר מחרוזת המכילה `initial contents`.

נוכל גם להשתמש בפונקציה `String::from` כדי ליצור `String` ממחרוזת מפורשת. הקוד ברשימה 8-13 שקול לקוד מרשימה 8-12 שמשתמש ב-'to_string'.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

<span class="caption">רשימה 8-13: שימוש בפונקציה `String::from` כדי ליצור `String` ממחרוזת מפורשת </span>

מכיוון שמחרוזות משמשות לכל כך הרבה דברים, אנחנו יכולים להשתמש בשלל ממשקי API גנריים המספקים לנו אפשרויות רבות. חלקם עשוים להיראות מיותרים, אך כולם ראויים! במקרה זה, `String::from` ו-`to_string` מבצעים את אותו הדבר, אז מה שתבחרו יהיה סוגיה של סגנון וקריאות.

יש לזכור שמחרוזות מקודדות בקידוד UTF-8, כך שנוכל לכלול בהן כל נתונים מקודדים נכונה, כפי שמציגה רשימה 8-14.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

<span class="caption">רישום 8-14: אחסון ברכות בשפות שונות במחרוזות</span>

כל אלה הם ערכי `String` חוקיים.

### עדכון מחרוזת

`String` יכולה לגדול והתוכן שלה יכול להשתנות, בדיוק כמו `Vec<T>`, אם תדחוף לתוכו נתונים נוספים. בנוסף, כדי לשרשר ערכי `מחרוזת`, ניתן להשתמש באופרטור `+` או במאקרו `format!`.

#### צירוף לקצה מחרוזת עם `push_str` ו-`push`

אנו יכולים להגדיל `String` על ידי שימוש בשיטת `push_str` כדי לצרף חיתוך מחרוזת לסופה, כפי שמציגה רשימה 8-15.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

<span class="caption">רשימה 8-15: צירוף חיתוך מחרוזת ל-`String` עם מתודת `push_str`</span>

אחרי שתי שורות אלה, `s` יכיל את `foobar`. מתודת `push_str` מקבלת חיתוך מחרוזת כיוון שלא בהכרח נרצה לקחת בעלות על הפרמטר. לדוגמה, ברשימה 8-16, אנו רוצים להיות מסוגלים להשתמש ב-'s2' גם לאחר הוספת התוכן שלו ל-'s1'.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

<span class="caption">רשימה 8-16: שימוש בחיתוך מחרוזת לאחר צירוף התוכן שלו ל`String`</span>

אם מתודת `push_str` לקחה בעלות על `s2`, לא נוכל להדפיס את הערך שלה בשורה האחרונה. עם זאת, קוד זה עובד כפי שהיינו מצפים!

המתודה `push` לוקחת תו בודד כפרמטר ומוסיפה אותו ל`String`. רשימה 8-17 מוסיף את האות "l" ל'מחרוזת' באמצעות המתודה `push`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

<span class="caption">רשימה 8-17: הוספת תו אחד לערך `String` באמצעות `push`</span>
כתוצאה מכך, `s` תכיל `lol`.

#### שרשור עם האופרטור `+` או המאקרו `format!`

לעתים קרובות נרצה לשרשר שתי מחרוזות קיימות. אחת הדרכים לעשות זאת היא להשתמש באופרטור `+`, כפי שמציגה רשימה 8-18.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

<span class="caption">רשימה 8-18: שימוש באופרטור `+` לחיבור שני ערכי `String` לערך `String` חדש</span>

המחרוזת `s3` תכיל את `Hello, world!`. הסיבה מדוע `s1` כבר לא תקף לאחר החיבור, והסיבה מדוע השתמשנו בהפניה ל-`s2` קשורה לחותם המתודה שנקראת כאשר אנו משתמשים באופרטור `+`. האופרטור `+` משתמש מתודת `add`, שהחותם שלה נראה בערך כך:

```rust,ignore
fn add(self, s: &str) -> String {
```

בספרייה הסטנדרטית, תראה את המתודה `add` מוגדרת באמצעות ג’נריקס וטיפוסים משויכים. בדוגמה כאן, החלפנו בטיפוסים קונקרטיים, שזה מה שקורה בפועל כשאנחנו קוראים לשיטה הזו עם ערכי `String`. נדון בהרחבה בטיפוסים גנריים בפרק 10. בכל זאת - חותם זה נותן לנו את הרמזים הדרושים בכדי להבין את החלקים המורכבים של האופרטור `+`.

ראשית, לארגומנט `s2` יש `&`, כלומר אנו מוסיפים _הפניה_ של המחרוזת השנייה למחרוזת הראשונה. הסיבה לכך נעוצה בפרמטר `s` בפונקציה `add`: אנו יכולים להוסיף רק `&str` ל`String`; אנחנו לא יכולים להוסיף שני ערכי `String` ביחד. אבל רגע - הטיפוס של `s2&` הוא `String&`, לא `str&`, כפי שצוין בפרמטר השני ל-'add'. אם כך, מדוע רשימה 8-18 עוברת קומפילציה?

הסיבה שאנו מסוגלים להשתמש ב-`s2&` בקריאה ל-`add` היא שהקומפיילר יכול _להכריח_ את הארגומנט `String&` לתוך `str&`. כאשר אנו קוראים למתודת `add`, ראסט מפעילה _כפיית דה-הפניה_, אשר הופכת כאן את `s2&` ל-`[..]s2&`. נדון עוד בכפיית דה-הפניה בפרק 15. כיוון ש-`add` אינה לוקחת בעלות על הפרמטר `s2`, `s2` יהיה עדיין טיפוס `String` חוקי לאחר הפעולה.

שנית, אנו יכולים לראות בחותם ש-'add' לוקחת בעלות על `self`, מכיוון של-`self` _אין_ `&`. פירוש הדבר ש-`s1` ברשימה 8-18 יועבר לקריאה ל-`add`, ולאחר-מכן לא יהיה תקף. אז למרות ש-`let s3 = s1 + &s2;` נראה כאילו שתי המחרוזות יועתקו אל תוך מחרוזת חדשה, הצהרה זו למעשה לוקחת בעלות על `s1`, מצרפת עותק עם התוכן של `s2`, ואז מחזירה בעלות על התוצאה. במילים אחרות, זה נראה כאילו נוצרים כאן עותקים רבים, אך לא כך הדבר; מימוש זה יעיל יותר מהעתקה.

עם זאת, אם אנחנו צריכים לשרשר מחרוזות מרובות, ההתנהגות של האופרטור `+` הופכת למסורבלת:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

בשלב זה, 's' יהיה 'tic-tac-toe'. עם כל התווים `+` ו-```, קשה לראות מה קורה. במקום זאת, אם נידרש לשילוב מחרוזות מורכב יותר, נוכל להשתמש במאקרו `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

קוד זה גם מגדיר את `s` ל-`tic-tac-toe`. המאקרו `format!` פועל בדומה ל-`println!`, אך במקום להדפיס את הפלט למסך, הוא מחזיר `String` עם התוכן. גרסת הקוד עם 'format!' קלה הרבה יותר לקריאה, והקוד שנוצר על ידי המאקרו 'format!' משתמש בהפניות כך שהקריאה הזו לא לוקחת בעלות על אף אחד מהפרמטרים שלה.

### גישה למחרוזת באמצעות אינדקס

בשפות תכנות רבות אחרות, גישה ישירה לתווים בודדים במחרוזת באמצעות ציון אינדקס היא פעולה חוקית ונפוצה. עם זאת, בראסט, הניסיון לגשת לחלקים של `String` באמצעות תחביר אינדקס יתקל בשגיאה. התבוננו בקוד הלא-תקין ברשימה 8-19.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

<span class="caption">רשימה 8-19: ניסיון להשתמש בתחביר אינדקס עם מחרוזת</span>

קוד זה יוביל לשגיאה הבאה:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

השגיאה וההערה מספרים את הסיפור כולו: מחרוזות בראסט אינן תומכות בתחביר אינדקס. אבל מדוע לא? כדי לענות על השאלה הזו, עלינו לדון כיצד ראסט מאחסן מחרוזות בזיכרון.

#### ייצוג פנימי

כאמור, הטיפוס `String` אינו אלא עטיפה של `Vec<u8>`. הבה נתבונן במספר מחרוזות דוגמה ברשימה 8-14. כולן מקודדות כראוי בקידוד UTF-8. ראשית, זו:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

במקרה זה, ערכו של `len` יהיה 4, מה שאומר שהווקטור המאחסן את המחרוזת "Hola" הוא באורך 4 בתים. בקידוד UTF-8, כל אחת מהאותיות הללו דורשת 1 בייט. השורה הבאה, לעומת זאת, עשויה להפתיע אותך. (שים לב שהמחרוזת הזו מתחילה באות הקירילית הגדולה Ze, לא המספר הערבי 3.)

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

בתשובה לשאלה מה אורך המחרוזת, תתפתו אולי לומר 12. למעשה, התשובה של ראסט היא 24: זה מספר הבתים שנדרש כדי לקודד "Здравствуйте" בקידוד UTF-8. זאת כיוון שכל ערך סקלארי של יוניקוד במחרוזת זו דורש 2 בתים של אחסון . לכן, אינדקס לבתים של מחרוזת זו לא תמיד יתאם לערך יוניקוד סקלארי חוקי. כדי להבין זאת טוב יותר, התבונן בקוד הלא-תקין הזה:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

אנחנו כבר יודעים ש`answer` לא תהיה `З`, האות הראשונה. בקידוד UTF-8, ערך הבייט הראשון של `З` הוא `208`, וערך השני הוא `151`, כך שנראה שערכו של `answer` צריך להיות למעשה `208`. אך `208` אינו חוקי בפני עצמו. סביר להניח שהחזרת '208' אינה מה שהמשתמש היה רוצה לו היה מבקש את האות הראשונה של המחרוזת הזו; עם זאת, אלו הנתונים היחידים שיש לראסט באינדקס 0. גם אם המחרוזת מכילה רק אותיות לטיניות, משתמשים בדרך כלל לא רוצים לקבל את ערך הבייטים עצמם: לו `&"hello"[0]` היה קוד חוקי, הוא היה מחזיר `104`, לא `h`.

התשובה, אם כן, היא שכדי להימנע מהחזרת ערך בלתי-צפוי שעלול להוביל באגים שאולי לא יתגלו מיד, ראסט מסרבת מראש לקמפל את הקוד הזה, ומונעת בכך אי-הבנות מעין אלה כבר בשלב מוקדם של תהליך הפיתוח.

#### בייטים וערכים סקלאריים ואשכולות גרפמה! אללי!

נקודה נוספת לגבי UTF-8 היא שלמעשה, מנקודת המבט של ראסט, ישנן שלוש דרכים אפשריות להסתכל על מחרוזות: כבתים, כערכים סקלרים, וכאשכולות גרפמה (שאלו הדבר הקרוב ביותר למה שהיינו מכנים _אותיות_).

אם נסתכל על המילה ההינדית "नमस्ते" הכתובה בסקריפט Devanagari, היא מאוחסנת כווקטור של ערכי 'u8' שנראה כך:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

נמדובר ב-18 בתים, וכך מחשבים מאחסנים בסופו של דבר את נתונים אלה. אם נסתכל עליהם כערכים סקלאריים של Unicode, שהם סוג התווים בשפת ראסט, בתים אלה נראים כך:

```text
['न', 'म', 'स', '्', 'त', 'े']
```

יש כאן שישה ערכי 'char', אבל הרביעי והשישי אינם אותיות: הם סימנים דיאקריטיים שאין להם מובן בפני עצמם. לבסוף, אם נסתכל עליהם כאשכולות גרפמה, נקבל מה שניתן להחשיב כארבע האותיות המרכיבות את המילה ההינדית:

```text
["न", "म", "स्", "ते"]
```

ראסט מספקת דרכים שונות לפרש את נתוני המחרוזת הגולמיים, כך שכל תוכנית תוכל לבחור את הפרשנות הדרושה לה, לא משנה איזו שפה אנושית מייצגים הנתונים.

סיבה אחרונה שראסט לא מאפשרת לנו לגשת ל-`String` באמצעות אינדקס היא שגישה באינדקס צפויה לדרוש זמן קבוע (O(1)). אך עבור טיפוס `String`, לא ניתן להבטיח את הביצועים האלה. ראסט הרי תצטרך לעבור על התוכן מתחילת המחרוזת עד לאינדקס המבוקש, בכדי לקבוע כמה תווים חוקיים היו.

### חיתוך מחרוזות

אינדקס למחרוזת הוא לעתים קרובות רעיון רע מכיוון שלא ברור מה צריך להיות סוג ההחזרה של פעולת גישה באמצעות אינדקס: האם ערך בתים, האם תו, אשכול גרפמה, או חיתוך מחרוזת. אם אתה באמת צריך להשתמש באינדקסים כדי ליצור חיתוכי מחרוזות, ראסט תבקש ממך להיות מדויק יותר בבקשתך.

במקום לגשת לאינדקס באמצעות `[]` עם מספר בודד, אתה יכול להשתמש ב-`[]` עם טווח כדי ליצור פרוסת מחרוזת המכילה בתים מסוימים:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

כאן, `s` יהיה מטיפוס `&str` שמכיל את 4 הבתים הראשונים של המחרוזת. קודם ציינו שכל אחד מהתווים האלה היה בן 2 בתים, מה שאומר ש-'s' יהיה 'Зд'.

אם היינו מנסים לחתוך רק חלק מהבתים של תו מסוים, נניח עם משהו כגון `&hello[0..1]`, ראסט היתה נכנסת לפאניקה בזמן הריצה, באותו אופן כאילו ניגשנו לאינדקס לא חוקי בווקטור:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

בבואך ליצור חיתוכי מחרוזת, נקוט במשנה זהירות, כי פעולה זו עלולה להביא לקריסת התוכנית שלך.

### שיטות לאיטרציה על מחרוזות

הדרך הטובה ביותר לפעול על חיתוכי מחרוזות היא להיות מפורש לגבי האם רצונך בתווים או בבתים. עבור ערכי יוניקוד סקלארים בודדים, השתמש במתודת `chars`. קריאה ל-`chars` ב-"Зд" מפרידה ומחזירה שני ערכים מסוג `chars`, ואתה יכול לחזור על התוצאה כדי לגשת לכל פריט:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

קוד זה ידפיס את הפלט הבא:

```text
З
д
```

לחלופין, המתודה `bytes` תחזיר ערכי בתים גולמיים, מה שעשוי להתאים לתחום שלך:

```rust
עבור b ב-"Зд".bytes() {
     println!("{b}");
}
```

קוד זה ידפיס את ארבעת הבתים המרכיבים את המחרוזת הזו:

```טקסט
208
151
208
180
```

אבל הקפד לזכור שערכים סקלארים חוקיים של יוניקוד עשויים להיות מורכבים מיותר מבית אחד.

קבלת אשכולות גרפמה ממחרוזות, בדומה לדוגמת Devanagari, היא מורכבת יותר. לכן, פונקציונליות זו אינה כלולה בספרייה הסטנדרטית. אם זו הפונקציונליות הנדרשת לכם, תוכלו למצוא מכולות מתאימות ב-[crates.io](https://crates.io/)<!-- ignore -->.

### מחרוזות אינן כל כך פשוטות

לסיכום, מחרוזות הן נושא מורכב. שפות תכנות שונות עושות בחירות שונות לגבי איך להנגיש את המורכבות הזו למתכנת. ראסט בחרה להפוך את הטיפול הנכון בנתוני 'מחרוזת' להתנהגות ברירת-המחדל של כל תכנית, מה שאומר שמתכנתים צריכים להשקיע מעט יותר מחשבה בטיפול בנתוני UTF-8. פשרה זו חושפת יותר מהמורכבות הפנימית של מחרוזות ביחס לשפות תכנות אחרות, אך היא חוסכת ממך טיפול בשגיאות המערבות תווי יוניקוד מאוחר יותר במחזור חיי הפיתוח שלך.

החדשות הטובות הן שהספרייה הסטנדרטית מציעה פונקציונליות רבה המורכבת מהסוגים `String` ו-`&str` כדי לטפל במצבים מורכבים אלו בצורה נכונה. הקפד לבדוק את התיעוד לשיטות שימושיות כמו `contains` לחיפוש במחרוזת, או `replace` להחלפת חלקים של מחרוזת קיימת במחרוזת אחרת.

הבה נעבור למשהו קצת פחות מורכב: מפות גיבוב!
