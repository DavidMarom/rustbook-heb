## משתנים וברות-שינוי

כפי שהוזכר בסעיף ["אחסון ערכים למשתנים"][storing-values-with-variables]<!-- ignore -->, ברירת המחדל בראסט היא שמשתנים אינם ברי שינוי. זהו אחד המנגנונים המובנים בשפה שנועדו לדרבן אתכם לכתוב קוד באופן שמנצל את הבטיחות ונוחות המקביליות שראסט מציעה. בכל זאת, עדיין יש לכם את האפשרות לגרום למשתנים שלכם להיות ברי-שינוי. הבה נבין כיצד ומדוע ראסט מעודדת אתכם להעדיף חוסר ברות-שינוי ומדוע, לעיתים, יתכן ותרצו להתעקש על ברות-שינוי.

כאשר משתנה אינו בר-שינוי, מרגע שערך נקשר לשם המשתנה, לא ניתן לשנות את אותו הערך. כדי להדגים זאת, צרו פרוייקט חדש בשם _variables_ בתיקיית הפרוייקטים שלכם על-ידי הרצת `cargo new variables`.

ואז, בתיקייה החדשה _variables_, פתחו את הקובץ _src/main.rs_ והחליפו את הקוד שבו בקוד הבא, אשר לא יעבור קומפילציה בשלב זה:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

שמרו את השינויים והקלידו`cargo run` בכדי להריץ את התוכנית. תופיעה הודעת שגיאה המציינת שהמשתנה שהגדרתם מנוע-שינוי:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

דוגמא זו מראה כיצד הקומפיילר מסייע במציאת טעויות בתכניות שלכם. שגיאות קומפילציה יכולות להיות מתישות, אבל הן שם כדי להתריע שהתכנית שלכם עדיין לא מבצעת בבטיחות את מה שאתם רוצים שהיא תבצע; השגיאות _אינן_ אומרות שאינכם מתכנתים טובים! גם ראסטיונרים מנוסים מקבלים שגיאות קומפילציה.

קיבלתם את הודעת השגיאה `` cannot assign twice to immutable variable `x` `` מכיוון שניסיתם לקשור ערך שני למשתנה `x`, שאינו בר-שינוי.

שגיאות קומפילציה עשויות להיות בעלת חשיבות רבה כאשר אנו מנסים לשנות ערך שאינו בר-שינוי, כיוון שעצם הניסיון עלול להוביל לבאגים. אם חלק מסוים בקוד שלנו פועל תחת ההנחה שערך כלשהו לעולם לא ישתנה, וחלק אחר בקוד משנה את אותו הערך, אז הקוד בחלק הראשון עלול לא לעשות את מה שהוא תוכנן לעשות. סוג זה של באגים עלול להיות קשה לאיתור מאוחר יותר, במיוחד אם פיסת הקוד השניה משנה את הערך האמור רק _לפעמים_. הקומפיילר של ראסט מבטיח שאם מציינים שערך לא ישתנה, אז הוא באמת לא ישתנה. כך נחסך ממכם הצורך לעקוב אחר זאת בעצמכם, ומתקבל קוד נוח יותר להבנה וניתוח.

בכל זאת, ברות-שינוי יכולה להיות מאוד שימושית, כיוון שביכולתה להפוך את כתיבה הקוד לקלה יותר. למרות שברירת המחדל בראסט היא שמשתנים אינם ברי-שינוי, ניתן להפוך אותם לכאלה על-ידי הוספת מילת המפתח `mut` לפני שם המשתנה, כפי שעשיתם [בפרק 2][storing-values-with-variables]<!-- ignore -->. הוספה של `mut` גם מבהירה לקוראים עתידיים של הקוד את הכוונה שחלקים אחרים של הקוד ישנו את ערך המשתנה.

למשל, הבה נשנה את תוכן הקובץ _src/main.rs_ כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

אם נריץ את התכנית עכשיו, אז נקבל:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

כאשר נעשה שימוש במילת המפתח`mut` , מותר לנו לשנות את הערך הקשור ל-`x` מ-`5` ל-`6`. בסופו של דבר, ההחלטה אם כן או לא להשתמש בברות-שינוי היא בידכם ותלויה במה שלהבנתכם יהיה נהיר ביותר בסיטואציה הנתונה.

### קבועים

_קבועים_, בדומה למשתנים שאינם ברי-שינוי, הם ערכים הקשורים לשם ואסור לשנות אותם. אבל יש כמה הבדלים בין קבועים למשתנים.

ראשית, לא ניתן להשתמש ב-`mut` עם קבועים. קבועים אינם רק מנועי-שינוי כברירת מחדל -- הם אף פעם לא יכולים להיות ברי-שינוי, בהגדרתם. ניתן להגדיר קבועים על-ידי שימוש במילת המפתח `const` במקום במילת המפתח `let`, והטיפוס של הערך _חייב_ להיות מבואר. אנו נדון בטיפוסים ובביאור טיפוס בסעיף הבא, [טיפוסי דאטה][data-types]<!-- ignore -->, כך שכרגע אין צורך לדאוג לגבי הפרטים. רק זכרו שתמיד חייבים לבאר את הטיפוס.

ניתן להכריז על קבועים בכל מתחם, כולל המתחם הגלובאלי. עובדה זו עושה אותם ליעילים ביותר במקרים בהם חלקים שונים בקוד דורשים אליהם גישה.

ההבדל האחרון בין קבועים למשתנים הוא שקבועים יכולים לקבל אך ורק ביטויים קבועים, ובשום פנים לא תוצאה של ערך המקבל את ערכו בזמן הריצה.

הינה דוגמא להכרזה של קבוע:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

שם הקבוע הוא `THREE_HOURS_IN_SECONDS` וערכו הוא התוצאה של הכפלת המספר 60 (מספר השניות בדקה) במספר 60 (מספר הדקות בשעה) במספר 3 (מספר השעות שאנו רוצים למדוד בתוכנית). המוסכמה לנתינת שמות לקבועים בראסט היא שימוש באותיות גדולות בלבד, והפרדת מילים באמצעות מקפים תחתונים. הקומפיילר יכול להעריך בזמן הקומפילציה אוסף מצומצם של פעולות. זה מאפשר לנו לבחור לכתוב את הערך בדרך קלה להבנה ולבדיקה, כך שעדיף לנו לקשור את ערך הקבוע באמצעות פירוט אופן החישוב, מאשר לקשור את הקבוע ישירות לערך 10,800. ראו [Rust Reference’s section on constant evaluation][const-eval] למידע נוסף בדבר הפעולות המותרות לשימוש בזמן הכרזה על קבועים.

קבועים תקפים לאורך כל זמן הריצה של התכנית, ובמתחם בו הם הוכרזו. תכונה זו הופכת קבועים לשימושיים עבור ערכים באפליקציה שלכם שחלקים רבים של התוכנית צריכים, למשל המספר המקסימלי של נקודות ששחקן במשחק יכול לצבור, או מהירות האור.

דרך פעולה זו, לפיה ערכים שרירים וידועים-מראש (כגון, נניח, מספר השניות בשלוש שעות) מוכרזים כקבועים, מסייעת בהעברת מהות הערך למתחזקים עתידיים של הקוד. במידה והערכים המקובעים יעברו עדכון בעתיד, ישנו רק מקום אחד בקוד אותו יהיה צריך לשנות.

### האפלה

כפי שראיתם בפרק אודות משחק ניחוש המספר [בפרק 2]()<!-- ignore -->, ניתן להכריז על משתנה חדש עם אותו שם כמו משתנה קודם. ראסטיונרים אומרים שהמשתנה הראשון _מואפל_ (shadowed) על-ידי השני, מה שאומר שהמשתנה השני הוא זה שהקומפיילר יראה כאשר תשתמשו בשם של המשתמש. למעשה, המשתנה השני מאפיל על הראשון ודורש את כל השימושים בשם המשתמש לעצמו, עד שהוא עצמו יואפל על-ידי משתנה אחר, או שיצא מחוץ למתחם. ניתן להאפיל על משתנה על-ידי שימוש בשם של המשתנה הקיים ביחד עם מילת המפתח `let`, למשל כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

ראשית, תכנית זאת מקשרת את `x` לערך `5`. אז היא יוצרת את המשתנה החדש `x` על-ידי שימוש חוזר ב- `let x =`, לוקחת את הערך המקורי ומוסיפה לו `1`, כך שהערך של `x` הוא `6`. אח"כ, בתוך מתחם פנימי שנוצר על-ידי הסוגרים המסולסלים, פקודת ה- `let` השלישית מעפילה גם היא על `x` ויוצרת משתנה חדש וכופלת את הערך הקודם ב- `2` כדי לתת ל- `x` את הערך `12`. כאשר מתחם זה מגיע לסופו, ההעפלה הפנימית מסתיימת והמשתנה `x` חוזר להיות `6`. כאשר מריצים את התכנית מקבלים את הפלט הבא:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

האפלה אינה שקולה להכרזה על משתנה כ-`mut` . אם ננסה בטעות לשנות את הערך ללא שימוש במילת המפתח `let `, נקבל שגיאת קומפילציה. על-ידי שימוש ב-`let` ניתן לבצע מספר שינויים בערך מסוים ולקבל, לאחר תום השינויים, ערך שאינו בר-שינוי.

קיים הבדל נוסף וחשוב בין שימוש במילת המפתח `mut`, להאפלה. משום שלמעשה אנו יוצרים משתנה חדש כשאנחנו משתמשים במילת המפתח `let` פעם נוספת, אנו יכולים לשנות את טיפוס הערך תוך שימור שם המשתנה. למשל, נניח שהתכנית שלנו מבקשת מהמשתמש לתאר כמה תווי רווח צריכים להיות בין טקסט כלשהו על-ידי הקלדת תווי רווח, ואז אנחנו רוצים לשמור את הקלט כמספר:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

המשתנה `spaces` הראשון הוא מטיפוס מחרוזת והמשתנה `spaces` השני הוא מטיפוס מספר. האפלה חוסכת מאיתנו את הצורך להמציא שמות שונים, כגון `spaces_str` ו-`spaces_num`; במקום זאת ניתן פשוט לעשות שימוש חוזר בשם `spaces`. אולם, אם ננסה להשתמש ב-`mut`, כמוצג כאן, נקבל שגיאת קומפילציה:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

השגיאה אומרת לנו שאסור לנו לשנות את טיפוס המשתנה:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

עכשיו משראינו כיצד משתנים מתנהגים, הבה נביט על כמה טיפוסי דאטה נוספים שהם יכולים לקבל.

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
