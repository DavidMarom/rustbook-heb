## משתנים וברות-שינוי

כפי שהוזכר בסעיף ["אכסון ערכים למשתנים"][storing-values-with-variables]<!-- ignore -->, ברירת המחדל היא שמשתנים אינם ברי שינוי. זהו מנגנון אחד מיני רבים המתוכננים כדי לדרבן אתכם לכתוב קוד בצורה שמנצלת את הבטיחות ונוחות המקביליות שראסט מציעה. אבל, עדיין יש לכם את האפשרות לגרום למשתנים שלכם להיות ברי-שינוי. הבה נבין כיצד ומדוע ראסט מעודדת אתכם להעדיף חוסר ברות-שינוי ומדוע, לעיתים, יתכן ותרצו להתעקש על ברות-שינוי.

כאשר משתנה אינו בר-שינוי, מרגע שערך נקשר לשם המשתנה לא ניתן לשנות את הערך. כדי להדגים זאת, צרו פרוייקט חדש בשם *variables* בתיקיית הפרוייקטים שלכם ע"י הרצת `cargo new variables`.

ואז, בתיקייה החדשה *variables*, פתחו את הקובץ *src/main.rs* והחליפו את הקוד שבו בקוד הבא, אשר לא יעבור קומפילציה בשלב זה:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

בצעו שמירה והריצו את התכנית ע"י `cargo run`. אתם צריכים לקבל הודעת שגיאה בדבר העדר ברות-שינוי, כפי שמוצג בקלט:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

דוגמא זו מראה כיצד הקומפיילר מסייע במציאת טעויות בתכניות שלכם. שגיאות קומפילציה יכולות להיות מתישות, אבל הן שם כדי להתריע שהתכנית שלכם עדיין לא מבצעת בבטיחות את מה שאתם רוצים שהיא תבצע; השגיאות *אינן* אומרות שאינכם מתכנתים טובים! גם ראסטיונרים מנוסים מקבלים שגיאות קומפילציה.

קיבלתם את הודעת השגיאה `` cannot assign twice to immutable variable `x` `` מכיוון שניסיתם לקשור ערך שני למשתנה `x`, אבל `x` אינו בר-שינוי.

יש חשיבות לקבלת שגיאות קומפילציה כשאנו מנסים לשנות ערך שאינו בר-שינוי כיוון שעצם הניסיון יכול להוביל לבאגים. אם חלק מסוים בקוד שלנו פועל תחת ההנחה שערך כלשהו לעולם לא ישתנה וחלק אחר בקוד משנה את הערך הזה, אז הקוד בחלק הראשון עלול לא לעשות את מה שהוא תוכנן לעשות. הגורם לסוג זה של באגים יכול להיות קשה לאיתור לאחר מעשה, במיוחד במידה ופיסת הקוד השניה משנה את הערך האמור רק *לפעמים*. הקומפיילר של ראסט מבטיח שאם מציינים שערך לא ישתנה, אז הוא באמת לא ישתנה, וכך נחסך ממכם הצורך לעקוב אחר זאת בעצמכם. כך מתקבל קוד נוח יותר להבנה ולניתוח.

אבל, ברות-שינוי יכולה להיות מאוד שימושית ועשויה לתרום לקלות הכתיבה של קוד. למרות שברירת המחדל היא שמשתנים הם לא ברי-שינוי, ניתן להפוך אותם לברי-שינוי ע"י הוספת `mut` לפני שם המשתנה, כפי שעשיתם [בפרק 2][storing-values-with-variables]<!-- ignore -->. הוספה של `mut` גם מבהירה לקוראים עתידיים של הקוד את הכוונה שחלקים אחרים של הקוד ישנו את ערך המשתנה.

למשל, הבה נשנה את תוכן הקובץ *src/main.rs* כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

אם נריץ את התכנית עכשיו, אז נקבל:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

מותר לנו לשנות את הערך הקשור ל-`x` מ-`5` ל-`6` כאשר נעשה שימוש ב-`mut`. בסופו של דבר, ההחלטה אם כן או לא להשתמש בברות-שינוי היא בידכם ותלויה במה שלהבנתכם יהיה נהיר ביותר בסיטואציה הנתונה.

### קבועים

*קבועים*, בדומה למשתנים שאינם ברי-שינוי, הם ערכים הקשורים לשם ואסור לשנות אותם. אבל יש כמה הבדלים בין קבועים למשתנים.

ראשית, לא ניתן להשתמש ב-`mut` עם קבועים. קבועים הם יותר רק מנועי-שינוי כברירת מחדל -- הם אף פעם לא יכולים להיות ברי-שינוי. מגדירים קבועים ע"י שימוש במילת המפתח `const` במקום במילת המפתח `let`, והטיפוס של הערך *חייב* להיות מבואר. אנו נדון בטיפוסים ובביאור טיפוס בסעיף הבא, [טיפוסי דאטה][data-types]<!-- ignore -->, כך שכרגע אין צורך לדאוג לגבי הפרטים. רק זכרו שתמיד חייבים לבאר את הטיפוס.

אפשר להכריז על קבועים בכל מתחם, כולל המתחם הגלובאלי, דבר ההופך אותם לשימושיים עבור ערכים אליהם חלקים רבים בקוד צריכים גישה.

ההבדל האחרון הוא שקבועים יכולים לקבל אך ורק ביטויים קבועים, ובשום פנים לא תוצאה של ערך שערכו ניתן לחישוב רק בזמן הריצה.

הינה דוגמא להכרזה של קבוע:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

שם הקבוע הוא `THREE_HOURS_IN_SECONDS` וערכו הוא התוצאה של הכפלת המספר 60 (מספר השניות בדקה) במספר 60 (מספר הדקות בשעה) במספר 3 (מספר השעות שאנו רוצים למדוד בתוכנית). הקונבנציה לנתינת שמות לקבועים בראסט משתמשת באותיות גדולות ומקפים תחתונים בין מילים. הקומפיילר יכול להעריך בזמן הקומפילציה אוסף מצומצם של פעולות. זה מאפשר לנו לבחור לכתוב את הערך בדרך קלה להבנה ולווידוא, במקום לקשור את הקבוע לערך 10,800. ראו [Rust Reference’s section on constant evaluation][const-eval] למידע נוסף בדבר הפעולות המותרות לשימוש בזמן הכרזה על קבועים.

קבועים תקפים לאורך זמן הריצה של התכנית, במתחם בו הם הוכרזו. תכונה זו הופכת קבועים לשימושיים עבור ערכים באפליקציה שלכם שחלקים רבים של התוכנית צריכים, למשל המספר המקסימלי של נקודות ששחקן במשחק יכול לצבור, או מהירות האור.

הכרזה על ערכים מקובעים, שבהם משתמשים במהלך התכנית, כקבועים מסייעת בהעברת המשמעות של הערך למתחזקים עתידיים של הקוד. זה גם עוזר שיש רק מקום אחד בקוד שצריך לשנות במידה והערכים המקובעים יעברו עדכון בעתיד.

### עיפול

כפי שראיתם בהדרכה של משחק ניחוש המספר [בפרק 2]()<!-- ignore -->, ניתן להכריז על משתנה חדש עם אותו שם כמו משתנה קודם. ראסטיונרים אומרים שהמשתנה הראשון *מועפל* (shadowed) ע"י השני, מה שאומר שהמשתנה השני הוא זה שהקומפיילר יראה כאשר תשתמשו בשם של המשתמש. למעשה, המשתנה השני מעפיל על הראשון ולוקח את כל השימושים בשם המשתמש לעצמו, עד שהוא עצמו יועפל ע"י משתנה אחר, או שיצא מחוץ למתחחם. ניתן להעפיל משתנה ע"י שימוש בשם של המשתנה הקיים ביחד עם מילת המפתח `let`, למשל כך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

תכנית זאת קודם מקשרת את `x` לערך `5`. אז היא יוצרת את המשתנה החדש `x` ע"י שימוש חוזר ב- `let x =`, לוקחת את הערך המקורי ומוסיפה לו `1`, כך שהערך של `x` הוא `6`. אח"כ, בתוך מתחם פנימי שנוצר ע"י הסוגרים המסולסלים, פקודת ה- `let` השלישית מעפילה גם היא על `x` ויוצרת משתנה חדש וכופלת את הערך הקודם ב- `2` כדי לתת ל- `x` את הערך `12`. כאשר מתחם זה מגיע לסופו, ההעפלה הפנימית מסתיימת והמשתנה `x` חוזר להיות `6`. כאשר מריצים את התכנית מקבלים את הפלט הבא:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

עיפול אינו שקול להכרזה על משתנה כ-`mut` כי אם ננסה בטעות לשנות את הערך ללא שימוש במילת המפתח `let `, נקבל שגיאת קומפילציה. ע"י שימוש ב-`let` ניתן לבצע מספר טרנספורמציות על ערך מסוים ולקבל, לאחר שהטרנספורמציות הושלמו, ערך שאינו בר-שינוי.

הבדל נוסף בין `mut` לעיפול הוא שמשום שאנחנו למעשה יוצרים משתנה חדש כשאנחנו משתמשים במילת המפתח `let` פעם נוספת, יש באפשרותינו לשנות את טיפוס הערך תוך שימור שם המשתנה. למשל, נניח שהתכנית שלנו מבקשת מהמשתמש לתאר כמה תווי רווח צריכים להיות בין טקסט כלשהו ע"י הקלדת תווי רווח, ואז אנחנו רוצים לשמור את הקלט כמספר:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

המשתנה `spaces` הראשון הוא מטיפוס מחרוזת והמשתנה `spaces` השני הוא מטיפוס מספר. עיפול חוסך מאיתנו את הצורך להמציא שמות שונים, כגון `spaces_str` ו-`spaces_num`; במקום זאת ניתן פשוט לעשות שימוש חוזר בשם `spaces`. אולם, אם ננסה להשתמש ב-`mut`, כמוצג כאן, נקבל שגיאת קומפילציה:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

השגיאה אומרת שאסור לנו לשנות את טיפוס המשתנה:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

עכשיו משראינו כיצד משתנים מתנהגים, הבה נביט על כמה טיפוסי דאטה נוספים שהם יכולים לקבל.

[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html