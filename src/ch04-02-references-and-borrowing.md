## הפניות והשאלות

עצם העניין שבשימוש ברצף בקוד שברשימה 4-5 הוא שאנחנו צריכים להחזיר את ה-`String` לפונקציה הקוראת כדי שנוכל להמשיך להשתמש ב- `String` אחרי הקריאה ל- `calculate_length`, בגלל שה-`String` הוזזה ל-`calculate_length`. במקום זאת, ניתן לספק הפניה לערך של ה- `String`. *הפניה* היא קצת כמו מצביע בכך שהיא כתובת בזיכרון אליה אנחנו יכולים לגשת כדי לקרוא את הדאטה בכתובת; הדאטה נמצא בבעלות של משתנה אחר. בניגוד למצביע, מובטח שהפניה מצביעה לערך תקף מטיפוס נתון וידוע לכל אורך החיים של ההפניה.

הינה הדרך להגדיר ולהשתמש בפונקציה `calculate_length` עם הפניה לאובייקט כפרמטר במקום לקיחת בעלות על הערך:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
```

ראשית, שימו לב שכל הקוד סביב הרצף והערך המוחזר מהפונקציה כבר לא שם. שנית, אנו מעבירים `&s1` ל-`calculate_length`, ובהגדרת הפונקציה אנחנו לוקחים `&String` במקום `String`. סימני האמפרסנט מייצגים *הפניות*, והם מאפשרים לכם להתייחס לערך מבלי לקחת בעלות עליו. תמונה 4-5 מבהירה את הרעיון הזה.

<img alt="Three tables: the table for s contains only a pointer to the table
for s1. The table for s1 contains the stack data for s1 and points to the
string data on the heap." src="img/trpl04-05.svg" class="center" />

<span class="caption">תמונה 4-5: דיאגרמה של `&String s` המצביע אל `String s1`</span>

> הערה: הפעולה ההפוכה להפניה תוך שימוש ב-`&` נקראת *דה-הפניה*, והיא מבוצעת באמצעות אופרטור הדה-הפניה, `*`. נראה כמה שימושים באופרטור הד-הפניה בפרק 8 ונדון בפרטים של דה-הפניות בפרק 15.

הבה נתבונן מקרוב בקריאה לפונקציה כאן:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
```

המבנה התחבירי `&s1` מאפשר ליצור הפניה *שמפנה* לערך של `s1` אבל לא לוקחת עליו בעלות. מכיוון שהיא לא בעלת הערך אליו היא מפנה, הערך עצמו לא יעזב כאשר ההפניה יוצאת משימוש.

באופן דומה, החותם של הפונקציה משתמש ב-`&` כדי לציין שטיפוס הפרמטר הוא הפניה. הבה נוסיף כמה ביאורים להסברה:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
```

המתחם בו המשתנה `s` תקף הוא כמו המתחם של כל פרמטר אחר של הפונקציה, אבל הערך עליו ההפניה מצביעה לא נעזב כאשר `s` יוצא מהמתחם, כיוון ש- `s` אינו בעל הערך. כאשר לפונקציות יש הפניות כפרמטרים במקום את הערכים עצמם, אנחנו לא צריכים להחזיר את הערכים כדי להעביר חזרה את הבעלות, כיוון שהבעלות מעולם לא הועברה אלינו.

הפעולה של יצירת הפניה נקראת *השאלה* (borrowing). כמו בחיים האמיתיים, אם למישהו יש בעלות על חפץ, אז ניתן להשאיל אותו מהם. כמובן שאח"כ יש להחזיר את החפץ. הוא לא בבעלותך.

אם כן, מה קורה אם ננסה לשנות משהו שהשאלנו? נסו את הקוד ברשימה 4-6. ספויילר אלרט: הוא לא עובד!

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}
```

<span class="caption">רשימה 4-6: ניסיון לשנות ערך שאול</span>

הינה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
```

בדיוק כמו שברירת המחדל היא שמשתנים הם מנועי-שינוי, כך גם הפניות. ברירת המחדל היא שאם יש לנו הפניה למשהו, אז אסור לנו לשנות אותו.

### הפניות ברות-שינוי

ניתן לתקן את הקוד מרשימה 4-6 כדי שיאפשר לנו לשנות ערך מושאל, וזאת באמצעות כמה התאמות קלות, דהיינו להשתמש *בהפניות ברות-שינוי*:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
```

קודם כל, נשנה את `s` להיות `mut`. לאחר מכן, ניצור הפניה ברת-שינוי באמצעות `&mut s` כאשר אנחנו קוראים לפונקציה `change`, ונעדכן את חותם הפונקציה לקבל הפניה ברת-שינוי באמצעות `some_string: &mut String`.
כל זה מבהיר שהפונקציה `change` כן תשנה את הערך אותו היא שואלת.

להפניות ברות-שינוי יש מגבלה משמעותית אחת: אם יש לכם הפניה ברת-שינוי לערך, אז לא יכולה להיות לכם אף הפניה אחרת לאותו ערך. הקוד הבא, שמנסה לייצר שתי הפניות ברות-שינוי ל- `s`, ייכשל:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}
```

הינה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
```

שגיאה זו אומרת שהקוד אינו תקין מכיוון לא ניתן לשאול את `s` כבר-שינוי יותר מפעם אחת באותו זמן. ההשאלה ברת-השינוי הראשונה מתבצעת ב- `r1` והיא חייבת להימשך עד לשימוש בה בשורת ה- `println!`, אבל, בין יצירת הפניה ברת-שינוי זו לשימוש בה, ניסינו ליצור הפניה ברת-שינוי נוספת ב- `r2` אשר שואלת את אותו דאטה כמו `r1`.

המגבלה שמונעת ריבוי הפניות ברות-שינוי לאותה פיסת דאטה בכל זמן נתון מאפשרת ביצוע שינויים, אבל בצורה מאוד מבוקרת. עניין זה הוא משהו שראסטיונרים מתחילים רבים מתקשים איתו כיוון שרוב שפות התכנות מאפשרות לכם לבצע שינויים מתי שתרצו. היתרון שבמגבלה זו הוא שראסט יכולה למנוע מרוצי דאטה (data races) בזמן הקומפילציה. *מרוץ דאטה* מתרחש כאשר שלושת ההתנהגויות הבאות קורות:

* לפחות שני מצביעים ניגשים לאותו דאטה באותו זמן.
* לפחות באחד מהמצביעים נעשה שימוש כדי לכתוב לדאטה.
* אין שימוש במנגנון לסינכרוניזציה של הגישה לדאטה.

מרוצי דאטה מובילים להתנהגות בלתי מוגדרת ויכולים להיות קשים לאבחון ולתיקון כאשר מנסים לאתר אותם בזמן הריצה; ראסט מונעת בעיה זו ע"י סירוב לקמפל קוד הכולל מרוצי דאטה!

כתמיד, ניתן להשתמש בסוגריים מסולסלים כדי ליצור מתחם חדש, ולאפשר כמה הפניות ברות-שינוי, פשוט לא *סימולטנית*:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
```

ראסט כופה כלל דומה בדבר שילוב הפניות ברות-שינוי ושאינן ברות-שינוי. הקוד הבא שגוי:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}
```

הינה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
```

מדהים! אנחנו *גם* לא יכולים שתהיה לנו הפניה ברת-שינוי בזמן שיש לנו הפניה מנועת-שינוי לאותו ערך.

משתמשים של הפניה מנועת-שינוי לא מצפים שהערך ישתנה להם פתאום! אולם, ריבוי הפניות מנועות-שינוי כן מותר מכיוון שאף אחד מקוראי הדאטה לא יכול להשפיע על אופן הקריאה של האחרים.

שימו לב שהמתחם של הפניה מתחיל במקום בוא היא מוכרזת וממשיך עד למקום בו נעשה שימוש בהפניה בפעם האחרונה. למשל, הקוד הזה יעבור קומפילציה כי השימוש האחרון בהפניה מנועת-השינוי, דהיינו ב-`println!`, מתרחש לפני ההכרזה על ההפניה ברת-השינוי:

```rust,edition2021
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
```

המתחמים של ההפניות מנועות-השינוי `r1` ו-`r2` מסתיימים לאחר ה- `println!` שבו נעשה בהם השימוש האחרון, וזה קורה לפני שההפניה ברת-השינוי `r3` נוצרת. מתחמים אלו לא חופפים, ולכן הקוד הזה תקני: הקומפיילר יכול לדעת, בנקדות זמן לפני סוף המתחם, שההפנייה כבר לא בשימוש.

למרות ששגיאות השאלה יכולות להיות מתסכלות, זכרו שמקורן בקומפיילר של ראסט שמספק לכם התרעה מוקדמת על באג פוטנציאלי (בזמן הקומפילציה, ולא בזמן הריצה) ומראה לכם היכן הבעיה. כך לא תצטרכו לנבור במכלול הסיבות הסבוכות להסברים מדוע הדאטה שלכם אינו מה שחשבתם שהוא צריך להיות.

### הפניות משתלשלות

בשפות עם מצביעים, קל ליצור בטעות *מצביע משתלשל* -- מצביע שמפנה למקום בזיכרון שהוקצה למשהו אחר -- ע"י שחרור זיכרון תוך שמירת המצביע לאותו מקום בזיכרון. בראסט, באופן מנוגד, הקומפיילר מבטיח שהפנייות לעולם לא יהיו הפניות משתלשלות: אם יש לכם הפניה לפיסת דאטה, אז הקומפיילר יוודא שהדאטה לא יצא מהמתחם לפני שההפנייה אליו תצא מהמתחם.

הבה ננסה ליצור הפניה משתלשלת כדי לראות כיצד ראסט מונעת אותן באמצעות שגיאת זמן-קומפילציה:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}
```

הינה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
```

שגיאה זו מתייחסת לתכונה שעוד לא ראינו: פז"ם. נדון בפז"ם ביתר פירוט בפרק 10. אבל, אם תתעלמו כרגע מהחלקים הנוגעים לפז"ם, שאר הודעת השגיאה כבר מכיל את גרעין הבעיה בקוד:

```text
טיפוס הערך החוזר של הפונקציה הזאת מכיל השאלה לערך, אבל אין ערך שניתן להשאלה
```

הבה נתבונן מקרוב במה בדיוק קורה בכל שלב של הקוד `המשתלשל` שלנו:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}
```

כיוון ש- `s` נוצר בתוך `dangle`, כאשר הקוד של `dangle` מסתיים יתבצע שחרור זיכרון עבור `s`. אבל, באותו זמן, אנחנו ניסינו גם להחזיר הפניה לערך ששוחרר. משמעות הדבר היא שהפניה זו תצביע אל ערך `String` שאינו תקף. מצב שאינו מתקבל על הדעת! ראסט לא תאפשר לנו לעשות משהו כזה.

הפיתרון כאן הוא להחזיר `String` ישירות:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
```

זה עובד ללא שום בעיות. הבעלות מועברת אל מחוץ למתחם, וכך לא מתבצע שחרור זיכרון.

### כללי הפניות

הבה נסכם את הדיון אודות הפנייות עד כה:

* בכל נקודה בזמן, ניתן שתהיה *או* הפניה ברת-שינוי יחידה *או* כל מספר שהוא של הפניות מנועות-שינוי.
* הפניות חייבות תמיד להיות תקפות.

מייד נתבונן בסוג אחר של הפניות: חיתוכים.
