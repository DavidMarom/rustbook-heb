## הפניות והשאלות

הקוד שברשימה 4-5 מדגים כיצד ניתן להשתמש במרצף בכדי להחזיר`String` לפונקציה הקוראת. אם נרצה להמשיך להשתמש ב- `String` אחרי הקריאה ל- `calculate_length`, אין לנו ברירה אלא להחזיר ל-`calculate length` את הבעלות עליו. זה אמנם עובד, אבל יוצר קוד מסורבל.
כדי להימנע מכך, ניתן לספק לפונקציה `calculate length` הפניה לערך של ה- `String`. _הפניה_ היא קצת כמו מצביע בכך שהיא מפנה את הקוד לכתובת הדאטה בזיכרון; הדאטה עצמו עודו בבעלות של משתנה אחר. אך בניגוד למצביע, מובטח שהפניה מצביעה לערך מטיפוס נתון וידוע, אשר תקף לכל אורך חיי ההפניה.

כחלופה ללקיחת בעלות לערך הנדרש, כך תוכלו להגדיר ולהשתמש בפונקציה `calculate_length` באמצעות שימוש בהפניה:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:all}}
```

ראשית, שימו לב שכל הקוד המטפל במרצף ובערך המוחזר מהפונקציה כבר לא שם. שנית, אנו מעבירים `&s1` ל-`calculate_length`, ובהגדרת הפונקציה אנחנו לוקחים `&String` במקום `String`. סימני החיבור (&) מייצגים _הפניות_, והם מאפשרים לכם להתייחס לערך מבלי לקחת בעלות עליו. תמונה 4-5 מבארת רעיון הזה.

<img alt="Three tables: the table for s contains only a pointer to the table
for s1. The table for s1 contains the stack data for s1 and points to the
string data on the heap." src="img/trpl04-05.svg" class="center" />

<span class="caption">תמונה 4-5: דיאגרמה של `&String s` המצביע אל `String s1`</span>

> הערה: הפעולה ההפוכה להפניה תוך שימוש ב-`&` נקראת _דה-הפניה_, והיא מבוצעת באמצעות אופרטור הדה-הפניה, `*`. נראה מספר שימושים באופרטור דה-הפניה בפרק 8, ונדון בפרטיו בפרק 15.

הבה נתבונן מקרוב בקריאה לפונקציה כאן:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-07-reference/src/main.rs:here}}
```

המבנה התחבירי `&s1` מאפשר ליצור הפניה _שמפנה_ לערך של `s1` אבל לא לוקחת עליו בעלות. מכיוון שהיא לא בעלת הערך אליו היא מפנה, הערך עצמו לא יעזב כאשר ההפניה יוצאת מן המרחב.

באופן דומה, החותם של הפונקציה עושה שימוש ב-`&` בכדי לציין שטיפוס הפרמטר הוא הפניה. הבה נוסיף כמה ביאורים להסבר:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-08-reference-with-annotations/src/main.rs:here}}
```

המתחם בו תקף המשתנה `s` הוא כמו המתחם של כל פרמטר אחר של הפונקציה, מלבד זאת שהערך אליו ההפניה מצביעה לא נעזב כאשר `s` יוצא מהמתחם. שוב, זאת כיוון ש- `s` אינו בעל הערך. כאשר פונקציות מקבלות כפרמטרים הפניות במקום את הערכים עצמם, אנחנו לא נדרשים להחזיר את הערכים כדי להעביר חזרה את הבעלות, כיוון שהבעלות מעולם לא הועברה אלינו במלואה.

הפעולה של יצירת הפניה נקראת _השאלה_ (borrowing). כמו בחיים האמיתיים, אם למישהו יש בעלות על חפץ, ניתן לשאול אותו מהם. אחר-כך, כמובן, יש להחזיר את החפץ. הוא לא בבעלותך!

אם כן, מה קורה אם ננסה לשנות משהו שהשאלנו? נסו את הקוד ברשימה 4-6. אזהרת ספויילר: הוא לא עובד!

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-06/src/main.rs}}
```

<span class="caption">רשימה 4-6: ניסיון לשנות ערך שאול</span>

הנה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/listing-04-06/output.txt}}
```

בדיוק כמו שברירת המחדל היא שמשתנים הם מנועי-שינוי, כך גם הפניות. ברירת המחדל היא שאם יש לנו הפניה למשהו, אסור לנו לשנות אותו.

### הפניות ברות-שינוי

ניתן לתקן את הקוד מרשימה 4-6 כדי שיאפשר לנו לשנות ערך מושאל, וזאת באמצעות כמה התאמות קלות, דהיינו להשתמש _בהפניות ברות-שינוי_:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-09-fixes-listing-04-06/src/main.rs}}
```

קודם כל, נשנה את `s` להיות `mut`. לאחר מכן, ניצור הפניה ברת-שינוי באמצעות `&mut s` כאשר אנחנו קוראים לפונקציה `change`,ונעדכן את חותם הפונקציה לקבל הפניה ברת-שינוי באמצעות `some_string: &mut String`.
כל זה מבהיר שהפונקציה `change` אכן תשנה את הערך אותו היא שואלת.

להפניות ברות-שינוי יש מגבלה משמעותית אחת: אם יש לכם הפניה ברת-שינוי לערך, לא יתאפשר לכם להגדיר אף הפניה אחרת לאותו הערך. הקוד הבא מנסה ליצור שתי הפניות ברות-שינוי ל- `s`, וכצפוי נכשל:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/src/main.rs:here}}
```

הנה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt}}
```

שגיאה זו מסבירה שהקוד אינו תקין מכיוון שלא ניתן לשאול את `s` כבר-שינוי יותר מפעם אחת באותו הזמן. ההשאלה ברת-השינוי הראשונה מתבצעת ב- `r1` והיא חייבת להימשך עד לשימוש בה בשורת ה- `println!`, אבל, בין יצירת הפניה ברת-שינוי זו לשימוש בה, ניסינו ליצור הפניה ברת-שינוי נוספת ב- `r2` אשר שואלת את אותו דאטה כמו `r1`.

המגבלה שמונעת ריבוי הפניות ברות-שינוי לאותה פיסת דאטה בכל זמן נתון מאפשרת ביצוע שינויים, אבל בצורה מאוד מבוקרת. זהו משהו שראסטיונרים מתחילים רבים מתקשים איתו, כיוון שרוב שפות התכנות מאפשרות לכם לבצע שינויים בדאטה מתי שתרצו. היתרון שבמגבלה זו הוא שראסט יכולה למנוע מרוצי דאטה (data races) כבר בזמן הקומפילציה. _מרוץ דאטה_ מתרחש כאשר שלושת ההתנהגויות הבאות קורות:

- לפחות שני מצביעים ניגשים לאותו דאטה באותו זמן.
- לפחות באחד מהמצביעים נעשה שימוש כדי לכתוב לדאטה.
- אין שימוש במנגנון לסינכרוניזציה של הגישה לדאטה.

מרוצי דאטה מובילים להתנהגות בלתי-מוגדרת העלולה להיות קשה לאבחון ותיקון בזמן ריצה; ראסט מונעת מראש בעיה זו על-ידי סירוב לקמפל קוד הכולל מרוצי דאטה!

כתמיד, ניתן להשתמש בסוגריים מסולסלים כדי ליצור מתחם חדש, ולאפשר כמה הפניות ברות-שינוי, פשוט לא _בה-בעת_:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-11-muts-in-separate-scopes/src/main.rs:here}}
```

ראסט כופה כלל דומה בדבר שילוב הפניות ברות-שינוי ושאינן ברות-שינוי. הקוד הבא שגוי:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/src/main.rs:here}}
```

הנה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt}}
```

מדהים! אנחנו _גם_ לא יכולים להגדיר הפניה ברת-שינוי כל עוד יש לנו הפניה מנועת-שינוי לאותו הערך.

משתמשים של הפניה מנועת-שינוי לא מצפים שהערך ישתנה להם פתאום! אולם, ריבוי הפניות מנועות-שינוי כן מותר מכיוון שאף-אחד מקוראי הדאטה לא יכול להשפיע על אופן הקריאה של האחרים.

שימו לב שהמתחם של הפניה מתחיל במקום בו היא מוכרזת וממשיך עד למקום בו נעשה שימוש בהפניה בפעם האחרונה. למשל, הקוד הזה יעבור קומפילציה כי השימוש האחרון בהפניה מנועת-השינוי, דהיינו ב-`println!`, מתרחש לפני ההכרזה על ההפניה ברת-השינוי:

```rust,edition2021
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-13-reference-scope-ends/src/main.rs:here}}
```

המתחמים של ההפניות מנועות-השינוי `r1` ו-`r2` מסתיימים לאחר ה- `println!` שבו נעשה בהם השימוש האחרון, וזה קורה לפני שההפניה ברת-השינוי `r3` נוצרת. מתחמים אלו לא חופפים, ולכן הקוד הזה תקני: הקומפיילר יכול לדעת, בנקדות זמן לפני סוף המתחם, שההפנייה כבר לא בשימוש.

למרות ששגיאות השאלה יכולות להיות מתסכלות, זכרו שמקורן בקומפיילר של ראסט שמספק לכם התרעה מוקדמת על באג פוטנציאלי כבר בזמן הקומפילציה, ומראה לכם היכן הבעיה. כך לא תצטרכו לנבור לאחר-מעשה במכלול הסיבות הסבוכות להסברים מדוע הדאטה שלכם אינו מה שהוא צריך להיות.

### הפניות משתלשלות

בשפות עם מצביעים, קל ליצור בטעות _מצביע משתלשל_ -- מצביע שמפנה למקום בזיכרון שהוקצה כבר למשהו אחר – על-ידי שחרור הזיכרון עצמו, אך שמירת המצביע לו. עם זאת, בראסט, הקומפיילר מבטיח שהפניות לעולם לא יהיו משתלשלות: אם יש לכם הפניה לפיסת דאטה, הקומפיילר יוודא שהדאטה לא יצא מהמתחם בטרם ההפנייה אליו תצא מהמתחם.

הבה ננסה ליצור הפניה משתלשלת כדי לראות כיצד ראסט מונעת אותן באמצעות שגיאת זמן-קומפילציה:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/src/main.rs}}
```

הנה השגיאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt}}
```

שגיאה זו מתייחסת לתכונה שעוד לא ראינו: משך חיים. נדון במשכי חיים ביתר פירוט בפרק 10. אבל, אם תתעלמו כרגע מהחלקים הנוגעים לכך, הודעת השגיאה מציגה את לב הבעיה:

```text
טיפוס הערך החוזר של הפונקציה הזאת מכיל השאלה לערך, אבל אין ערך שניתן להשאילו.
```

הבה נתבונן מקרוב במה בדיוק קורה בכל שלב של הקוד `המשתלשל` שלנו:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-15-dangling-reference-annotated/src/main.rs:here}}
```

כיוון ש- `s` נוצר בתוך `dangle`, כאשר הקוד של `dangle` מסתיים יתבצע שחרור זיכרון עבור `s`. אבל, באותו זמן, ניסינו גם להחזיר הפניה לערך ששוחרר. משמעות הדבר היא שהפניה זו תצביע אל ערך `String` שאינו תקף. מצב זה אינו מתקבל על הדעת! ראסט לא תאפשר לנו לעשות משהו כזה.

הפיתרון כאן הוא להחזיר `String` ישירות:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-16-no-dangle/src/main.rs:here}}
```

זה עובד ללא שום בעיות. הבעלות מועברת אל מחוץ למתחם, ואף שחרור זיכרון לא מתבצע.

### כללי הפניות

הבה נסכם את הדיון אודות הפניות עד כה:

- בכל נקודה בזמן, ניתן שתתקיים _או_ הפניה ברת-שינוי יחידה, _או_ כל מספר שהוא של הפניות מנועות-שינוי.
- הפניות חייבות תמיד להיות תקפות.

מייד נתבונן בסוג אחר של הפניות: חיתוכים.
