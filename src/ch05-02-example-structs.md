תכנית לדוגמה המשתמשת במבנים

על מנת להבין מתי אנו עשויים לרצות להשתמש במבנים, הבה נכתוב תכנית שמחשבת את שטחו של מלבן נתון. נתחיל עם משתנה יחיד, ואז נשפר את מבנה התכנית עד שנגיע לשימוש במבנים.

בואו ניצור פרוייקט בינארי חדש עם קארגו בשם _rectangles_, שיקבל רוחב וגובה של מלבן במונחים של פיקסלים, ויחשב את שטחו. רשימה 5-8 מציגה תכנית קצרה שעושה בדיוק את זה, וממוקמת ב- _src/main.rs_.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:all}}
```

<span class="caption">רשימה 5-8: חישוב השטח של מלבן המיוצג לפי אורכו וגובהו כמשתנים</span>

עכשיו, הריצו תכנית זו על-ידי `cargo run`:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/output.txt}}
```

קוד זה מחשב את השטח של המלבן על-ידי קריאה לפונקציה `area` עם שני המימדים שהועברו לו, אבל אנחנו יכולים לשפר את קריאות ובהירות הקוד.

הבעיה עם הקוד ברורה מהתבוננות בחותם של `area`:

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:here}}
```

הפונקציה `area` אמורה לחשב את שטחו של מלבן אחד, אבל לפונקציה שכתבנו יש שני פרמטרים, ואין זה ברור כלל שהם קשורים זה לזה. יהיה יותר קריא ויותר קל לתחזוק אם נאגד את הרוחב והגובה יחדיו. כבר דיברנו על דרך אחת לבצע זאת בסעיף ["טיפוס המרצף"][the-tuple-type]<!-- ignore --> בפרק 3: שימוש במרצפים.

### ארגון מחדש של הקוד עם מרצפים

רשימה 5-9 מציגה גרסה נוספת של התכנית שלנו שעושה שימוש במרצפים.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-09/src/main.rs}}
```

<span class="caption">רשימה 5-9: יצוג באמצעות מרצף של הרוחב והגובה של המלבן</span>

במובן מסוים, זו תכנית טובה יותר. מרצפים מאפשרים לנו להוסיף קצת יותר סדר וארגון, וכעת אנחנו מעבירים רק ארגומנט אחד. אבל מצד שני, גרסה זו פחות ברורה: לרכיבים במרצף אין שמות, ולכן יש להשתמש באינדקס בכדי לגשת אליהם, מה שהופך את החישובים שלנו לפחות מובנים.

החלפת הסדר בין הרוחב והגובה אינה חשובה למטרת חישוב השטח, אבל אם נרצה לצייר את המלבן על המסך, סדר הפרמטרים חשוב מאוד! נאלץ לזכור ש-`width` נמצא במרצף באינדקס `0` וש-`height` נמצא באינדקס `1` של המרצף. דבר זה יקשה על כל מי שיפגוש את הקוד שלנו; חוסר הבהירות לגבי משמעות הדאטה בקוד שלנו מגביר את הסכנה לשגיאות.

### ארגון מחדש של הקוד עם מבנים: חידוד משמעות

ניתן להשתמש במבנים כדי להוסיף משמעות על-ידי תיוג הדאטה שהם מאחסנים. אנחנו יכולים להפוך את המרצף בו אנו משתמשים למבנה, כך שלמבנה כולו יש שם וגם למרכיבי המבנה יש שמות, כפי שמוצג ברשימה 5-10.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-10/src/main.rs}}
```

<span class="caption">רשימה 5-10: הגדרת המבנה `Rectangle`</span>

כאן הגדרנו מבנה וקראנו לו `Rectangle`. בתוך סוגריים מסולסלים, הגדרנו את השדות `width` ו- `height`, שניהם מטיפוס `u32`. ואז, ב- `main`, יצרנו מופע ספציפי של `Rectangle` עם רוחב `30` וגובה `50`.

הפונקציה `area` מוגדרת כעת עם פרמטר אחד, לו קראנו `rectangle`, מטיפוס השאלה מנועת-שינוי של מופע של `Rectangle`. כפי שהוזכר בפרק 4, אנחנו רוצים לשאול את המבנה ולא לקחת עליו בעלות. בדרך זו, הפונקציה `main` שומרת על הבעלות, ובאפשרותה להמשיך להשתמש ב- `rect1`,. זו הסיבה לשימוש ב- `&` בחותם הפונקציה ובקריאה לה.

הפונקציה `area` ניגשת לשדות `width` ו-`height` של מופע ה- `Rectangle` (שימו לב שגישה לשדותיו של מופע מושאל של מבנה לא מזיזה את הערכים. לכן מרבים להשתמש בהשאלות למבנים). חותם הפונקציה של `area` משקף כעת בבירור את כוונת הכותב: חישוב השטח של `Rectangle` תוך שימוש בשדות `width` ו-`height`. זה מעביר את המסר שהרוחב והגובה קשורים זה לזה, ומספק שמות תיאוריים לערכים במקום השימוש באינדקסים `0` ו-`1` עבור המרצף. זהו שיפור ניכר בבהירות.

### הוספת פונקציונאליות מועילה באמצעות תכונות נגזרות

יהיה זה מועיל אם, בזמן שאנו מנפים באגים מן התכנית שלנו, נוכל להדפיס מופע של `Rectangle` כדי לראות את הערכים של השדות. רשימה 5-11 מנסה להשתמש במאקרו [println!][println]<!-- ignore --> כפי שעשינו בפרקים קודמים. אבל, זה לא יעבוד.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/src/main.rs}}
```

<span class="caption">רשימה 5-11: ניסיון להדפיס מופע של `Rectangle`</span>

כשננסה לקמפל את הקוד, נקבל את הודעת השגיאה:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:3}}
```

המאקרו `println!` יכול לבצע כמה סוגים של פירמוט, וברירת המחדל היא שהסוגריים המסלוסלים אומרים ל- `println!` להשתמש בפורמט שנקרא `Display`: פלט שמיועד לקריאה נוחה ולא-טכנית. הטיפוסים הפרימיטיביים בהם השתמשנו עד כה מיישמים את `Display` כברירת מחדל, מכיוון שיש רק דרך אחת להציג את `1`, או כל ערך פרימיטיבי אחר, למשתמש. לעומת זאת, עם מבנים, הדרך בה `println!` צריך לפרמט את הפלט אינה מובנת מאליה. הרי, ישנן כמה אופשרויות לתצוגה: עם או בלי פסיקים? האם להדפיס את הסוגריים המסולסלים? האם להציג את כל השדות? בשל חוסר בהירות זו, ראסט לא מנסה לנחש מה היינו רוצים. משום כך, למבנים אין יישום אוטומטי של `Display` לשימוש עם `println!` והביאור `{}`.

אם נקרא את המשך הודעת השגיאה, נמצא את ההערה המועילה:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:9:10}}
```

הבה ננסה זאת! הקריאה למאקרו `println!` תראה כעת כך: `println!("rect1 is
{:?}", rect1);`. המיקום של המציין `:?` בתוך סוגריים מסולסלים אומר ל-`println!` שאנחנו רוצים להשתמש בפורמט פלט שנקרא `Debug`. התכונה `Debug` מאפשרת לנו להדפיס את המבנה שלנו בצורה מועילה עבור המפתחים כותבי הקוד, כך שניתן יהיה לראות את הערכים בזמן דיבאג, קרי בזמן ניפוי שגיאות.

קמפלו את הקוד כעת, עם השינוי לעיל. אשמדאי! אנחנו בכל זאת מקבלים שגיאה:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:3}}
```

אבל שוב, הקומפיילר עוזר לנו:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:9:10}}
```

ראסט _כן_ כוללת פונקציונאליות להדפסת מידע לניפוי שגיאות, אבל בכדי להשתמש בתכונה זו עבור מבנים, יש לציין זאת מפורשות, על-ידי הוספת האפיון `#[derive(Debug)]` ממש לפני הגדרת המבנה, כפי שמציגה רשימה 5-12.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/src/main.rs}}
```

<span class="caption">רשימה 5-12: הוספת האפיון לגזירת התכונה `Debug` והדפסת המופע של `Rectangle` באמצעות פורמט ניפוי שגיאות</span>

כשנריץ את התכנית עכשיו, לא נקבל שגיאות, ונראה את הפלט הבא:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/output.txt}}
```

יפה! זה לא הפלט היפה ביותר, אבל הוא מציג את הערכים של כל השדות עבור מופע זה, וזה בוודאי יעזור במהלך ניפוי שגיאות. כאשר עובדים עם מבנים גדולים יותר, יהיה זה מועיל אם הפלט יהיה קל יותר לקריאה; במקרים כאלה ניתן להשתמש ב- `{:#?}` במקום ב- `{:?}` במחרוזת של ה-`println!`. בדוגמא זו, שימוש ב-`{:#?}` יפיק פלט מהצורה הבאה:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-02-pretty-debug/output.txt}}
```

דרך אחרת להדפיס ערך בפורמט `Debug` הוא להשתמש במאקרו `dbg!`<!-- ignore -->, שלוקח בעלות על הביטוי (בניגוד ל-`println!`, שלוקח הפנייה), מדפיס את הקובץ ומספר השורה בקוד שלכם בה התבצעה הקריאה ל- `dbg!`, יחד עם הערך אליו הביטוי מוערך, ומחזיר בעלות על הערך.

> הערה: קריאה למאקרו `dbg!` מדפיסה אל פלט השגיאות (`stderr`), בניגוד ל-`println!`, שמדפיסה אל הפלט התקני (`stdout`). נרחיב את הדיון על `stderr` ועל `stdout` בסעיף [כתיבת הודעות שגיאה לפלט השגיאות במקום לפלט התקני"][err] בפרק 12<!-- ignore -->.

הנה דוגמה. כאן אנו מעוניינים גם בערך שמושם לשדה `width`, וגם לערך של המבנה כולו ב-`rect1`:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/src/main.rs}}
```

אנחנו יכולים להוסיף `dbg!` מסביב לביטוי `30 * scale` ואז, משום ש-`dbg!` מחזיר בעלות על תוצאת הערכת הביטוי, השדה `width` יקבל את אותו הערך כאילו לא קראנו כאן ל-`dbg!`. ומצד שני, אנחנו לא מעוניינים ש-`dbg!` יקח בעלות על `rect1`, ולכן אנחנו משתמשים בהפנייה ל- `rect1` בקריאה הבאה. הפלט של התכנית נראה כך:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/output.txt}}
```

ניתן לראות שהחלק הראשון של הפלט מגיע משורה 10 בקובץ _src/main.rs_, שם אנו מדפיסים, בפורמט ניפוי שגיאות, את הביטוי `30 * scale`, ותוצאת ההערכה שלו היא `60` (יישום פירמוט ניפוי השגיאות עבור שלמים מדפיס רק את ערכם). הקריאה ל-`dbg!` בשורה 14 בקובץ _src/main.rs_ מדפיסה את הערך של `&rect1`, שהוא המבנה `Rectangle`. פלט זה משתמש בפירמוט היפה לניפוי השגיאות של הטיפוס `Rectangle`. המאקרו `dbg!` יכול להיות מאוד שימושי כאשר אתם מנסים להבין מה הקוד שלכם עושה!

בנוסף לתכונה `Debug`, ראסט מספקת לנו מספר תכונות לשימוש עם האפיון `derive` שיכולות להוסיף התנהגות לטיפוסים שאנו מגדירים. תכונות אלה, וההתנהגויות שלהן, מופיעות [בנספח ג'][app-c]<!--
ignore -->. אנחנו נראה כיצד ליישם תכונות אלה באמצעות התנהגות מתאימה, וגם נלמד כיצד ליצור תכונות משלנו, בפרק 10.

יש גם מאפיינים רבים אחרים חוץ מ-`derive`; למידע נוסף, פנו [לסעיף "מאפיינים" של התיעוד של ראסט][attributes].

הפונקציה `area` היא מאוד ספציפית: היא מחשבת אך ורק שטחים של מלבנים. יהיה זה מועיל לקשור את ההתנהגות הזו בצורה יותר ברורה למבנה `Rectangle` עצמו, כיוון שהיא לא מתאימה למבנים אקראים אחרים. הבה נראה כיצד נוכל להמשיך לארגן מחדש את הקוד שלנו על-ידי הפיכת הפונקציה `area` למתודה המוגדרת עבור הטיפוס `Rectangle`.

[the-tuple-type]: ch03-02-data-types.html#the-tuple-type
[app-c]: appendix-03-derivable-traits.md
[println]: ../std/macro.println.html
[err]: ch12-06-writing-to-stderr-instead-of-stdout.html
[attributes]: ../reference/attributes.html
