## תכנית לדוגמא המשתמשת במבנים

על מנת להבין מתי אנו עשויים לרצות להשתמש במבנים, הבה נכתוב תכנית שמחשבת את השטח של מלבן. נתחיל ע"י שימוש במשתנה יחיד, ואז נשפר את מבנה התכנית עד שנגיע לשימוש במבנים.

בואו ניצור פרוייקט בינארי חדש עם קארגו בשם *rectangles*, שיקבל רוחב וגובה של מלבן, במונחים של פיקסלים, ויחשב את שטח המלבן. רשימה 5-8 מראה תכנית קצרה שעושה בדיוק את זה, וממוקמת ב- *src/main.rs*.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:all}}
```


<span class="caption">רשימה 5-8: חישוב השטח של מלבן המיוצג לפי אורכו וגובהו כמשתנים</span>

עכשיו, הריצו תכנית זו ע"י `cargo run`:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/output.txt}}
```

קוד זה מצליח לחשב את השטח של המלבן ע"י קריאה לפונקציה `area` עם שני המימדים, אבל אנחנו יכולים לשפר את קריאות ובהירות הקוד.

הבעיה עם הקוד נהירה מהתבוננות בחותם של `area`:

```rust,ignore
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-08/src/main.rs:here}}
```

הפונקציה `area` אמורה לחשב את השטח של מלבן אחד, אבל לפונקציה שכתבנו יש שני פרמטרים, ואין זה ברור כלל שהם קשורים זה לזה. יהיה יותר קריא ויותר קל לתחזוק אם נאגד את הרוחב והגובה יחדיו. כבר דיברנו על דרך אחת לבצע זאת בסעיף ["טיפוס הרצף"][the-tuple-type]<!-- ignore --> בפרק 3: שימוש ברצפים.

### ארגון מחדש של הקוד עם רצפים

רשימה 5-9 מראה גרסה נוספת של התכנית שלנו שעושה שימוש ברצפים.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-09/src/main.rs}}
```


<span class="caption">רשימה 5-9: ייצוג באמצעות רצף של הרוחב והגובה של המלבן</span>

מצד אחד, תכנית זו טובה יותר. רצפים מאפשרים לנו להוסיף קצת יותר סדר וארגון, וכעת אנחנו מעבירים רק ארגומנט אחד. אבל מצד שני, גרסה זו פחות ברורה: לרכיבים ברצף אין שמות, ולכן יש להישתמש באינדקס כדי לגשת אליהם, וכך החישובים שלנו פחות מובנים.

החלפת הסדר בין הרוחב והגובה לא ישנה לחישוב השטח, אבל אם נרצה לצייר את המלבן על המסך, אז הסדר מאוד ישנה! נאלץ לזכור ש-`width` נמצא ברצף באינדקס `0` וש-`height` נמצא באינדקס `1` של הרצף. צורך זה יקשה על כל מי שיפגוש את הקוד שלנו. חוסר הבהירות לגבי משמעות הדאטה בקוד שלנו מגביר את הסכנה ליצירת שגיאות.

### ארגון מחדש של הקוד עם מבנים: הגברת משמעות

ניתן להשתמש במבנים כדי להוסיף משמעות ע"י תיוג הדאטה. אנחנו יכולים להפוך את הרצף בו אנו משתמשים למבנה כך שלמבנה כולו יש שם וגם למרכיבי המבנה יש שמות, כפי שמוצג ברשימה 5-10.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-10/src/main.rs}}
```

<span class="caption">רשימה 5-10: הגדרת המבנה `Rectangle`</span>

כאן הגדרנו מבנה וקראנו לו `Rectangle`. בתוך סוגריים מסולסלים, הגדרנו את השדות `width` ו- `height`, שניהם מטיפוס `u32`. ואז, ב- `main`, יצרנו מופע ספציפי של `Rectangle` עם רוחב `30` וגובה `50`.

הפונקציה `area` מוגדרת כעת עם פרמטר אחד, לו קראנו `rectangle`, מטיפוס השאלה מנועת-שינוי של מופע של `Rectangle`. כפי שהוזכר בפרק 4, אנחנו רוצים לשאול את המבנה ולא לקחת עליו בעלות. בדרך זו, הפונקציה `main` שומרת את הבעלות ואפשר להמשיך להשתמש ב- `rect1`, וזו הסיבה לשימוש ב- `&` בחותם הפונקציה ובקריאה לה.

הפונקציה `area` ניגשת לשדות `width` ו-`height` של מופע ה- `Rectangle` (שימו לב שגישה לשדות של השאלה למופע של מבנה לא מזיזה את הערכים, ולכן מרבים להשתמש בהשאלות למבנים). חותם הפונקציה של `area` משקף כעת כוונה בצורה ברורה: חישוב השטח של `Rectangle` תוך שימוש בשדות `width` ו-`height`. זה מעביר את המסר שהרוחב והגובה קשורים זה לזה, וזה מספק שמות תיאוריים לערכים במקום השימוש באינדקסים `0` ו-`1` עבור הרצף. השיפור בבהירות ניכר.

### הוספת פונקציונאליות מועילה באמצעות תכונות נגזרות

זה יהיה מועיל אם, בזמן שאנו מנפים באגים בתכנית שלנו, נוכל להדפיס מופע של `Rectangle` כדי לראות את הערכים של השדות. רשימה 5-11 מנסה להשתמש במאקרו [println!][println]<!-- ignore --> כפי שעשינו בפרקים קודמים. אבל, זה לא יעבוד.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/src/main.rs}}
```


<span class="caption">רשימה 5-11: ניסיון להדפיס מופע של `Rectangle`</span>

כשננסה לקמפל את הקוד, נקבל את הודעת השגיאה:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:3}}
```

המאקרו `println!` יכול לבצע כמה סוגים של פרמוט, וברירת המחדל היא שהסוגריים המסלוסלים אומרים ל- `println!` להשתמש בפורמט שנקרא `Display`: פלט שמיועד לקריאה נוחה ולא טכנית. הטיפוסים היסודיים בהם השתמשנו עד כה מיישמים את `Display` כברירת מחדל מכיוון שיש רק דרך אחת להציג את `1`, או כל ערך יסודי אחר, למשתמש. עם מבנים, לאומת זאת, הדרך בה `println!` צריך לפרמט את הפלט אינה מובנת מאליה בגלל שיש כמה אופציות לתצוגה: אם או בלי פסיקים? האם להדפיס את הסוגריים המסולסלים? האם להציג את כל השדות? בשל חוסר בהירות זו, ראסט לא מנסה לנחש את רצוננו. כפועל יוצא, למבנים אין יישום אוטומטי של `Display` לשימוש עם `println!` והנוטציה `{}`.

אם נמשיך לקרוא את הודעת השגיאה, נמצא את ההערה המועילה:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt:9:10}}
```

הבה ננסה זאת! הקריאה למאקרו `println!` תראה כעת כך: `println!("rect1 is
{:?}", rect1);`. המיקום של המציין `:?` בתוך סוגריים מסולסלים אומר ל-`println!` שאנחנו רוצים להשתמש בפורמט פלט שנקרא `Debug`. התכונה `Debug` מאפשרת לנו להדפיס את המבנה שלנו בצורה מועילה למפתחים, דהיינו כך שניתן לראות את הערכים בזמן ניפוי שגיאות.

קמפלו את הקוד כעת, עם השינוי לעיל. אשמדאי! אנחנו בכל זאת מקבלים שגיאה:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:3}}
```

אבל שוב, הקומפיילר עוזר לנו:

```text
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt:9:10}}
```

ראסט *כן* כוללת פונקציונאליות להדפסת מידע לניפוי שגיאות, אבל צריך לאפשר זאת מפורשות כדי לנוכל להשתמש בתכונה זו עבור מבנים. על מנת לעשות זאת, נוסיף את האפיון `#[derive(Debug)]` בדיוק לפני הגדרת המבנה, כפי שרואים ברשימה 5-12.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/src/main.rs}}
```


<span class="caption">רשימה 5-12: הוספת האפיון לגזירת התכונה `Debug` והדפסת המופע של `Rectangle` באמצעות פורמט ניפוי שגיאות</span>

עכשיו כשנריץ את התכנית לא נקבל שגיאות, ונראה את הפלט הבא:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/output.txt}}
```

יפה! זה לא הפלט היפה ביותר, אבל הוא מציג את הערכים של כל השדות עבור מופע זה, וזה בוודאי יעזור במהלך ניפוי שגיאות. כאשר מתעסקים עם מבנים גדולים יותר, זה מועיל אם הפלט יהיה קל יותר לקריאה; במקרים כאלה ניתן להשתמש ב- `{:#?}` במקום ב- `{:?}` במחרוזת של ה-`println!`. בדוגמא זו, שימוש ב-`{:#?}` יפיק פלט מהצורה הבאה:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/output-only-02-pretty-debug/output.txt}}
```

דרך אחרת להדפיס ערך בפורמט `Debug` הוא להשתמש במאקרו `dbg!`<!-- ignore -->, שלוקח בעלות על הביטוי (בניגוד ל-`println!`, שלוקח הפנייה), מדפיס את הקובץ ומספר השורה בקוד שלכם בה התבצעה הקריאה ל- `dbg!`, יחד עם הערך אליו הביטוי מוערך, ומחזיר בעלות על הערך.

> הערה: קריאה למאקרו `dbg!` מדפיסה אל פלט השגיאות (`stderr`), בניגוד ל-`println!`, שמדפיסה אל הפלט התקני (`stdout`). נרחיב את הדיון על  `stderr` ועל  `stdout` בסעיף [כתיבת הודעות שגיאה לפלט השגיאות במקום לפלט התקני"][err] בפרק 12<!-- ignore -->.

הינה דוגמא בה אנו מעוניינים בערך שמושם לשדה `width`, וגם לערך של המבנה כולו ב-`rect1`:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/src/main.rs}}
```

אנחנו יכולים להוסיף `dbg!` מסביב לביטוי `30 * scale` ואז, משום ש-`dbg!` מחזיר בעלות על תוצאת הערכת הביטוי, השדה `width` יקבל את אותו הערך כאילו שלא קראנו כאן ל-`dbg!`. אנחנו לא רוצים ש-`dbg!` יקח בעלות על `rect1`, ולכן אנחנו משתמשים בהפנייה ל- `rect1` בקריאה הבאה. הפלט של התכנית נראה כך:

```console
{{#include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/output.txt}}
```

ניתן לראות שהחלק הראשון של הפלט מגיע משורה 10 בקובץ *src/main.rs*, שם אנו מדפיסים, בפורמט ניפוי שגיאות, את הביטוי `30 * scale`, ותוצאת ההערכה שלו היא `60` (יישום פירמוט ניפוי השגיאות עבור שלמים מדפיס רק את ערכם). הקריאה ל-`dbg!` בשורה 14 בקובץ *src/main.rs* מדפיסה את הערך של `&rect1`, שהוא המבנה `Rectangle`. פלט זה משתמש בפירמוט היפה לניפוי השגיאות של הטיפוס `Rectangle`. המאקרו `dbg!` יכול להיות מאוד שימושי כאשר אתם מנסים להבין מה הקוד שלכם עושה!

בנוסף לתכונה `Debug`, ראסט מספקת לנו מספר תכונות לשימוש עם האפיון `derive` שיכולות להוסיף התנהגות לטיפוסים שאנו מגדירים. תכונות אלה, וההתנהגויות שלהן, מופיעות [בנספח ג'][app-c]<!--
ignore -->. אנחנו נראה כיצד ליישם תכונות אלה באמצעות התנהגות מתאימה, וגם נלמד כיצד ליצור תכונות משלנו, בפרק 10.

 יש גם מאפיינים רבים אחרים חוץ מ-`derive`; למידע נוסף, פנו [לסעיף "מאפיינים" של התיעוד של ראסט][attributes].

הפונקציה `area` היא מאוד ספציפית: היא מחשבת אך ורק שטחים של מלבנים. זה יהיה מועיל לקשור את ההתנהגות הזו בצורה יותר ברורה למבנה `Rectangle` עצמו, כיוון שהיא לא מתאימה למבנים אקראים אחרים. הבה נראה כיצד נוכל להמשיך לארגן מחדש את הקוד שלנו ע"י הפיכת הפונקציה `area` למתודה המוגדרת עבור הטיפוס `Rectangle`.

[the-tuple-type]: ch03-02-data-types.html#the-tuple-type
[app-c]: appendix-03-derivable-traits.md
[println]: ../std/macro.println.html
[err]: ch12-06-writing-to-stderr-instead-of-stdout.html
[attributes]: ../reference/attributes.html
