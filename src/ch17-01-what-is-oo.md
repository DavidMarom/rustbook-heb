## מאפיינים של שפות מונחות-עצמים

אין בנמצא הסכמה רחבה בקרב קהילת המתכנתים בדבר אלו תכונות חייבות להימצא על מנת להכריז על שפה כשפה מונחת-עצמים. ראסט מושפעת מפרדיגמות תכנות רבות, כולל OOP; למשל, כבר בחנו כמה תכונות שמגיעות מעולם התכנות הפונקציונאלי בפרק 13. ניתן לטעון ששפות מונחות-עצמים משתפות כמה מאפיינים נפוצים, קריא עצמים, אפסון, וירושה (inheritance). הבה נביט במשמעות של כל אחד ממאפיינים אלה, ונתהה על רמת התמיכה בהם בראסט.

### עצמים מכילים דאטה והתנהגות

הספר *Design Patterns: Elements of Reusable Object-Oriented Software* שנכתב על-ידי אריך גאמה, ריצ'ארד הלם, ראלף ג'ונסון, וג'ון ווליסדס (הוצאת Addison-Wesley Proffesional, 1994) אליו מתייחסים בעממיות כספר *חבורת הארבעה*, הינו קטלוג של דפוסי תכנון מונחה-עצמים. הוא מגדיר OOP כך:

> תכניות מונחות-עצמים מורכבות מעצמים. *עצם* מאגד דאטה יחד עם הפרוצדורות שפועלות על הדאטה הזה. לפרוצדורות קוראים, בדרך כלל, *מתודות* או *פעולות*.

בהתאם להגדרה זו, ראסט היא שפה מונחת-עצמים: למבנים ומבחרים יש דאטה, ובלוקי `impl` מספקים מתודות עבור המבנים והמבחרים. אפילו שמבנים ומבחרים ביחד עם מתודות עליהם לא *נקראים* עצמים, הם מספקים את אותה הפונקציונאליות, לפי ההגדרה של עצמים של חבורת הארבעה.

### אפסון שמחביא פרטי יישום

אספקט נוסף שמשוייך לרוב עם OOP הוא הרעיון של *אפסון*, שמשמעו שפרטי יישומים של עצם אינם נגישים עבור קוד שמשתמש בעצם זה. לכן, הדרך היחידה לבוא במגע עם עצם היא דרך ה-API הפומבי שלו; אסור לקוד שמשתמש בעצם לנבור לעמקי העצם ולשנות ישירות דאטה או התנהגות. כך מתאפשר למתכנת לשנות ולשפר את מנגנוני הפעולה הפנימיים של העצם ללא צורך לשנות קוד שעושה שימוש בעצם.

אודות שליטה באפסון דנו בפרק 7: ניתן להשתמש במילת המפתח `pub` על מנת להחליט אלו מודולים, טיפוסים, פונקציות, ומתודות בקוד שלנו יהיו פומביות, כאשר כל דבר אחר, כברירת מחדל, הוא פרטי. למשל, ניתן להגדיר את המבנה `AveragedCollection` שלו שדה המכיל ווקטור של ערכי `i32`. המבנה יכול גם לכלול שדה שמכיל את הממוצע של הערכים בווקטור, כך שלא יהיה צורך לחשב את הממוצע בכל פעם שמישהו צריך אותו. במילים אחרות, `AveragedCollection` יטמין (cache) עבורנו את הממוצע המחושב. רשימה 17-1 מראה את ההגדרה של המבנה `AveragedCollection`:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-01/src/lib.rs}}
```


<span class="caption">רשימה 17-1: מבנה `AveragedCollection` אשר מנהל גם רשימת שלמים וגם את הממוצע שלהם</span>

המבנה מסומן כ-`pub` בכדי שקוד אחר יוכל להשתמש בו, אבל השדות בתוך המבנה נשארים פרטיים. נקודה זו חשובה במקרה זה שכן אנו רוצים להבטיח שבכל פעם שמוסיפים או מסירים ערך מהרשימה, הממוצע מתעדכן. אנו משיגים זאת באמצעות היישומים של המתודות `add`, `remove`, ו-`average` על המבנה, כמוצג ברשימה 17-2:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}
```


<span class="caption">רשימה 17-2: יישומים של המתודות פומביות `add`, `remove`, ו-`average` על המבנה `AveragedCollection`</span>

המתודות הפומביות `add`, `remove`, ו-`average` מהוות את הדרך היחידה לגשת אל הדאטה במופע של `AveragedCollection`, או לשנות אותו. כאשר מוסיפים ערך לשדה `list` באמצעות המתודה `add`, או כאשר מסירים ערך באמצעות המתודה `remove`, היישום של כל אחת מהן קורא למתודה הפרטית `update_average` אשר מנהלת גם את העדכון של השדה `average`.

אנו משאירים את השדות `list` ו-`average` פרטיים כדי שלא תהיה דרך לקוד חיצוני להוסיף את להסירערכים מהשדה `list` באופן ישיר; שאם לא כן, השדה `average` עלול לצאת מסנכרון כאשר `list` עובר שינויים. המתודה `average` מחזירה את הערך שמאוכסן בשדה `average`, ומאפשרת לקוד חיצוני לקרוא את `average` אבל לא לשנות אותו.

כיוון שאפסנו את פרטי היישום של המבנה `AveragedCollection`, אנו יכולים בקלות לבצע שינויים מסויימים, כמו שינויים בדרך ייצוג הנתונים, בעתיד. למשל, נוכל להשתמש ב- `HashSet<i32>` במקום ב-`Vec<i32>` עבור השדה `list`. כל עוד החותמים של `add`, `remove`, ו- `average` מצהירים עליהן כמתודות פומביות, לא יהיה צורך לשנות קוד שעושה שימוש במבנה `AveragedCollection`. במידה והיינו הופכים את `list` לפומבי, המצב היה יכול להיות עדין יותר: ל-`HashSet<i32>` ול- `Vec<i32>` יש מתודות שונות להוספת והסרת ערכים, ולכן סביר שיהיה צורך להתאים קוד חיצוני המשתמש במבנה, במידה והוא היה מתייחס לשדה `list` ישירות.

אם אפסון היא דרישה הכרחית על מנת להכריז על שפה במונחת-עצמים, אז ראסט עונה לדרישה זו. האפשרות אם כן או לא להשתמש ב-`pub` עבור חלקים שונים בקוד מאפשרת אפסון פרטי יישום.

### ירושה כמערכת טיפוסים וכשיתופיות קוד

*ירושה* היא מנגנון שמאפשר לעצם לרשת אלמנטים מההגדרה של עצם אחר, ובכל לרכוש דאטה והתנהגות מאובייקט האב ללא צורך בשחזור הגדרות.

אם שפה חייבת לתמוך בירושה כדי להיקרא שפה מונחת-עצמים, אז ראסט אינה כזו. אין דרך להגדיר מבנה שיורש שדות או מתודות ממבנה אחר ללא שימוש במאקרו.

אבל, אם מנגנון הירושה הוא כלי חשוב לכם באגז כלי הפיתוח שלכם, תוכלו להשתמש בפתרונות אחרים בראסט, בהתאם לסיבה שגורמת לכם לחפש כלי זה בזמן הפיתוח.

בדרך-כלל, ניגשים לירושה משתי סיבות. האחת היא כדי לעשות שימוש חוזר בקוד: ניתן ליישם התנהגות ספציפית עבור טיפוס אחד, ואז ירושה מאפשרת לכם להשתמש שוב ביישום עבור טיפוסים אחרים. ניתן לעשות זאת בצורה מצומצת בראסט על-ידי שימוש ביישומיי ברירת מחדל עבור תכונות, כפי שראיתם ברשימה 10-14 כאשר הוספנו יישום ברירת מחדל עבור המתודה `summarize` בתכונה `Summary`. לכל טיפוס המיישם את התכונה `Summary`, המתודה `summarize` תהיה זמינה ללא צורך בקוד נוסף. מצב זה דומה למצב בו מחלקת אב (parent class) מכילה יישום של מתודה, כך שלמחלקה שיורשת ממחלקה זו יש את אותו היישום. ניתן גם לעקוף את יישום ברירת המחדל של המתודה `summarize` כאשר אנו מיישמים את התכונה `Summary`, בצורה דומה למעקף שמחלקה יורשת יכולה לבצע כדי לעקוף את היישום שמחלקת האב מספקת.

הסיבה השניה לשימוש בירושה מתייחסת למערכת הטיפוסים: על מנת לאפשר שימוש בטיפוס בן (child type) באותם המקומות בהם ניתן להשתמש בטיפוס האב. תכונה זו נקראת גם *פולימורפיזם* (polymorphism), ומשמעה היכולת להחליף עצמים בינם לבין עצמם בזמן הריצה במידה והם משתפים תכונות מסויימות.

> ### פולימורפיזם
> 
> עבור משתמשים רבים, פולימורפיזם וירושה הם מושגים נרדפים. אבל למעשה פולימורפיזם הוא מושג רחב יותר שמתייחס לקוד שיכול לעבוד עם דאטה מכמה טיפוסים. במושג הירושה, טיפוסים אלה, בדרך כלל, הם תתי-מחלקות.
> 
> ראסט, לחילופין, מאפשרת שימוש בג'נריקס כדי לבצע אבסטרקטיזציה על פני טיפוסים שונים ומגבילי תכונות כדי לכפות תנאים על סוגי הטיפוסים שיש לספק. לעיתים קוראים לכך *פולימורפיזם פרמטרי מוגבל* (bounded parametric polymorphism).

בשנים האחרונות, ירושה איבדה מיוקרתה, בשפות רבות, ככלי לפתירת בעיות בפיתוח מכיוון שבפועל יש סכנה לשיתוף קוד שלא לצורך. תתי-מחלקות לא תמיד צריכות לשתם את כל המאפיינים של מחלקות האב שלהן, אבל זה בדיוק מה שקורה עם ירושה. דבר זה יכול להוביל לתבניות תכנות פחות גמישות. בנוסף, נוצרת גם האפשרות לקריאה למתודות על תתי-מחלקות שעלולת להיות חסרות הגיון או שיכולות ליצור שגיאות בגלל שהמתודות לא באמת רלוונטיות לתתי-המחלקות. בנוסף, שפות מסויימות מאפשרות אך ורק ירושה ישירה (single inheritance, ז"א שמחלקה יכולה לרשת רק ממחלקה אחת), ובכך נוצרת מגבלה נוספת על גמישות התכנון.

מסיבות אלה, ראסט פונה לאובייקטי תכונה (trait objects) במקום לירושה. הבה נראה כיצד אובייקטי תכונה מאפשרים פולימורפיזם בראסט.
