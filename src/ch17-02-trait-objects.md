## שימוש באובייקטי תכונה שמאפשרים ערכים מטיפוסים שונים

בפרק 8, אמרנו שאחת המגבלות של ווקטורים היא שווקטור מאכסן אלמנטים מטיפוס נתון אחד בלבד. יצרנו דרך לעקוף זאת ברשימה 8-9, שם הגדרנו את המבחר `SpreadsheetCell` שלו ווריאנטים לאכסון שלמים, מספרי נקודה צפה, וטקסט. משמעות הדבר היא שיכולנו לאחכסן טיפוסים שונים של דאטה בכל אחד מהתאים ועדיין להשתמש בווקטור שמייצג שורה של תאים. זהו פתרון טוב ויפה כאשר הטיפוסים הרלוונטים שייכים לקבוצה קבועה של טיפוסים שידועה בזמן קמפול הקוד.

אבל, לעיתים נרצה שמשתמש הספריה שלנו יוכל להרחיב את קבוצת הטיפוסים בהם ניתן להשתמש. כדי להראות כיצד נוכל להשיג זאת, ניצור דוגמא של כלי ממשק משתמש גרפי (GUI) שמבצע איטרציה על פני רשימת עצמים, וקורא למתודה `draw` עבור כל אחד מהם על מנת להציגו על המסך -- טכניקה נפוצה ביישום כלי GUI. אנו ניצור מכולת ספריה בשם `gui` שתכיל את המבנה של ספרית ה-GUI. מכולה זו עשויה לכלול כמה טיפוסים לנוחות המשתמשים, כמו `Button` או `TextField`. בנוסף, משתמשי ה-`gui` ירצו ליצור טיפוסים משלהם שגם אותם ניתן להציג על המסך: למשל, אולי מתכנת אחד יוסיף `Image` ומתכנתת אחרת תוסיף להוסיף טיפוס `SelectBox`.

לא ניישם כאן ספרית GUI מלאה רק למטרת דוגמא זו, אבל נראה כיצד החלקים השונים של מערכת כזו מתאימים יחדיו. אין ביכולתנו לדעת, בזמן כתיבת הספריה, אלו טיפוסים עתידיים ישמשו את המשתשמשים בספריה שלנו, ולכן אין יכולת להגדיר אותם כחלק מהמכולה. אבל אנחנו כן יודעים שמערכת ה-`gui` צריכה לעקוב אחר ערכים רבים מכל מיני טיפוסים, והיא צריכה להיות מסוגלת לקרוא למתודה `draw` על כל אחד מערכים אלה, בלי תלות בטיפוס הספציפי שלו. המערכת לא צריכה לדעת בדיוק מה יקרה כאשר המתודה `draw` תופעל, אלה רק לדעת שהטיפוסים הנדונים יאפשרו קריאה למתודה זו.

כדי לעשות כך בשפה עם ירושה, ניתן להגדיר מחלקה בשם `Component` שלה מתודה בשם `draw`. המחלקות האחרות, כמו `Button`, `Image`, ו- `SelectBox`, ירשו מ-`Component` ולכן ירשו את המתודה `draw`. כל מחלקה כזו תוכל לעקוף את את המתודה `draw` על מנת להגדיר את ההתנהגות הרצויה לה, אבל המערכת עצמה תוכל להתייחס אל כל הטיפוסים כאילו הם מופעים של `Component` ולקרוא למתודה `draw` עליהם. אבל בגלל שבראסט אין ירושה, אנחנו צריכים דרך אחרת לעצב את ספריית ה- `gui` שלנו כדי לאפשר למשתמשים להרחיב אותה עם טיפוסים משלהם.

### הגדרת תכונה כדי לשתף התנהגות

על מנת ליישם את היכולות שאנחנו רוצים עבור ה- `gui` שלנו, נגדיר תוכנה בשם `Draw` ובה מתודה אחת בשם `draw`. ואז נוכל להגדיר ווקטור של ערכים מסוג *אובייקט תכונה* (trait object). אובייקט תכונה מצביע גם למופע של טיפוס המיישם את התכונה שלנו וגם לטבלה המשמשת לחיפוש אחר מתודות תכונה שמוגדרות על הטיפוס בזמן הריצה. אנו יוצרים אובייקט תכונה על-ידי ציון סוג כלשהו של מצביע, כמו הפניית `&` או מצביע חכם מסוג `Box<T>`, לאחריו מילת המפתח `dyn`, ולבסוף ציון התכונה הרלוונטית. (נדון בסיבה לכך שאובייקטי תכונה חייבים להשתמש במצביע בפרק 19 בסעיף ["טיפוסים בגודל דינמי והתכונה `Sized`"][dynamically-sized]<!-- ignore -->) ניתן להשתמש באובייקטי תכונה במקום בטיפוסים גנריים או קונקרטיים. בכל פעם שמשתמשים באובייקט תכונה, מערכת הטיפוסים של ראסט תוודא בזמן הקומפילציה שכל ערך בו נעשה שימוש בהקשר זה יישם את התכונה של אובייקט התכונה. בעקבות זאת, אין צורך לדעת בזמן הקומפילציה מהן כל האפשרויות לטיפוסים.

כבר הזכרנו שאנו נמנעים, בראסט, מלהתייחס למבנים ולמבחרים "עצמים" בכדי להבדיל בינם לבין המושג "עצמים" בשפות אחרות. במבנה או במבחר, הדאטה שבשדות וההתנהגות בבלוקי `impl` הם נפרדים, בעוד שבשפות אחרות הדאטה וההתנהגות, כאשר הם מאוגדים לכדי מושג אחד, מקוטלגים לרוב כאובייקט. אולם, אובייקטי תכונה *הם* יותר כמו עצמים בשפות אחרות במובן שהם מאגדים דאטה והתנהגות. אבל אובייקטי תכונה נבדלים מעצמים מסורתיים בכך שאי אפשר להוסיף דאטה לאובייקט תכונה. אובייקטי תכונה אינם שימושיים באופן רחב כמו עצמים בשפות אחרות: השימוש הספציפי שלהם הוא לאפשר אבסטרקטיזציה על פני התנהגות משותפת.

רשימה 17-3 מראה כיצד להגדיר תכונה בשם `Draw` בעלת מתודה יחידה בשם `draw`:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-03/src/lib.rs}}
```

<span class="caption">רשימה 17-3: הגדרת התכונה `Draw`</span>

תחביר זה צריך להיות לכם מוכר מהדיון הקודם שלנו מפרק 10 אודות הדרך להגדיר תכונות. מייד מובא תחביר חדש: ברשימה 17-4 מוגדר מבנה בשם `Screen` אשר מאכסן ווקטור בשם `components`. זהו ווקטור מטיפוס `Box<dyn Draw>`, שהוא טיפוס אובייקט תכונה; זהו ממלא-מקום עבור כל טיפוס בתוך `Box` שמיישם את התכונה `Draw`.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-04/src/lib.rs:here}}
```


<span class="caption">רשימה 17-4: הגדרה של מבנה בשם `Screen` עם שדה בשם `components` שהוא ווקטור של אובייקטי תכונה המיישמים את התכונה `Draw`</span>

על המבנה `Screen` נגדיר מתודה בשם `run` שתקרא למתודה `draw` עבור כל אחד מהערכים ב- `components`, כפי שמוצג ברשימה 17-5:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-05/src/lib.rs:here}}
```


<span class="caption">רשימה 17-5: מתודה בשם `run` על המבנה `Screen` אשר קוראת למתודה `draw` עבור כל רכיב</span>

יישום זה עובד בצורה שונה מהגדרת מבנה שמשתמש בטיפוס פרמטר גנרי עם הגבלות תכונות. טיפוס פרמטר גנרי ניתן להחליף רק באמצעות טיפוס קונקרטי אחד, בעוד אובייקטי תכונה מאפשרים ריבוי טיפוסים קונקרטיים כממלאי מקום עבור אובייקט התכונה בזמן הריצה. לדוגמא, היינו יכולים להגדיר את המבנה `Screen` באמצעות טיפוס גנרי ומגבלת תכונה כמו ברשימה 17-6:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-06/src/lib.rs:here}}
```


<span class="caption">רשימה 17-6: אלטרנטיבה ליישום של המבנה `Screen` ומתודת ה-`run` שלו תוך שימוש בג'נריקס ומגבלות תכונה</span>

ביישום זה יש את המגבלה שבכל מופע של `Screen` רשימת הרכיבים הם כולם מטיפוס `Button` או כולם מטיפוס `TextField`. אם אתם יודעים מראש שהאוסף שלכם יהיה הומוגני, אז שימוש בג'נריקס ומגבלות תכונה הוא פתרון עדיף על פני אובייקטי תכונה. זאת מכיוון שההגדרות יעברו מונומורפיזציה בזמן הקומפילציה ויהפכו לטיפוסים קונקרטיים.

מצד שני, בגישה המשתמשת באובייקטי תכונה, מופע יחיד של `Screen` יכול להכיל ווקטור שבו ערך מטיפוס `Box<Button>` וכן ערך מטיפוס `Box<TextField>`. הבה נתבונן כיצד זה קורה, ואחר-כך נדון בהשלכות ביצועי זמן הריצה.

### יישום התכונה

כעת נוסיף כמה טיפוסים שמיישמים את התכונה `Draw`. נספק כאן את הטיפוס `Button`. נזכיר שוב, שיישום מלא של ספריית GUI הוא מעבר לשאיפות הספר הזה, ולכן בגוף המתודה `draw` לא יהיה שום יישום שימושי. To imagine what the implementation might look like, a `Button` struct might have fields for `width`, `height`, and `label`, as shown in Listing 17-7:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch17-oop/listing-17-07/src/lib.rs:here}}
```


<span class="caption">רשימה 17-7: מבנה מסוג `Button` המיישם את התכונה `Draw`</span>

השדות `width`, `height`, ו- `label` של `Button` יהיו שונים מהשדות של רכיבים אחרים; למשל, טיפוס מסוג `TextField` יכול לכלול שדות אלה ובנוסף שדה בשם `placeholder`. כל טיפוס שנרצה להציג על המסך יממש את התכונה `Draw` אבל ישתמש בקוד שונה במתודה `draw` על מנת להגדיר כיצד להציג את הטיפוס הספציפי, כפי שיש ל-`Button` כאן (ללא קוד אמת של GUI, בהתאם לאמור לעיל). לטיפוס `Button`, למשל, יכול להיות בלוק `impl` נוסף המכיל מתודות הקשורות לתרחיש בו המשתמש לוחץ על כפתור. מתודות מסוג זה לא יהיו תקפות עבור טיפוסים כמו `TextField`.

אם משתמש כלשהו בספריה שלנו יחליט לממש מבנה מסוג `SelectBox` שבו יש את השדות `width`, `height`, ו- `options`, יהיה עליהם לממש גם את התכונה `Draw` עבור הטיפוס `SelectBox`, כפי שמוצג ברשימה 17-8:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch17-oop/listing-17-08/src/main.rs:here}}
```


<span class="caption">רשימה 17-8: מכולה נוספת שמשתמשת ב-`gui` ומממשת את התכונה `Draw` עבור המבנה `SelectBox`</span>

משתמש הספריה שלנו יכול עכשיו לכתוב את פונקציית ה- `main` שלהם כדי ליצור מופע של `Screen`. למופע זה של `Screen`, הם יוכלו גם להוסיף ערכי `SelectBox` ו- `Button` על-ידי הכנסת כל ערך ל-`Box<T>` כדי להפוך אותם לאובייקטי תכונה. בצורה זו הם יוכלו לקרוא למתודה `run` על מופע ה- `Screen`, דבר שיגרום לקריאה למתודה `draw` על כל אחד מהרכיבים. רשימה 17-9 מראה מימוש זה:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch17-oop/listing-17-09/src/main.rs:here}}
```


<span class="caption">רשימה 17-9: שימוש באובייקטי תכונה כדי לאכסן ערכים מטיפוסים שונים שמיישמים את אותה התכונה</span>

כאשר כתבנו את הספריה, לא ידענו שמשתמש עתידי עלול להוסיף טיפוס מסוג `SelectBox`, אבל המימוש שלנו של `Screen` יכל לפעול עם הטיפוס החדש ולהציגו על המסך מכיוון ש-`SelectBox` מממש את התכונה `Draw`, וכך מובטח שהוא ממשמ את המתודה `draw`.

מושג זה -- היכולת להתמקד רק בהודעות להן ערך מסויים מגיב, ללא צורך לדעת דבר אודות הטיפוס הקונקרטי עצמו -- דומה למושג *duch typing* בשפות בעלות טיפוסים דינמיים, מונח השאול מהאמרה: if it walks like a duck and quacks like a duck, then it must be a duck! במימוש של `run` עבור `Screen` ברשימה 17-5, המתודה `run` לא צריכה לדעת מהו הטיפוס הקונקרטי של כל רכיב ורכיב. היא לא בודקת האם הרכיב הוא מופע של `Button` או של `SelectBox`, אלא פשוט קוראת למתודה `draw` של הרכיב הנדון. על-ידי ציון הטיפוס של הערכים כ- `Box<dyn Draw>` בווקטור `components`, הצהרנו כי `Screen` זקוק לערכים שעליהם ניתן לקרוא למתודה `draw`.

היתרון שבשימוש באובייקטי תכונה ובמערכת הטיפוסים של ראסט על מנת לכתוב קוד הדומה לקוד שמשתמש ב-duck typing הוא שכך אין צורך לבדוק האם ערך מסויים מממש מתודה מסויימת בזמן הריצה, ואין צורך לדאוג שנקבל שגיאות במידה וערך מסויים לא מממש מתודה שאנו בכל זאת קוראים לה. ראסט לא תקמפל את הקוד שלנו אם הערכים לא מממשים את התכונות שאובייקט התכונה דורש.

למשל, רשימה 17-10 מראה מה קורה אם ננסה ליצור מופע של `Screen` עם רכיב מטיפוס `String`:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch17-oop/listing-17-10/src/main.rs}}
```


<span class="caption">רשימה 17-10: ניסיון להשתמש בטיפוס שלא מממש את תכונת אובייקט התכונה</span>

נקבל שגיאה זו משום שהטיפוס `String` לא מממש את התכונה `Draw`:

```console
{{#include ../listings/ch17-oop/listing-17-10/output.txt}}
```

שגיאה זו מתריעה בפנינו שאו שאנחנו מעבירים דבר מה ל- `Screen` שלא התכוונו להעביר ושלכן כדאי לבדוק אם ראוי להעביר טיפוס אחר, או שיש עלינו למממש את התכונה `Draw` עבור הטיפוס `String` ובכל לאפשר ל- `Screen` לקרוא למתודה `draw` על מימושים שלו.

### אובייקטי תכונה מבצעים שיגור דינמי

זכרו מסעיף ["ביצועי קוד המשתמש בג'נריקס"]()<!-- ignore --> שבפרק 10 את הדיון שלנו אודות תהליך המונומורפיזציה שמבוצע על-ידי הקומפיילר כאשר משתמשים במגבלות תכונה על ג'נריקס: הקומפיילר מייצר מימושים לא-גנריים של פונקציות ומתודות עבור כל טיפוס קונקרטי בו אנו משתמשים במקום טיפוס פרמטר גנרי. הקוד שנוצר כתוצאה מתהליך המונומורפיזציה מבצע *שיגור סטטי* (static dispatch), כיוון שהקומפיילר יודע בזמן הקומפילציה בדיוק לאיזה מתודה קוראים. זאת בניגוד ל-*שיגור דינמי*, שמבוצע כאשר הקומפיילר לא יכול לדעת בזמן הקומפילציה לאיזה מתודה צריך לקרוא. במקרה של שיגור דינמי, הקומפיילר מייצר קוד שיצתרך, בזמן הריצה, להבין לאיזה מתודה לקרוא.

כאשר משתמשים באובייקטי תכונה, ראסט חייבת לבצע שיגור דינמי. הקומפיילר לא יכול לדעת מהם כל הטיפוסים האפשריים שיכולים להיות בשימוש עם הקוד שמשתמש באובייקטי תכונה, ולכן הוא לא יודע לאיזה מהמתודות הממומשות עבור הטיפוסים צריך לקרוא. במקום זאת, בזמן הריצה, ראסט משתמשת במצביעים בתוך אובייקט התכונה כדי לדעת לאיזה מתודה לקרוא. חיפוש זה גורר מחיר בזמן הריצה, מחיר שלא קיים בביצוע שיגור סטטי. שיגור דינמי גם מונע מהקומפיילר מלבחור למקם את קוד המתודה כ-inline, ודבר זה מגביל את יכולות האופטימיזציה של הקומפיילר. מחיר זה אנו משלמים בעבור הגברת גמישות הקוד שכתבנו ברשימה 17-5 ובו יכלונו לתמוך ברשימה 17-9. אלו היתרונות והחסרונות של אובייקטי תכונה.
ch10-01-syntax.html#performance-of-code-using-generics

[dynamically-sized]: ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait
