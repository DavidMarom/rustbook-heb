## הגדרת מבחרים

בעוד שמבנים מקנים לכם דרך לאגד שדות הקשורים זה לזה יחד עם דאטה, כמו המבנה `Rectangle` עם השדות `width` ו- `height`, מבחרים מאפשרים לכם לאמר שערך הוא אחד ממחלקה מסויימת של ערכים. למשל, נוכל לרצות לאמר ש-`Rectangle` הוא צורה אחת מתוך מחלקה של צורות אפשריות שכוללת גם את `Circle` וגם את `Triangle`. על מנת לעשות זאת, ראסט מאפשרת לקודד אפשרויות כמבחר.

הבה נתבונן בסיטואציה שנרצה לבטא בקוד ונראה מדוע מבחרים שימושיים ומתאימים, במקרה זה, יותר ממבנים. נניח שאנו עובדים עם כתובות IP. שני סטנדרטים מרכזיים נמצאים בשימוש עבור כתובות IP: גרסת ארבע וגרסת שש. מכיוון שאלו האפשרויות היחידות עבוד כתובת IP בהן התוכנית שלנו אי-פעם תשתמש, יש ביכולתנו למנות את כל הווריאנטים האפשריים. המינוח באנגלית למבחר הוא enumeration, דהיינו מניה, ומכאן נגזר המינוח הלועזי.

כל כתובת IP יכולה להיות או גרסת ארבע או גרסת שש, אבל לא שתי הגרסאות באותו זמן. תכונה זו של כתובות IP היא זו שהופכת את השימוש במבחר למתאים במקרה זה משום שערך של מבחר יכול להיות בדיוק אחד מהווריאנטים שלו. גם כתובות גרסת ארבע וגם גרסת שש הן עדיין, ביסודן, כתובות IP, ולכן יש להתייחס אליהן כבעלות אותו טיפוס כאשר הקוד מטפל במצב שתקף לכל סוג של כתובת IP.

אנו יכולים להביע מושג זה בקוד ע"י הגדרת מבחר בשם `IpAddrKind` וציון הסוגים האפשריים שכתובת IP יכולה להיות, דהיינו `V4` ו- `V6`. אלו הווריאנטים של המבחר:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:def}}
```

כעט, `IpAddrKind` הוא טיפוס דאטה בפני עצמו וניתן להשתמש בו בכל מקום בקוד.

### ערך מטיפוס מבחר

ניתן ליצור מופעים של כל אחד משני הווריאנטים של `IpAddrKind` כך:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:instance}}
```

שימו לב שהווריאנטים של המבחר ממוקמים (namespaced) תחת המציין שלו, ומשתמשים בנקודותיים כפולות כדי להפריד בינהם. זה שימושי ונוח כי עכשיו שני הערכים `IpAddrKind::V4` ו- `IpAddrKind::V6` הם מאותו טיפוס: `IpAddrKind`. ולכן אפשר, למשל, להגדיר פונקציה שלוקחת כל משתנה מטיפוס `IpAddrKind`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn}}
```

לפונקציה זו ניתן לקרוא עם כל אחד מהווריאנטים:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn_call}}
```

לשימוש במבחרים יש אפילו עוד יתרונות. מעט מחשבה אודות טיפוס כתובות ה-IP שלנו מגלה שבשלב זה אין לנו דרך לאכסן את כתובת ה-IP עצמה; כל שאנו יודעים הוא מאיזה *סוג* היא. בהינתן שזה עתה למדתם, בפרק 5, על מבנים, ייתכן ואתם מתפתים לפתור בעיה זו באמצעות מבנים, כמו שמוצג ברשימה 6-1.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-01/src/main.rs:here}}
```


<span class="caption">רשימה 6-1: אכסון הדאטה והווריאנט של `IpAddrKind` של כתובת IP תוך שימוש במבנה</span>

כאן, הגדרנו את המבנה `IpAddr` שלו שני שדות: השדה `kind` שהוא מטיפוס `IpAddrKind` (המבחר שהגדרנו קודם) והשדה `address` מטיפוס `String`. יש לנו שני מופעים של מבנה זה. הראשון הוא `home`, ובו מאוכסן הערך `IpAddrKind::V4` בשדה `kind` יחד עם הכתובת `127.0.0.1` כדאטה מקושר. המופע השני הוא `loopback`. לו יש את הווריאנט השני של `IpAddrKind` כערך בשדה `kind`, דהיינו `V6`, והכתובת המקושרת היא `::1`. השתמשנו במבנה כדי לאגד יחדיו את ערכי ה- `kind` וה- `address`, כך שעכשיו הווריאנט משוייך לערך.

אולם, פשוט יותר לייצג את אותו הרעיון תוך שימוש במבחר בלבד: במקום מבחר בתוך מבנה אנו יכולים לאכסן דאטה ישירות לתוך כל ווריאנט של המבחר. הגדרה חדשה זו של המבחר `IpAddr` מציינת שלשני הווריאנטים `V4` ו-`V6` ישוייכו ערכי `String`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-02-enum-with-data/src/main.rs:here}}
```

אנו מקשרים דאטה ישירות לכל ווריאנט של המבחר, וכך אין צורך ליצור מבנה מעבר למבחר. במקרה זה גם קל להבחין בפרט נוסף בדבר דרך פעולת מבחרים: השם של כל ווריאנט של המבחר מתפקד גם כפונקציה שבונה מופע של המבחר. ז"א ש- `IpAddr::V4()` הוא קריאה לפונקציה שמקבלת ארגומנט מטיפוס `String` ומחזירה מופע מטיפוס `IpAddr`. אנו מקבלים פונקציות בונות אלה בצורה אוטמוטית כתוצאה מהגדרת המבחר.

ישנו אף יתרון נוסף לשימוש במבחר במקום במבנה: לכל ווריאנט יכול להיות דאטה מקושר מטיפוסים שונים ובכמויות שונות. לגרסת ארבע של כתובות IP תמיד יהיו ארבעה רכיבים נומריים בעלי ערכים בין 0 ל-255. לו רצינו לאכסן כתובת `V4` כארבע ערכי `u8` אבל עדיין לבטא כתובות `V6` כערך יחיד מטיפוס `String`, לא היינו יכולים לעשות זאת באמצעות מבנה. מבחרים מתמודדים עם מקרה שכזה בקלות:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-03-variants-with-different-data/src/main.rs:here}}
```

הדגמנו כמה דרכים שונות להגדיר מבני דאטה לאכסון כתובות IP בגרסת ארבע ובגרסת שש. אבל, מתברר שאכסון כתובות IP וקידוד הסוג שלהן הוא דבר כל-כך נפוץ [שבספריה הסטנדרטית יש הגדרה לשימושנו!][IpAddr]<!-- ignore --> הבה נראה כיצד הספריה הסטנדרטית מגדירה את `IpAddr`: אנו מוצאים בדיוק את אותו המבחר והווריאנטים שאנו הגדרנו ובהם השתמשנו, אבל המידע אודות הכתובת עצמה נמצא באחד משני מבנים שונים, ואלו מוגדרים באופן שונה לכל ווריאנט:

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

קוד זה מדגים שניתן לשים כל סוג של דאטה בתוך ווריאנט של מבחר: מחרוזות, טיפוסים נומריים, או מבנים, למשל. ניתן אף להשתמש במבחר אחר! בנוסף, גילינו שטיפוסים המוגדרים בספריה הסטנדרטית הם לרוב לא הרבה יותר סבוכים ממה שאתם הייתם כותבים בעצמכם.

שימו לב שלמרות שהספריה הסטנדרטית מכילה הגדרה עבור `IpAddr`, אנחנו עדיין יכולים ליצור ולהשתמש בהגדרות משלנו ללא התנגשות, כיוון שלא הכנסנו את ההגדרות מהספריה הסטנדרטית למתחם שלנו. נרחיב את הדיבור אודות הכנסת טיפוסים למתחם בפרק 7.

הבה נתבונן בדוגמא נוספת של מבחר ברשימה 6-2: הפעם יש מגוון רחב של טיפוסים המשובצים בתוך הווריאנטים.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```


<span class="caption">רשימה 6-2: מבחר `Message` בו כל ווריאנט מאכסן כמות שונה של ערכים מטיפוסים שונים</span>

למבחר זה יש ארבעה ווריאנטים מטיפוסים שונים:

* ל-`Quit` אין כלל דאטה מקושר.
* ל-`Move` יש שדות עם שמות, כמו שיש במבנה.
* ל-`Write` יש ערך יחיד מטיפוס `String`.
* ל-`ChangeColor` יש שלושה ערכי `i32`.

הגדרת מבחר אם ווריאנטים כמו אלה ברשימה 6-2 דומה להגדרת סוגים שונים של הגדרות מבנה, למעט שבמקרה של מבחר לא משתמשים במילת המפתח `struct` וכל הווריאנטים מקובצים יחדיו תחת הטיפוס `Message`. המבנים הבאים יכולים לאכסן את אותו המידע כמו הווריאנטים של המבחר הקודם:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-04-structs-similar-to-message-enum/src/main.rs:here}}
```

אבל, אם היינו משתמשים במבנים האחרים, שכל אחד מהם הוא טיפוס בפני עצמו, לא היינו יכולים להגדיר פונקציה שיכולה לקבל כל אחד מסוגי ההודעות האלה באותה הקלות בה אנו עושים זאת באמצעות המבחר `Message` המוגדר ברשימה 6-2, שהוא טיפוס אחד ויחיד.

יש עוד נקודת דמיון אחת בין מבחרים למבנים: בדיוק כמו שניתן להגדיר מתודות על מבנים באמצעות `impl`, ניתן גם להגדיר מתודות על מבחרים. הינה מתודה בשם `call` שניתן להגדיר על המבחר `Message`:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-05-methods-on-enums/src/main.rs:here}}
```

בגוף המתודה משתמשים ב-`self` כדי לגשת אל הערך עליו המתודה נקראה. בדוגמא זו, יצרנו את המשתנה `m` שמקושר לערך `Message::Write(String::from("hello"))`, וזה הערך אליו `self` יתייחס בגוף המתודה `call` כאשר `m.call()` רץ.

הבה נתבונן במבחר נוסף, שימושי מאוד, מהספריה הסטנדרטית: `Option`.

### המבחר `Option` ויתרונותיו מול ערכי Null

סעיף זה הוא מקרה בוחן (case study) לשימוש ב- `Option`, שהוא מבחר נוסף מהספריה הסטנדרטית. הטיפוס `Option` מקודד את סיטואציה שכיחה בה ערך מסוים יכול להיות משהו או כלום.

למשל, אם קוראים את האיבר הראשון ברשימה שאינה ריקה, אז מקבלים ערך. אם מבקשים את האיבר הראשון מרשימה ריקה, לא מקבלים דבר. ביטוי מושג זה במונחי מערכת הטיפוסים משמעה שהקומפיילר יכול לבדוק אם טיפלתם בכל המקרים שצריכים טיפול; פונקציונאליות זו יכולה למנוע באגים נפוצים מאוד בשפות תכנות אחרות.

התחום של עיצוב שפות תכנות נתפס לעיתים קרובות במונחים של התכונות שרוצים שהשפה תכלול, אבל תכונות שרוצים להדיר מהשפה חשובות גם הן. לראסט אין את תכונת ה-null שיש לשפות רבות אחרות. *Null* הוא ערך שמשמעותו היא שאין ערך. בשפות עם null, משתנים תמיד יכולים להיות באחד משני מצבים: null או non-null.

במצגת “Null References: The Billion Dollar Mistake” משנת 2009, טוני הוארה (Tony Hoare), ממציא ה-null, אמר כך:

> אני קורא לזה טעות ביליון הדולר שלי. בזמנו, תכננתי את מערכת הטיפוסים המקיפה הראשונה להפניות בשפה מונחת-עצמים. המטרה שלי היתה להבטיח שכל שימוש בהפניה יהיה בטוח לחלוטין, עם בדיקות שמבוצעות אוטומטית ע"י הקומפיילר. אבל לא יכולתי לעמוד בפיתוי של הוספת הפנית null, פשוט כי זה היה קל מאוד ליישום. דבר זה הוביל לאינספור שגיאות, רגישויות, וקריסות מערכת, שלבטח גרמו לנזק וכאב בשווי בליון דולר במהלך 40 השנים האחרונות.

הבעיה עם ערכי null היא שאם מנסים להשתמש בערך null כאילו הוא non-null, מקבלים שגיאה כלשהיא. בגלל שהשאלה האם ערך הוא null או non-null יכולה לצוץ בכל מקום, שגיאות מסוג זה צצות אף הן בקלות רבה מידי.

בכל זאת, המושג ש-null מנסה לבטא הוא בעל חשיבות: null מייצג ערך שכרגע, מסיבה זו או אחרת, לא תקף או חסר.

שורש הבעיה אינו נעוץ במושג עצמו אלא באופן היישום. וכך, בראסט אין ערכי null, אבל מבחר מתאים המקודד את המושג של נוכחות או העדרות של ערך, יש ויש. מבחר זה הוא `Option<T>`, והוא [מוגדר בספריה הסטנדרטית][option]<!-- ignore -->
בצורה הבאה:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

המבחר `Option<T>` הוא כל-כך שימושי שהוא אפילו נכלל בפרליוד; אין צורך להכניס אותו לתוך המתחם באופן מפורש. הווריאנטים שלו כלולים גם הם בפרליוד: ניתן להשתמש ב- `Some` וב- `None` ישירות, ללא צורך להקדימם עם `Option::`. מעבר לכך, המבחר `Option<T>` הוא מבחר ככל מבחר אחר, והווריאנטים `Some(T)` ו-`None` הם פשוט ווריאנטים מטיפוס `Option<T>`.

התחביר `<T>` הוא יכולת של ראסט עליה עוד לא דיברנו. זהו פרמטר טיפוס גנרי, נושא בו נדון ביתר פירוט בפרק 10. לעכשיו, כל שאתם צריכים לדעת הוא שהמשמעות של `<T>` היא שהווריאנט `Some` של המבחר `Option` יכול להכיל פיסת דאטה אחת מכל טיפוס שהוא, ושכל טיפוס קונקרטי בו משתמשים במקום `T` הוא חלק בלתי נפרד מהטיפוס הכולל של `Option<T>`. במילים אחרות, `Option<T>`הוא משפחה שלמה של טיפוסים, אחד לכל טיפוס`T`. הינה כמה דוגמאות לשימוש בערכי `Option` על מנת לאכסן טיפוסי מספר וטיפוסי תו:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here}}
```

הטיפוס של `some_number` הוא `Option<i32>`. הטיפוס של `some_char` הוא `Option<char>`, ואלו שני טיפוסים שונים. ראסט יכולה להסיק את הטיפוסים האלה כיוון שציינו ערך בתוך הווריאנט `Some`. עבור `absent_number`, ראסט דורשת שנבאר באיזה טיפוס `Option` מדובר: הקומפיילר לא יכול להסיק בעצמו איזה טיפוס הווריאנט `Some` יהיה רק מהמידע שמסופק לו באמצעות הערך `None`. כאן, אנו אומרים לראסט שכוונתנו היא ש- `absent_number` הוא מטיפוס `Option<i32>`.

כאשר יש לנו ערך מסוג `Some`, אנו יודעים שיש ערך בנמצא ושערך זה ממוקם בתוך ה- `Some`. כאשר יש לנו ערך מסוג `None`, במובן מסויים המשמעות היא זהה למשמעות של null: אין לנו ערך תקף. אז מדוע `Option<T>` עדיף על null?

בקצרה, משום ש- `Option<T>` ו- `T` (כאשר `T` יכול להיות כל טיפוס שהוא) הם טיפוסים שונים, הקומפיילר לא יאפשר לנו להשתמש בערכי `Option<T>` כאילו שהיו ערך תקף. למשל, הקוד הבא לא יעבור קומפילציה, בגלל שהוא מנסה להוסיף `i8` ל- `Option<i8>`:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here}}
```

אם נריץ את הקוד, נקבל את הודעת שגיאה מהצורה:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}
```

מלחיץ! למעשה, הודעת שגיאה זו משמעה שראסט אינה מבינה איך להוסיף `i8` ל-`Option<i8>`, כיוון שהם מטיפוסים שונים. כאשר יש לנו ערך מטיפוס `i8` בראסט, הקומפיילר יוודא שתמיד יש לנו ערך תקף. אנו תמיד יכולים להמשיך בביטחון ללא צורך לבדוק שמה הערך הוא null לפני שימוש בו. אנחנו רק צריכים לדאוג אם יש ערך או אין כשאנו מתעסקים עם `Option<i8>` (או כל טיפוס אחר לערך עצמו), והקומפיילר יוודא שאנו מטפלים בכך בצורה נאותה לפני שנורשה לנסות ולהשתמש בערך.

במילים אחרות, יש להמיר את `Option<T>` ל-`T` לפני שאפשר לבצע פעולות מסוג `T` על הערך. באופן כללי, פועל יוצא מכך הוא הימנעות מאחת הבעיות הנפוצות שנובעות משימוש ב-null: הנחה מוטעית שמשהו אינו null כשלמעשה הוא כן null.

העלמת הסכנה של הנחה שגויה שערך מסויים אינו null תורמת לביטחון שלכם בקוד שלכם. על מנת לאפשר מצב בו ערך יכול להיות null, יש לבחור מפורשות לעשות זאת ע"י הצהרת הטיפוס של הערך כ- `Option<T>`. ואז, כאשר מתשמשים בערך זה, חייבים לטפל בצורה מפורשת במקרה שהערך הוא null. בכל מקום בו לערך יש טיפוס שאינו `Option<T>`, אז *אפשר* בביטחון להניח שערך זה אינו null. מצב זה הוא החלטת עיצוב מתוכננת בראסט על מנת להגביל את הפזיזות שבשימוש ב-null ולהגביר את בטיחות הקוד של ראסט.

אם כן, כיצד מפיקים ערך מטיפוס `T` מתוך הווריאנט `Some` כאשר יש לכם ערך מטיפוס `Option<T>` על מנת להשתמש בו ישירות? למבחר `Option<T>` יש מספר רב של מתודות שימושיות למגוון מצבים; תוכלו לקרוא עליהן [בתיעוד][docs] של המבחר<!-- ignore -->. פיתוח הכרות ונוחות שימוש עם המתודות המוגדרות על `Option<T>` יהיו יכולות שימושיות וחשובות במסלול ההתקדמות שלכם עם ראסט.

באופן כללי, על מנת להשתמש בערך מטיפוס `Option<T>`, יש לכלול קוד שמטפל בכל ווריאנט. תצטרכו שיהיה קוד שירוץ רק כאשר הערך הוא מסוג `Some(T)`, וקוד זה רשאי להשתמש בערך הפנימי מטיפוס `T`. תצטרכו גם קוד שירוץ רק כאשר הערך הוא ערך מסוג `None`, ולקוד זה אין דרך להתייחס לערך פנימי מטיפוס `T`. ביטוי `match` הוא מבנה תחבירי לבקרת זרימה של קוד שמאפשר ארגון קוד בצורה זו תוך שימוש במבחרים: הוא מריץ קוד שונה בהתאם לווריאנט של המבחר בו הוא פוגש, וקוד זה יכול לגשת לדאטה שבתוך הערך המותאם.

[IpAddr]: ../std/net/enum.IpAddr.html
[option]: ../std/option/enum.Option.html
[docs]: ../std/option/enum.Option.html
