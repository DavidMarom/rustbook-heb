## שגיאות סופניות ופאניקה

לעיתים, דברים לא טובים קורים בקוד, ואין הרבה מה לעשות בקשר לכך. למקרים כאלה, ראסט כוללת את המאקרו `panic!`. בפועל ישנן שתי דרכים להיכנס לפאניקה: על-ידי נקיטת פעולה שגורמת לקוד להיכנס לפאניקה (כמו ניסיון גישה לאינדקס מערך מעבר לסופו), או על-ידי קריאה מפורשת למאקרו `panic!`. בשני המקרים, התכנית תיכנס לפאניקה. כברירת מחדל, כניסה כזו לפאניקה תדפיס הודעת קריסה, תגלול את המחסנית לאחור, תנקה את זיכרון המחסנית, ותצא. באמצעות הגדרת משתנה סביבה (environment variable) מתאים, ניתן להורות לראסט להציג בנוסף את מחסנית הקריאות (call stack) בעת כניסה לפאניקה, על-מנת להקל את איתור מקור הבעיה.

> ### גלילת המחסנית או עצירה מוחלטת בתגובה לפאניקה
>
> כברירת מחדל, בעת כניסה לפאניקה, התכנית מתחילה לגלול. משמעות הדבר היא שראסט עוברת על המחסנית ומנקה את הדאטה של כל פונקציה שהיא פוגשת. אבל, עבור ראסט, הגלילה והניקיון הן לא מעט עבודה. לכן, ראסט מאפשרת לבחור באפשרות החליפית של _עצירה מיידית_, שתסיים את ריצת התכנית באופן מיידי, ללא פעולות ניקוי.
>
> במקרה כזה, מערכת ההפעלה תהיה זו שתפקידה לנקות את הזיכרון בו השתמשה התכנית שלכם. אם לפרוייקט שלכם נדרש גודל בינארי קטן ככל האפשר, תוכלו לעבור מגלילה לעצירה מוחלטת על-ידי הוספת `panic = 'abort'` לסעיפי ה- `[profile]` הרלוונטים של קובץ ה-_Cargo.toml_. לדוגמה, אם אתם רוצים לעצור לחלוטין במקרה של פאניקה במצב release, הוסיפו את הטקסט:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

הבה ננסה לקרוא ל-`panic!` מתוך תכנית פשוטה:

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}
```

כאשר תריצו את התכנית, תראו משהו כמו זה:

```console
{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}
```

הקריאה ל-`panic!` מדפיסה את הודעת השגיאה שבשתי השורות האחרונות. השורה הראשונה מראה את הודעת הפאניקה שלנו ואת המיקום בקוד שלנו בו ארעה הפאניקה: _src/main.rs:2:5_ מציין שמדובר בשורה השניה, התו החמישי בקובץ _src/main.rs_.

במקרה זה, השורה המצויינת היא חלק מהקוד שלנו, ואם נלך לשורה זו, נראה את הקריאה למאקרו `panic!`. במקרים אחרים, הקריאה ל- `panic!` יכולה להופיע בקוד חיצוני, שהקוד שלנו משתמש בו, ושם הקובץ ומספר השורה שידווחו בהודעת השגיאה יהיו של המיקום בקוד החיצוני. ניתן להשתמש במעקב-לאחור (backtrace) של הפונקציות שגררו קריאה ל- `panic!`, כדי להבין איזה חלק בדיוק בקוד שלנו גרם לבעיה. הבה נדון במעקב- לאחור ביתר פירוט.

### שימוש במעקב לאחור של `panic!`

הבה נתבונן בדוגמה נוספת כדי לראות מה קורה כאשר קריאה ל-`panic!` מגיעה מספריה חיצונית בעקבות באג בקוד שלנו. ברשימה 9-1 מופיע קוד שמנסה לגשת לאינדקס לא-תקף בווקטור.

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}
```

<span class="caption">רשימה 9-1: ניסון לגשת לפריט מעבר לסוף הווקטור, מה שיגרום לקריאה ל-`panic!`</span>

כאן, אנו מנסים לגשת לפריט ה-100 בווקטור (כיוון שמספור אינדקסים מתחיל ב-0, הפריט ה-100 נמצא-כביכול באינדקס 99), אבל בווקטור מאוחסנים רק שלושה פריטים. במקרה זה, ראסט תיכנס לפאניקה. שימוש ב- `[]` אמור להחזיר פריט, אבל אם מעבירים אינדקס לא-תקף, אז אין פריט אותו ראסט יכולה להחזיר.

בשפת C, ניסיון לקרוא מעבר לסוף של מבנה נתונים כלשהי מוביל להתנהגות לא-מוגדרת. יתכן ותקבלו דבר מה הנמצא בזיכרון במיקום שהיה תואם לאינדקס הנתון לו מבנה הנתונים היה ארוך יותר. זאת, למרות שמיקום זה כלל לא שייך לאותו מבנה נתונים. לכך קוראים _buffer overread_, ופעולה כזו עלולה להוביל לפרצות אבטחה במידה ותוקף יהיה מסוגל לתמרן את האינדקס כך שתיווצר גישה לדאטה רגיש שממוקם מחוץ למבנה הנתונים.

כדי להגן על תכניתכם מסוג זה של פעילות עוינת, ראסט תעצור את ריצת התכנית ותסרב להמשיך אם תנסו לקרוא פריט באינדקס שלא קיים. הבה ננסה וניווכח:

```console
{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}
```

שגיאה זו מצביעה על שורה 4 בקובץ `main.rs` בה אנו מנסים לגשת לאינדקס 99. השורה הבאה אומרת לנו שאנחנו יכולים להשתמש במשתנה הסביבתי `RUST_BACKTRACE` על-מנת לעקוב-לאחור ולראות את השתלשלות האירועים שהובילו לשגיאה. _מעקב לאחור_ אינו אלא הצגת רשימה של הפונקציות שנקראו והובילו לנקודה זו. מעקב-לאחור בראסט עובד בדיוק כמו בשפות אחרות: המפתח לקריאה מועילה של המעקב-לאחור הוא להתחיל מההתחלה, ולסרוק עד שמגיעים לקבצים שאתם כתבתם. זו הנקודה בה הבעיה התחילה. השורות מעל נקודה זו הן קוד בו הקוד שלנו עשה שימוש; השורות שמתחת הן קוד שקרא לקוד שלנו. השורות האלה, של לפני ואחרי, עשויות לכלול קוד ליבה של ראסט, קוד מהספריה הסטנדרטית, או קוד ממכולות בהן אתם משתמשים. הבה ננסה לקרוא מעקב-לאחור על-ידי שימוש בערך בלתי-תקני עבור המשתנה הסביבתי `RUST_BACKTRACE`. רשימה 9-2 מציגה פלט דומה למה שתראו.

<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->

```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

<span class="caption">רשימה 9-2: המעקב לאחור שנוצר מקריאה ל-`panic!` שמוצג כאשר מציבים ערך עבור המשתנה הסביבתי `RUST_BACKTRACE`</span>

זה די הרבה לקרוא! הפלט המדויק שאתם תראו עשוי להיות מעט שונה, בהתאם למערכת ההפעלה שלכם ובגרסת ראסט בה אתם משתמשים. בכדי לקבל מעקב-לאחור עם מידע זה, יש לאפשר סימולי דה-באג. סימולי דה-באג זמינים כברירת מחדל כאשר משתמשים ב- `cargo build` או ב- `cargo run` ללא הדגל `--release`, כפי שאנו עושים כאן.

בפלט ברשימה 9-2, שורה 6 של המעקב-לאחור מצביעה לשורה בפרוייקט שלנו שגורמת לבעיה: שורה 4 בקובץ _src/main.rs_. אם אנחנו לא רוצים שהתכנית שלנו תיכנס לפאניקה, אנחנו צריכים להתחיל את מלאכת איתור הבעיה במיקום אליו מצביעה השורה הראשונה המציינת קובץ שכתבנו אנחנו. ברשימה 9-1, שם כתבנו בכוונה קוד שנכנס לפאניקה, הדרך להימנע מפאניקה היא להימנע מלגשת לפריט באינדקס שמעבר לגבול הווקטור. בעתיד, כאשר הקוד שלכם יכנס לפאניקה, תצטרכו להבין מה בדיוק עושה הקוד שלכם, ועם איזה ערכים, שגורר פאניקה. מכאן תוכלו גם להסיק מה עשוי להיות הפתרון.

נחזור למאקרו `panic!`, ונדון מתי ראוי ומתי לא ראוי להשתמש בו כדי לנהל מצבי שגיאה, בסעיף ["להיכנס לפאניקה, כן או לא?"]()<!-- ignore --> מאוחר יותר בפרק זה. נעבור כעת לדון בדרכים להתמודד עם שגיאות באמצעות הטיפוס `Result`.
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
