## שגיאות סופניות ופאניקה

לעיתים, דברים לא טובים קורים בקוד, ואין מה לעשות בקשר לכך. למקרים כאלה, לראסט יש את המאקרו `panic!`. בפועל יש שתי דרכים להיכנס לפאניקה: על-ידי נקיטת פעולה שגורמת לקוד להיכנס לפאניקה (כמו גישה למערך מעבר לאורכו) או על-ידי קריאה מפורשת למאקרו `panic!`. בשני המקרים, אנו גורמים לתכנית להיכנס לפאניקה. כברירת מחדל, כניסה כזו לפאניקה תדפיס הודעת קריסה, תגלול את הריצה, תנקה את המחסנית, ותצא. דרך משתנה סביבתי (environment variable), ניתן גם לגרום לראסט להציג את מחסנית הקריאות (call stack) בעת כניסה לפאניקה על מנת להקל על איתור מקור הכניסה לפאניקה.

> ### גלילת המחסנית או עצירה מוחלטת בתגובה לפאניקה
> 
> כברירת מחדל, כאשר נכנסים לפאניקה, התכנית מתחילה לגלול, משמע שראסט עובר על המחסנית ומנקה את הדאטה של כל פונקציה שהיא פוגשת. אבל, פעולה זו והניקיון זה הרבה עבודה. לכן, ראסט מאפשרת לבחור באלטרנטיבה של *עצירה מיידית*, דבר שמייד יסיים את ריצת התכנית ללא פעולות ניקוי.
> 
> על מערכת ההפעלה יהיה לנקות את הזיכרון בו התכנית השתמשה. אם, בפרוייקט שלכם, אתם רוצים שגודל הבינרי יהיה קטן ככל שניתן, תוכלו לעבור מגלילה לעצירה מוחלטת בעקבות פאניקה על-ידי הוספת `panic = 'abort'` לסעיפי ה- `[profile]` הרולוונטים של קובץ ה-*Cargo.toml*. לדוגמא, אם אתם רוצים לעצור לחלוטין במקרה של פאניקה במצב release, הוסיפו את הטקסט:
> 
> ```toml
> [profile.release]
> panic = 'abort'
> ```

הבה ננסה לקרוא ל-`panic!` מתוך תכנית פשוטה:

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}
```

כאשר תריצו את התכנית, תראו משהו כמו:

```console
{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}
```

הקריאה ל-`panic!` מדפיסה את הודעת השגיאה שבשתי השורות האחרונות. השורה הראשונה מראה את הודעת הפאניקה שלנו ואת המיקום בקוד שלנו בו ארעה הפאניקה: *src/main.rs:2:5* מציין שמדובר בשורה השניה, התו החמישי בקובץ *src/main.rs*.

במקרה זה, השורה המצויינת היא חלק מהקוד שלנו, ואם נלך לשורה זו, נראה את הקריאה למאקרו `panic!`. במקרים אחרים, הקריאה ל- `panic!` יכולה להיות בקוד אחר שהקוד שלנו משתמש בו, ושם הקובץ ומספר השורה שידווחו בהודעת השגיאה יהיו של המיקום בקוד של מישהו אחר בו הקריאה ל- `panic!` בוצעה, ולא השורה בקוד שלנו שהובילה, בסופו של דבר, לקריאה ל- `panic!`. ניתן להשתמש במעקב לאחור (backtrace) של הפונקציות מהן הקריאה ל- `panic!` הגיעה כדי להבין איזה חלק של הקוד שלנו גרם לבעיה. כעת נדון במעקב לאחור ביתר פירוט.

### שימוש במעקב לאחור של `panic!`

הבה נתבונן בדוגמא נוספת כדי לראות מה קורה כאשר קריאה ל-`panic!` מגיעה מספריה בעקבות באג בקוד שלנו, ולא בעקבות קריאה ישירה למאקרו. ברשימה 9-1 יש קוד שמנסה לגשת מיקום בווקטור שנמצא מעבר לתחום הערכים התקף.

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}
```


<span class="caption">רשימה 9-1: ניסון לגשת לפריט מעבר לסוף הווקטור, דבר שיגרום לקריאה ל-`panic!`</span>

כאן, אנו מנסים לגשת לפריט ה-100 בווקטור (שנמצא באינדקס 99 כיוון שאינדקסציה מתחילה באפס), אבל בווקטור יש רק שלושה פריטים. במקרה זה, ראסט תיכנס לפאניקה. שימוש ב- `[]` אמור להחזיר פריט, אבל אם מעבירים אינדקס לא תקף, אז פשוט אין פריט שראסט יכולה להחזיר.

בשפה C, ניסיון לקרוא מעבר לסוף של מבנה נתונים מוביל להתנהגות לא מוגדרת. יתכן ותקבלו דבר מה שממוקם בזיכרון במקום שהיה מותאם לפריט כלשהו לו מבנה הנתונים היה ארוך יותר, למרות שהזיכרון כלל לא שייך למבנה הנתונים. לזה קוראים *buffer overread*, וזה יכול להוביל לרגישות בבטיחות במידה ותוקף יהיה מסוגל לתמרן את האינדקס בצורה כזו שתיווצר גישה לדאטה רגיש שממוקם מחוץ למבנה הנתונים.

כדי להגן אל תכניתחם מסוג זה של פעילות עויינת, אם תנסו לקרוא פריט באינדקס שלא קיים, ראסט תעצור את ההרצה ותסרב להמשיך. הבה ננסה וניווכח:

```console
{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}
```

שגיאה זו מצביע על שורה 4 בקובץ `main.rs` בה אנו מנסים לגשת לאינדקס
99. השורה הבאה אומרת לנו שאנחנו יכולים להשתמש במשתנה הסביבתי `RUST_BACKTRACE` על מנת מעקב לאחור שיראה בדיוק מה הארועים שהובילו לשגיאה. *מעקב לאחור* הוא רשימה של הפונקציות שנקראו והובילו לנקודה זו. מעקב לאחור בראסט עובד כמו בשפות אחרות: המפתח לקריאה מועילה של המעקב לאחור הוא להתחיל מההתחלה ולסרוק עד שמגיעים לקבצים שאתם כתבתם. זו הנקודה בה הבעיה התחילה. השורות מעל נקודה זו הן קוד בו הקוד שלנו עשה שימוש; השורות שמתחת הן קוד שקרא לקוד שלנו. השורות האלה, של לפני ואחרי, יכולות לכלול קוד ליבה של ראסט, קוד מהספריה הסטנדרטית, או מכולות בהן אתם משתמשים. הבה ננסה לקרוא מעקב לאחור על-ידי שימוש בערך שאינו אפש עבור המשתנה הסביבתי `RUST_BACKTRACE`. רשימה 9-2 מציגה פלט דומה למה שתראו.

<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->

```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```


<span class="caption">רשימה 9-2: המעקב לאחור שנוצר מקריאה ל-`panic!` שמוצג כאשר מציבים ערך עבור המשתנה הסביבתי `RUST_BACKTRACE`</span>

יש די הרבה מה לקרוא! הפלט המדויק שאתם תראו יכול להיות שונה בתלות במערכת ההפעלה שלכם ובגרסת ראסט בה אתם משתמשים. בכדי לקבל מעקב לאחור עם מידע זה, חייבים לאפשר סימולי דה-באג. סימולי דה-באג זמינים כברירת מחדל כאשר משתמשים ב- `cargo build` או ב- `cargo run` ללא הדגל `--release`, כפי שאנו עושים כאן.

בפלט ברשימה 9-2, שורה 6 של המעקב לאחור מצביעה לשורה בפרוייקט שלנו שגורמת לבעיה: שורה 4 בקובץ *src/main.rs*. אם אנחנו לא רוצים שהתכנית שלנו תיכנס לפאניקה, אנחנו צריכים להתחיל את מלאכת איתור הבעיה במיקום אליו מצביעה השורה הראשונה שמזכירה קובץ שאנו כתבנו. ברשימה 9-1, שם כתבנו בכוונה קוד שניכנס לפאניקה, הדרך להימנע מפאניקה היא לא לגשת לפריט במיקום שמחוץ לטוו האינדקסים של הווקטור. כאשר הקוד שלכם יכנס לפאניקה בעתיד, תצטרכו להבין באיזו פעולה הקוד נוקט, ועם אלו ערכים, שגורם לפאניקה, ומה הדרך לתקן את הקוד.

נחזור למאקרו `panic!`, ונדון מתי ראוי ומתי לא ראוי להשתמש בו כדי לנהל מצבי שגיאה, בסעיף ["להיכנס לפאניקה, כן או לא?"]()<!-- ignore --> מאוחר יותר בפרק זה. כעת, נעבור לדון בדרכים להתמודד עם שגיאות באמצעות הטיפוס `Result`.
ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
