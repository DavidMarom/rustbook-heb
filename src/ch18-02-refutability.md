## ניתנות להפרכה: האם התאמה מול תבנית יכולה להיכשל

תבניות באות בשתי צורות: שניתנות להפרכה ושאינן תיתנות להפרכה. תבנית שמובטח שתותאם על כל ערך שהוא, נקראת תבנית *לא ניתנת להפרכה*. דוגמא לכך היא התבנית `x` בפקודה `let x = 5;` מכיוון ש- `x` מתאים לכל דבר שהוא ולכן התאמה לא יכולה להיכשל. תבנית שכן יכולה להיכשל עבור לפחות ערך אחד נקראת תבנית *ניתנת להפרכה*. דוגמא לכך היא התבנית `Some(x)` בביטוי `if let Some(x) =
a_value` משום שאם הערך במשתנה `a_value` הוא `None` ולא `Some`, התבנית `Some(x)` לא תותאם.

פרמטרים לפונקציות, פקודות `let`, ולולאות `for` יכולים לקבל אך ורק תבניות לא ניתנות להפרכה. זאת מכיוון שהתכנית לא יכולה להמשיך לזרום במקרה שאין התאמה. הביטויים `if let` ו- `while let` יכולים לקבל גם תבניות ניתנות להפרכה וגם כאלה שאינן, אבל הקומפיילר יספק אזהרה אודות שימוש בתבנית לא ניתנת להפרכה כי, מעצם תפקידם, הם אמורים לטפל בכשלונות אפשריים: הפונקציונאליות של התניה נמצאת ביכולת לפעול בצורות שונות בתלות בהצלחה או כישלון.

באופן כללי, אין צורך לדאוג בקשר להבחנה בין תבניות ניתנות להפרכה לכאלה שאינן ניתנות להפרכה; אולם, יש להכיר את המונחים האלה כדי להיות מסוגלים להגיב היטב במקרה של שגיאות. במקרים כאלה, יהיה צורך לשנות או את התבנית או את הבניה הרלוונטית לתבנית, בתלות בהתנהגות הרצויה מהקוד.

הבה נתבונן בדוגמא שמראה מה יכול להתרחש כאשר מנסים להשתמש בתבנית ניתנת להפרכה במקום בו ראסט דורשת תבנית לא ניתנת להפרכה, ולהיפך. רשימה 18-8 מציגה פקודת `let`, אבל התבנית המסופקת היא `Some(x)`, שהיא ניתנת להפרכה. כצפוי, קוד זה לא עובר קומפילציה.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-08/src/main.rs:here}}
```


<span class="caption">רשימה 18-8: ניסיון להשתמש בתבנית ניתנת להפרכה עם פקודת `let`</span>

אם `some_option_value` היה הערך `None`, לא יהיה ניתן להתאים אותו לתבנית `Some(x)`, זאת אומרת שהתבנית ניתנת להפרכה. אבל, פקודת `let` יכולה לקבל אך ורק תבניות לא ניתנות להפרכה היות ואין שום פעולה תקינה שהקוד יכול לבצע עם ערך `None`. בזמן הקומפילציה, ראסט תתלונן שניסינו להשתמש בתבנית ניתנת להפרכה במקום בו על התבנית להיות לא ניתנת להפרכה:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-08/output.txt}}
```

כיוון שלא מיצינו כל אפשרות תקינה לערך (ואין שום דרך לעשות זאת!) עבור התבנית `Some(x)`, ראסט צודקת להפיק שגיאת קומפילציה.

אם יש לנו תבנית ניתנת להפרכה במקום בו חייבים תבנית לא ניתנת להפרכה, נוכל לפתור זאת על-ידי שינוי הקוד שמשתמש בתבנית: במקום להישתמש ב- `let` נוכל להשתמש ב-`if let`. בצורה זו, אם התבנית לא מותאמת, הקוד פשוט ידלג על הקוד שבסוגריים המסולסלים, וכך מתאפשר לקוד להמשיך לזרום. רשימה 18-9 מציגה דרך לתקן את הקוד מרשימה 18-8.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-09/src/main.rs:here}}
```


<span class="caption">רשימה 18-9: שימוש ב-`if let` ובבלוק עם תבנית ניתנת להפרכה, במקום שימוש שגוי ב-`let`</span>

סיפקנו לקוד דרך להמשיך! קוד זה תקני לחלוטין, למרות שהמשמעות היא שלא ניתן להשתמש בתבנית לא ניתנת להפרכה ללא קבלת שגיאה. If we give `if
let` a pattern that will always match, such as `x`, as shown in Listing 18-10, the compiler will give a warning.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-10/src/main.rs:here}}
```


<span class="caption">רשימה 18-10: ניסיון להשתמש בתבנית לא ניתנת להפרכה עם `if let`</span>

ראסט מתלוננת שזה לא הגיוני להשתמש ב- `if let` עם תבנית לא ניתנת להפרכה:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-10/output.txt}}
```

מסיבה זו, זרועות התאמה חייבות להשתמש בתבניות ניתנות להפרכה, חוץ מהזרוע האחרונה, שעליה להשתמש בתבנית שחייבת להתאים לכל ערך אפשרי נותר. ראסט מאפשרת שימוש בתבנית לא ניתנת להפרכה ב-`match` בו יש רק זרוע אחת, אבל תחביר כזה אינו יעיל במיוחד וניתן להחליף אותו בפקודת `let` פשוטה יותר.

עכשיו, משאתם יודעים היכן להשתמש בתבניות ובינים את ההבדל בין תבניות ניתנות להפרכה לאלו שאינן ניתנות להפרכה, הבה נעבור על כל התחביר הקיים ליצירת תבניות.
