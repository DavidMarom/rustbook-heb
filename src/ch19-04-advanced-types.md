## נושאים מתקדמים אודות טיפוסים

למערכת הטיפוסים של ראסט ישנן כמה תכונות שכבר הזכרנו אבל שעוד לא דנו בהן. נתחיל בלדון בתבנית הטיפוס החדש באופן כללי תוך כדי פיתוח הבנה מדוע תבנית זו שימושית. משם נעבור לכינויי טיפוסים, תכונה דומה לטיפוסים חדשים אבל עם סמנטיקה מעט שונה. נדון גם בטיפוס `!` ובטיפוסים בעלי גודל דינמי.

### שימוש בתבנית הטיפוס החדש למטרת בטיחות טיפוסים ואבסטרקציה

> הערה: סעיף זה מניח שקראתם את הסעיף הקודם ["שימוש בתבנית הטיפוס החדש כדי לממש תכונות חיצוניות וטיפוסים חיצוניים".][using-the-newtype-pattern]<!-- ignore -->

תבנית הטיפוס החדש שימושית גם עבור מטלות מעבר לאלו בהן דנו עד כה, כולל כפיה סטטית שערכים אף-פעם לא מבולבלים וציון יחידות של ערך. ראיתם דוגמא לשימוש בתבנית הטיפוס החדש כדי לציין יחידות ברשימה 19-15: זכרו שהמבנים `Millimeters` ו- `Meters` עטפו ערכי `u32` בתוך טיפוס חדש. אם היינו כותבים פונקציה עם פרמטר מטיפוס `Millimeters`, לא היינו יכולים לקמפל תוכנית שבטעות היתה מנסה לקרוא לפונקציה עם ערך מטיפוס `Meters` או עם ערך `u32` פשוט.

ניתן גם להשתמש בתבנית הטיפוס החדש כדי ליצור אבסטרקציה של פרטי מימוש עבור טיפוס: הטיפוס החדש יכול לחשוף API ציבורי שונה מה-API של הטיפוס הפנימי.

טיפוסים חדשים יכולים גם להסתיר מימושים פנימיים. למשל, ניתן לספק טיפוס `People` כדי לעטוף `HashMap<i32, String>` שמאכסן מספר זהות של משתמש המשוייך לשמם. קוד שמשתמש ב-`People` יבוא במגע רק עם ה-API הפומבי שאנו מספקים, כמו מתודה להוספת שם, כמחרוזת, לאוסף ה-`People`; קוד זה לא יצטרך לדעת ששייכנו ערך `i32` לשמות באופן פנימי. תבנית הטיפוס החדש היא דרך קלת-משקל לאפסן ולהחביא פרטי מימושים, תכונה בה דנו בסעיף ["אפסון שמחביא פרטי מימושים"]()<!-- ignore -->
בפרק 17.

### יצירת שמות נרדפים לטיפוסים באמצעות כינויי טיפוסים

ראסט מספקת את היכולת להכריז על *כינוי טיפוס* על מנת לתת לטיפוס קיים שם אחר. לשם כך משתמשים במילת המפתח `type`. לדוגמא, ניתן ליצור את הכינוי `Kilometers` עבור הטיפוס `i32` כך:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:here}}
```

כעת, הכינוי `Kilometers` הוא *שם נרדף* עבור `i32`; שלא כמו `Millimeters` ו-`Meters`, טיפוסים בפני עצמם שיצרנו ברשימה 19-15, `Kilometers` אינו טיפוס בפני עצמו. ערכים מטיפוס `Kilometers` הם בדיוק כמו ערכים מטיפוס `i32`:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-04-kilometers-alias/src/main.rs:there}}
```

כיוון ש-`Kilometers` ו-`i32` הם אותו טיפוס, ניתן לחבר ערכים מטיפוסים אלה וניתן להעביר ערכי `Kilometers` לפונקציות שמקבלות פרמטרים מטיפוס `i32`. אבל, שימוש בטכניקה זו לא מגיע עם היתרון של בדיקת טיפוסים על-ידי הקומפיילר כמו שאנו מקבלים משימוש בתבנית הטיפוס החדש, כפי שראינו קודם. במילים אחרות, אם נערב ערכי `Kilometers` וערכי `i32` במקום כלשהו, הקומפיילר לא יתריע על כך כלל.

המניע העיקרי ליצרית שמות נרדפים לטיפוסים הוא הפחתת רפטטיביות. לדוגמא, יתכן שיש לנו טיפוס ארוך כמו:

```rust,ignore
Box<dyn Fn() + Send + 'static>
```

כתיבת טיפוס ארוך זה בחותמים של פונקציות ובביאורי טיפוסים לכל אורך הקוד יכולה להיות משימה מיגעת ומועדת לטעויות. דמיינו פרוייקט מלא בקוד כדוגמת הקוד ברשימה 19-24.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-24/src/main.rs:here}}
```

<span class="caption">רשימה 19-24: שימוש בטיפוס ארוך במקומות רבים</span>

כינוי טיפוס יהפוך קוד זה להרבה יותר קריא על-ידי הפחתת הרפטטיביות. ברשימה 19-25, הצגנו את הכינוי בשם `Thunk` עבור הטיפוס רב המלל והחלפנו את כל השימושים בטיפוס בכינוי המקוצר `Thunk`.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-25/src/main.rs:here}}
```


<span class="caption">רשימה 19-25: הכנסה לשימוש של כינוי הטיפוס `Thunk` כדי להפחית רפטטיביות</span>

קוד זה קל הרבה יותר גם לקריאה וגם לכתיבה! בחירה של שם בעל משמעות עבור כינוי טיפוס יכולה להבהיר את כוונת הקוד (*thunk* היא מילה עבור קוד שיוערך בעתיד, כך שזה שם מתאים עבור סגור מאוכסן).

כינויי טיפוסים נפוצים גם עם הטיפוס `Result<T, E>` כדי להימנע מרפטטיביות. התבוננו במודול `std::io` אשר בספריה הסטנדרטית. פעולות I/O בדרך-כלל מחזירות `Result<T, E>` לניהול מצבים בהם פעולות נכשלות. לספריה הסטנדרטית יש את המבנה `std::io::Error` שמייצג את כל שגיאות ה-I/O האפשריות. רבות מהפונקציות ב- `std::io` מחזירות `Result<T, E>` בהם חלק ה- `E` הוא `std::io::Error`, כמו, למשל, פונקציות אלה מהתכונה `Write`:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-05-write-trait/src/lib.rs}}
```

השימוש ב- `Result<..., Error>` חוזר על עצמו פעמים רבות. לכן, ב- `std::io` יש את הכרזת כינוי הטיפוס:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:here}}
```

מכיוון שהכרזה זו נמצאת במודול `std::io`, ניתן להשתמש בכינוי המוסמך לחלוטין `std::io::Result<T>`; זאת אומרת, טיפוס `Result<T, E>` שבו `E` הוא `std::io::Error`. חותמי הפונקציות של התכונה `Write` הופכות עכשיו להראות כך:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-06-result-alias/src/lib.rs:there}}
```

כינוי הטיפוס מסייע בשני אופנים: הוא הופך את הקוד קל יותר לכתיבה *והוא גם* נותן לנו ממשק עקבי לאורך כל השימוש ב-`std::io`. כיוון שזהו כינוי, זהו פשוט שם נוסף עבור הטיפוס `Result<T, E>`, ולכן ניתן להשתמש עליו בכל המתודות הזמינות לשימוש על `Result<T, E>`, וכן בתחביר יחודי כמו האופרטור `?`.

### הטיפוס Never שאף-פעם לא מחזיר

לראסט יש טיפוס מיוחד בשם `!` שידוע בעולם תורת הטיפוסים בשם *הטיפוס הריק* כיוון שאין לא כלל ערכים. אנו מעדיפים לקרוא לו בשם *טיפוס האף-פעם* בגלל שהוא משמש כטיפוס הערך החוזר בפונקציות שאף פעם לא חוזרות. הינה דוגמא:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-07-never-type/src/lib.rs:here}}
```

ניתן לקרוא קוד זה כאומר "הפונקציה `bar` מחזירה אף-פעם." פונקציות שמחזירות אף-פעם נקראות *פונקציות מתבדרות*. לא ניתן ליצור ערכים מטיפוס `!`, ולכן `bar` אף-פעם לא יכולה לחזור.

אבל איזה שימוש יכול להיות לטיפוס שלא ניתן להפיק אפילו לא ערך אחד שזה הטיפוס שלו? הזכרו בקוד מרשימה 2-5, שהוא חלק מתכנית משחק הניחוש; חלקו משוחזר כאן ברשימה 19-26.

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:ch19}}
```


<span class="caption">רשימה 19-26: ביטוי `match` עם זרוע שמסתיימת ב-`continue`</span>

בזמנו, דילגנו על כמה פרטים בקוד זה. בפרק 6, בסעיף ["המבנה התחבירי `match` לבקרת זרימה"]()<!-- ignore -->
, אמרנו שכל הזרועות בביטוי `match` חייבות להחזיר את אותו הטיפוס. אם כן, לדוגמא, הקוד הבא לא תקין:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-08-match-arms-different-types/src/main.rs:here}}
```

הטיפוס של `guess` בקוד זה יהיה צריך להיות גם שלם *וגם* מחרוזת, בעוד שראסט דורשת של- `guess` יהיה טיפוס יחיד מוגדר היטב. אז איזה טיפוס `continue` מחזיר? מדוע מותר, ברשימה 19-26, לנו להחזיר ערך מטיפוס `u32` מזרוע אחת ולסיים זרוע אחרת עם `continue`?

וודאי ניחשתם של- `continue` יש את הטיפוס `!`. זאת אומרת, כאשר ראסט מחשבת את הטיפוס של `guess`, היא מסתכלת על שתי הזרועות בביטוי ההתאמה, אחת מחזירה טיפוס `u32` והשניה `!`. כיוון של- `!` אף-פעם לא יכול להיות ערך קונקרטי, ראסט מחליטה שהטיפוס של `guess` הוא `u32`.

הדרך הפורמלית לתאר התנהגות זו היא שביטויים מטיפוס `!` יכולים להיות מומרים לכל טיפוס אחר. מותר לנו לסיים זרוע זו של ה- `match` עם `continue` משום ש-`continue` לא מחזירה ערך; במקום זאת, היא מעבירה את השליטה חזרה לראשית הלולאה, וכך במקרה של `Err` אנחנו אף-פעם לא מבצעים השמה של ערך ל-`guess`.

טיפוס האף-פעם שימושי גם עם המאקרו `panic!`. זכרו את הפונקציה `unwrap`, לה אנו קוראים על ערכי `Option<T>` כדי או להפיק ערך או להיכנס לפאניקה, שהינה הגדרתה:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-09-unwrap-definition/src/lib.rs:here}}
```

בקוד זה, מתרחשת אותה התופעה כמו בביטוי ה- `match` מרשימה 19-26: ראסט רואה של- `val` יש את הטיפוס `T` ול-`panic!` יש את הטיפוס `!`, ולכן התוצאה של ביטוי ה-`match` כולו היא `T`. קוד זה תקין משום ש-`panic!` לא מחזירה שום ערך; היא מסיימת את ריצת התכנית. במקרה של `None`, לא מוחזר ערך מ- `unwrap`, ולכן קוד זה תקני.

ביטוי נוסף אחרון מטיפוס `!` הוא לולאה:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-10-loop-returns-never/src/main.rs:here}}
```

כאן, הלולאה אף-פעם לא מסתיימת, ולכן `!` הוא טיפוס הערך של הביטוי. אבל, זה לא היה המקרה לו היינו מוסיפים פקודת `break`, שכן אז הלולאה היתה מסתיימת בהגיעה לפקודת ה- `break`.

### טיפוסים בעלי גודל דינמי והתכונה `Sized`

ראסט צריכה לדעת פרטים מסויימים בקשר לטיפוסים שלה, כמו כמה מקום בזיכרון להקצות עבור ערך מטיפוס זה או אחר. פרט זה משאיר פינה אחת במערכת הטיפוסים של ראסט מעט לוטה בערפל: הרעיון של *טיפוסים בעלי גודל דינמי*. טיפוסים אלה, שלפעמים גם קוראים להם *DST* או *טיפוסים ללא גודל (unsized types)*, מאפשרים כתיבת קוד תוך שימוש בערכים שגודלם ידוע רק בזמן הריצה.

הבה נתעמק בפרטים של הטיפוס `str`, שהוא בעל גודל דינמי, שכבר ראינו לכל אורך הספר. שימו לב, אכן, לא `&str` אלה הטיפוס `str` בפני עצמו הוא DST. אין דרך לדעת מה אורך המחרוזת עד לזמן הריצה, ולכן לא ניתן ליצור משתנה מטיפוס `str` או להעביר משתנה מטיפוס `str`. התבוננו בקוד הבא, שלא עובד:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}
```

ראסט צריכה לדעת כמה מקום בזיכרון להקצות עבור כל משתנה שהוא, וכל הערכים מאותו טיפוס חייבים להשתמש באותה כמות של זיכרון. אם ראסט היתה מאפשרת לנו לכתוב קוד זה, שני ערכי `str` אלה היו משתמשים בכמות שווה של זיכרון. אבל יש להם אורכים שונים: `s1` זקוקה ל-12 בייטים בעוד `s2` צריכה 15. זו הסיבה שלא ניתן ליצור משתנים המאכסנים טיפוסים בעלי גודל דינמי.

אז מה אפשר לעשות? במקרה זה, אתם כבר יודעים את התשובה: משנים את הטיפוסים של `s1` ו- `s2` ל-`&str` במקום `str`. זכרו מסעיף ["חיתוכי מחרוזת"][string-slices]<!-- ignore --> בפרק 14 שחיתוך, כמבנה נתונים, רק מאכסן את מיקום תחילת החיתוך ואת אורכו. כך שלמרות ש- `&T` הוא ערך יחיד שמאכסן את כתובת הזיכרון שבה `T` ממוקם, מופע של `&str` הוא *שתי פיסות מידע*: כתובת של `str` ואורך. לכן, כן ניתן לדעת את הגודל של ערך מטיפוס `&str` בזמן הקומפילציה: פעמיים הגודל של `usize`. זאת אומרת שאנחנו תמיד יודעים את הגודל של `&str`, ללא תלות באורך המחרוזת אליה הוא מפנה. באופן כללי, זוהי הדרך בה משתמשים בטיפוסים בעלי גודל דינמי בראסט: הם מכילים מעט יותר מטה-דאטס שמאכסן את הגודל של המידע הדינמי. כלל הזהב לעבודה עם טיפוסים בעל גודל דינמי הוא שתמיד צריך לאכסן טיפוסים בעלי גודל דינמי מאחורי מצביע מתאים.

ניתן לשלב את `str` עם מצביעים מסוגים שונים: למשל, `Box<str>` או `Rc<str>`. למעשה, ראיתם זאת כבר עם טיפוס אחר בעל גודל דינמי: תכונה. כל תכונה היא טיפוס בעל גודל דינמי אליו ניתן להתייחס באמצעות שם התכונה. בפרק 17, בסעיף ["שימוש באובייקטי תכונה שמאפשרים ערכים מטיפוסים שונים"]()<!--
ignore --> , הערנו שעל מנת להשתמש בתכונות כאובייקטי תכונה, חייבים לשים אותם מאחור מצביע, כמו 

`&dyn Trait` או `Box<dyn Trait>` (וכן `Rc<dyn
Trait>`).

על מנת לעבור עם טיפוסים בעלי גודל דינמי, ראסט מספקת את התכונה `Sized` על מנת לקבוע האם הגודל של טיפוס ידוע בזמן הקומפילציה. תכונה זו ממומשת אוטומטית עבור כל טיפוס שגודלו ידוע בזמן הקומפילציה. בנוסף, ראסט, באופן לא מפורש, מגבלה על `Sized` עבור כל פונקציה גנרית. זאת אומרת, הגדרת פונקציה גנרית כזאת:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}
```

מתפרשת למעשה כאילו כתבנו:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}
```

כברירת מחדל, פונקציות גנריות יעבדו אך ורק עם טיפוסים שגודלם ידוע בזמן הקומפילציה. אולם, ניתן להחליש דרישה זו על-ידי שימוש בתחביר המיוחד הבא:

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}
```

מגבלת תכונה על `?Sized` משמעה ש-`T` יכול להיות `Sized` ויכול גם שלא, ונוטציה גוברת על ברירת המחדל לפיה טיפוסים גנריים חייבים להיות בעלי גודל ידוע בזמן הקומפילציה. התחביר `?Trait` במשמעות זו זמין רק עבור `Sized` ולא לאף תכונה אחרת.

שימו לב גם שהחלפנו את הטיפוס של הפרמטר `t` מ- `T` ל-`&T`. כיוון שהטיפוס לא חייב לממש את `Sized`, עלינו להשתמש בו מאחורי מצביע כלשהוא. במקרה זה, בחרנו להשתמש בהפניה.

הנושא הבא הוא פונקציות וסגורים!
ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details ch06-02-match.html#the-match-control-flow-operator ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types

[string-slices]: ch04-03-slices.html#string-slices
[using-the-newtype-pattern]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
