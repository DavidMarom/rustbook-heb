## שלום קארגו!

קארגו (Cargo) הוא מערכת הבניה ומנהל החבילות של ראסט. רוב הרסטיונרים (Rustaceans) משתמשים בכלי זה על מנת לנהל את פרוייקטי הראסט שלהם מכיוון שקארגו מטפל בהרבה מטלות בשבילכם. למשל, בניית הקוד, הורדת ספריות עליהן הקוד מסתמך, ובניית ספריות אלה. (ספריות שהקוד שלכם צריך נקראות *תלותות *.)

לתוכנות ראסט הפשוטות ביותר, כמו אלו שכתבנו עד עכשיו, אין תלותות. אם היינו בונים את פרוייקט ה-"Hello, world!" עם קארגו, אז היה נעשה שימוש רק בחלק של קארגו שמטפל בבניית הקוד. ככל שתכתבו תוכנות ראסט מורכבות יותר, תתחילו להוסיף תלותות, ואם תתחילו פרוייקט דרך קארגו, אז הוספת תלותות תהיה קלה הרבה יותר לביצוע.

כיוון שהרוב העצום של פרוייקטי ראסט משתשמשים בקארגו, שאר הספר מניח שגם אתם משתמשים בקארגו. קארגו מותקנת כחלק מראסט, במידה והשתמשתם בהתקנה הרשמית כפי שהסברנו ב- [התקנה][installation]<!-- ignore --> בסעיף. אם התקנתם את ראסט בדרך אחרת, בדקו אם קארגו מותקנת ע"י הקלדת הפקודה הבאה בטרמינל:

```console
$ cargo --version
```

אם אתם מקבלים מספר גרסה, אז קארגו מותקן! אם אתם מקבלים שגיאה, כמו `command
not found`, קראו את התיעוד עבור אופן ההתקנה שאתם מבצעים בכדי לקבוע איך להתקין את קארגו בנפרד.

### יצירת פרוייקט עם קארגו

הבה ניצור פרוייקט חדש באמצעות קארגו ונראה כיצד זה שונה מפרוייקט ה-"Hello, world!" המקורי שלנו. נווטו חזרה אל תיקיית ה-*פרוייקטים * שלכם (או לתיקייה אחרת אם שם החלטתם לאכסן את הקוד). עכשיו, לא משנה באיזו מערכת הפעלה אתם משתמשים, הריצו את הפקודות:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

הפקודה הראשונה יוצרת תיקייה חדשה ופרוייקט בשם *hello_cargo*. לפרוייקט שלנו קראנו *hello_carog*, וקארגו מייצר את הקבצים שלו בתיקייה בעלת אותו שם.

היכנסו לתיקייה *hello_cargo* וסרקו את הקבצים ששם. תראו שקארגו ייצר שני קבצים ותיקייה נוספת עבורנו: הקובץ *Cargo.toml* והתיקייה *src*, ובתוכה הקובץ *main.rs*.

בנוסף, בוצע אתחול של מאגר Git ביחד עם קובץ *.gitignore*. קבצי Git לא ייוצרו במידה ותריצו `cargo new` בתוך מאגר Git קיים; ניתן לעקוף ברירת מחדל זו ע"י הרצת `cargo new --vcs=git`.

> הערה: Git הינו מערכת בקרת גרסאות נפוצה. ניתן לשנות את פקודת ה-`cargo new` בכדי להשתמש במערכת בקרת גרסאות אחרת, או לוותר על מערכת כזו, ע"י שימוש בדגל `--vcs`. הריצו `cargo new --help` כדי לראות את כל האפשרויות.

פתחו את *Cargo.toml* באדיטור החביב עליכם. תראו משהו דומה לכתוב ברשימה 1-2.

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```


<span class="caption">רשימה 1-2: תוכן הקובץ *Cargo.toml* שנוצר בעקבות הרצת `cargo new`</span>

הפורמט של קובץ זה הוא [*TOML*][toml]<!-- ignore --> (*Tom's Obvious Minimal Language*), שהוא פורמט הקונפיגורציה של קארגו.

השורה הראשונה, `[package]`, היא כותרת סעיף המציינת שההוראות הבאות מתאמות חבילה. כאשר נוסיף עוד מידע לקובץ, נוסיף עוד סעיפים.

שלושת השורות הבאות מספקות לקארגו מידע הנחוץ לו בכדי לקמפל את התוכנית: השם, הגרסה, והמהדורה של ראסט. נדבר על מילת המפתח `edition` [בנספח ה'][appendix-e]<!-- ignore -->.

השורה האחרונה, `[dependencies]`, היא תחילת הסעיף המיועד להזנת תלותות הפרוייקט שלכם. בראסט, חבילות קוד נקראות *מכולות* (crates). לא נזדקק למכולות נוספות בפרוייקט זה, אבל בפרק 2 תהיה לנו הזדמנות לעשות זאת, ואז נחזור לסעיף התלותות.

כעת, פתחו את הקובץ *src/main.rs*:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

קארגו יצר עבורכם תוכנית "Hello, world!"', בדיוק כמו שכתבתם ברשימה 1-1! עד כאן, ההבדלים בין הפרוייקט שלנו והפרוייקט שקארגו יצר הם שקארגו מיקם את הקוד בתיקייה *src* ולנו יש את קובץ הקונפיגורציה *Cargo.toml* בתיקייה הראשית.

קארגו מצפה שקבצי הקוד שלכם יימצאו בתיקייה *src*. התיקייה המרכזית של הפרוייקט היא רק עבור קבצי README, רשיונות, קבצי קונפיגורציה, וכל דבר שאינו קשור לקוד. שימוש בקארגו מסייע בארגון פרוייקטים. יש מקום לכל דבר, וכל דבר נמצא במקומו.

אם התחלתם פרוייקט שלא באמצעות קארגו, כפי שעשינו בפרוייקט "Hello, world!"', תוכלו להמיר אותו לפרוייקט המנוהל ע"י קארגו. העבירו את קוד הפרוייקט לתוך התיקייה *src* וצרו קובץ *Cargo.toml* מתאים.

### הניה והרצה של פרוייקט קארגו

הבה הראה מה נשתנה כאשר בונים ומריצים את תכנית ה-"Hello, world!" דרך קארגו! מתוך התיקייה *hello_cargo*, בנו את הפרוייקט ע"י הקלדת הפקודה:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

פקודה זו יוצרת קובץ הרצה בתיקייה *target/debug/hello_cargo* (או ב-*target\debug\hello_cargo.exe* על Windows) במקום בתיקיה הנוכחית. בגלל שברירת המחדל היא בניה במצב debug, קארגו ממקם את הקבצים הבינארים בתיקייה בשם *debug*. את קובץ ההרצה תוכלו להריץ עם הפקודה:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

אם הכל הולך כשורה, `Hello, world!` יודפס על המסך. הרצת `cargo build` בפעם הראשונה גם גורם לקארגו ליצור קובץ חדש בתיקייה המרכזית: *Cargo.lock*. קובץ זה עוקב אחר הגרסאות המדוייקות של התלותות בפרוייקט. בפרוייקט זה אין תלותות, ולכן קובץ זה דל למדי. אין צורך לשנות קובץ זה ידנית; קארגו מנהל את תוכנו עבורכם.

אם כן, בנינו פרוייקט תוך שימוש ב-`cargo build` והרצנו אותו עם `./target/debug/hello_cargo`, אבל ניתן גם להשתמש ב-`cargo run` כדי לקמפל את הקוד ולהריץ את קובץ ההרצה בפקודה אחת:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

נוח להשתמש ב-`cargo run` כי אז אין צורך לזכור להריץ `cargo build` ואח"כ להשתמש במסלול המלא אל הקובץ הבינארי, ולכן רוב המפתחים משתמשים ב-`cargo run`.

שימו לב שהפעם לא התקבלו הודעות שקארגו ביצע קימפול `hello_cargo`. קארגו הבין שהקבצים לא שונו, ולכן הוא לא היה צריך לבנות שוב, אלא רק להריץ. אם הייתם משנים את קוד המקור, אז קארגו היה בונה מחדש את הפרוייקט לפני ההרצה, והייתם רואים את הפלט:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

קארגו גם מספק את שורת הפקודה `cargo check`. פקודה זו בודקת במהירות את הקוד על מנת לוודא שהוא עובר קומפילציה, ללא בניית קובץ הרצה:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

מדוע שלא תרצו קובץ הרצה? לרוב, `cargo check` הרבה יותר מהיר מ-`cargo build` משום שהוא מדלג על שלב ייצור קובץ ההרצה. אם אתם בודקים את עבודתכם באופן תדיר בזמן כתיבת קוד, שימוש ב-`cargo check` יאיץ את תהליך הווידוא שהקוד עובר קומפילציה! לכן, רסטיונרים רבים מריצים `cargo check` בקביעות בעודם כותבים תכניות, על מנת לוודא מעבר קומפילציה. את `cargo build` הם מריצים כאשר הם מוכנים להשתמש בקובץ ההרצה.

הבה נסכם את שלמדנו עד כה על קארגו:

* ניתן ליצור פרוייקט באמצעות `cargo new`.
* ניתן לבנות פרוייקט באמצעות `cargo build`.
* ניתן לבנות ולהריץ פרוייקט בצעד אחד באמצעות `cargo run`.
* ניתן לבנות פרוייקט ללא בניית קובץ בינארי על מנת לבדוק שגיאות ע"י באמצעות `cargo check`.
* במקום לשמור את תוצאת הבניה באותה תיקייה בה הקוד מאוכסן, קארגו שומר אותה בתיקייה *target/debug*.

יתרון נוסף לשימוש בקארגו הוא ששמות הפקודות אינן תלויות במערכת ההפעלה שלכם. לכן, מנקודה זאת, נפסיק לספק הוראות ספציפיות ל-Linux ו-macOS לעומת Windows.

### בניה להפצה

כאשר הפרוייקט שלכם מוכן להפצה ניתן להשתמש ב-`cargo build --release` כדי לבצע קומפילציה עם אופטימיזציות. פקודה זו תיצור קובץ הרצה בתיקייה *target/release* במקום ב-*target/debug*. הקוד המופק תוך שימוש באופטימיזציות רץ מהר יותר, אבל הקומפילציה לוקחת יותר זמן. לכן יש שני אופני פעולה שונים: אחד לפיתוח, כאשר מעוניינים לבנות מהר ולעיתים תכופות, והשני כאשר מעוניינים לבנות תכנית סופית המיועדת לשימוש, לא תיבנה שוב ושוב, ושתרוץ הכי מהר שאפשר. אם אתם מודדים את מהירות ריצת הקוד שלכם וודאו להשתמש ב-`cargo build --release` ולמדוד את זמן הריצה של קובץ הריצה הנמצא ב-*target/release*.

### קארגו כקונבנציה

עבור פרוייקטים פשוטים קארגו אינו מספק ערך מוסף רב מעבר לשימוש ב-`rustc`, אבל ככל שהתכניות שלכם יהפכו מורכבות יותר כך יגדל ערכו של קארגו. ברגע שתכניות מערבות כמה קבצים או צורך בתלותות, הרבה יותר נוח לתת לקארגו לנהל את הבניה.

למרות הפשטות של הפרוייקט `hello_cargo`, הוא כבר משתמש ברוב הכלים האמיתיים בהם תשתמש במהלך קריארת הראסט שלכם. למעשה, על מנת לעבוד על כל פרוייקט קיים, ניתן לבצע את הפעולות הבאות על מנת להשיג את הקוד באמצעות גיט, להיכנס לתיקיית הפרוייקט, ולבנות:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

למידע נוסף אודות קארגו, פנו [לתיעוד][cargo] שלו.

## סיכום

אתם כבר בדרך הנכונה במסע לעבר שליטה בראסט! בפרק זה למדתם כיצד:

* להתקין את הגרסה היציבה החדשה ביותר של ראסט באמצעות `rustup`
* לעדכן לגרסה חדשה של ראסט
* לפתוח תיעוד המותקן לוקאלית
* לכתוב ולהריץ תוכנית "Hello, world!" באמצעות `rustc` ישירות
* ליצור ולהריץ פרוייקט חדש באמצעות הקונבנציות של קארגו

זה הזמן לבנות תכנית יותר משמעותית על מנת להתרגל לקרוא ולכתוב קוד ראסט. על כן, בפרק 2, נבנה תכנית המיישמם משחק ניחוש מספר. אם אתם מעדיפים להתחיל בלימוד כיצד עקרונות תכנות נפוצים מיושמים בראסט, קפצו לפרק 3 וחזרו אח"כ לפרק 2.

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
