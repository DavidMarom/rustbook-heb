## מהי בעלות?

*בעלות* (ownership) זה מקבץ כללים שקובעים איך תכניות ראסט מתנהלות עם הזיכרון. כל תכנית מחשב צריכה להתנהל מול זיכרון המחשב בזמן הריצה. לשפות מסויימות יש מאסף אשפה שבאופן תדיר מחפש פיסות זיכרון שכבר לא בשימוש בזמן שהתכנית רצה; בשפות אחרות זהו המתכנת שצריך להקצות ולשחרר זיכרון באופן מפורש. ראסט מיישמת גישה שלישית: הזיכרון מנוהל באמצעות מערכת של בעלות שנתונה ע"י מקבץ כללים שהקומפיילר יכול לוודא. אם אחד מהכללים מופר, אז התכנית לא תעבור קומפילציה. אף אחת מהתכונות של בעלות לא מאטה את זמן הריצה של התכנית.

בגלל שבעלות היא מושג חדש עבור מתכנתים רבים, לוקח זמן מה כדי להתרגל אליו. החדשות הטובות הן שככל שהמיומנות שלכם בראסט ובכללי מערכת הבעלות תגדל, יהיה לכם קל יותר לפתח בטבעיות קוד שהוא גם בטוח וגם יעיל. כל שעליכם לעשות הוא להתמיד!

התמעת מושג הבעלות תהווה עבורכם יסוד איתן להבנת תכונות של ראסט שמייחדות אותה ביחס לשפות אחרות. בפרק זה תלמדו על בעלות באמצעות כמה דוגמאות המתמקדות בטיפוס דאטה מאוד נפוץ: המחרוזת.

> ### המחסנית והערימה
> 
> שפות תכנות רבות לא דורשות ממכם, לרוב, לחשוב על המחסנית והערימה. אבל, בשפת תכנות מערכות, כמו ראסט, אם ערך מאוכסן על המחסנית או בערימה משפיע על הדרך בה השפה מתנהגת ולכן חשוב לקבלת החלטות כמתכנת. חלקים מהנושא של בעלות יידונו בהקשר של המחסנית והערימה מאוחר יותר בפרק זה, לכן כאן, כהכנה, ניתן רק הסבר קצר.
> 
> גם המחסנית וגם הערימה מהוות חלק מהזיכרון הזמין לשימוש הקוד שלכם בזמן הריצה, אבל הן מאורגנות בדרכים שונות. המחסנית מאכסנת ערכים בסדר בה הם מועברים אליה, ומוציאה ערכים בסדר ההפוך. לגישת אכסון זו קוראים *נכנס אחרון, יוצא ראשון*. חשבו על מחסנית של אקדח: הכדורים שנדחפו אחרונים למחסנית יהיו אלו שיצאו ראשונים כאשר מרוקנים את המחסנית. הוספת והוצאת כדורים מאמצע או מתחתית המחסנית אינה אפשרית! הוספת דאטה נקראת *דחיפה למחסנית*, והוצאת דאטה נקראת *הקפצה מהמחסנית*. כל פיסת דאטה המאוכסנת על המחסנית חייבת להיות בעלת גודל ידוע ומקובע. דאטה שגודלו לא ידוע בזמן הריצה, או שגודלו יכול להשתנות, חייב להיות מוגדר בערימה.
> 
> הערימה היא מבנה פחות מאורגן: כאשר מוסיפים דאטה לערימה, מתבצעת בקשה לכמות מסוימת של מקום. ספק הזיכרון מוצא מקום ריק בערימה שהוא גדול דיו, מסמן אותו שהוא בשימוש, ומחזיר מצביע (*pointer*), שהוא הכתובת של המיקום בזיכרון. תהליך זה נקרא *הקצאה בערימה* (allocating on the heap) ולפעמים מקצרים ופשוט אומרים *הקצאה* (דחיפת ערכים למחסנית אינה נחשבת הקצאה). בגלל שהמצביע לערימה הוא בעל גודל ידוע וקבוע, ניתן לאכסן את המצביע על המחסנית, אבל כאשר רוצים לגשת אל הדאטה עצמו, חייבים לעקוב אחר המצביע. חשבו על הושבה במסעדה. כאשר אתם נכנסים, אתם מציינים את מספר הסועדים בקבוצה שלכם, ואז המארחים שלכם מוצאים שולחן ריק עם מספיק כיסאות, ולוקחים אתכם אליו. אם מישהו מהקבוצה שלכם מגיע באיחור, הם יכולים לשאול איפה השולחן שהקצו לכם, ולהצטרף.
> 
> דחיפה למחסנית היא פעולה מהירה יותר מהקצאה בערימה משום שאין צורך לחפש מקום אכסון לדאטה חדש; המיקום הוא תמיד בראש המחסנית. להשוואה, הקצאת מקום בערימה דורשת יותר עבודה כי צריך קודם למצוא איזור גדול מספיק בזיכרון כדי להחזיק את כל הדאטה, ולבצע עבודת רישום (bookkeeping) כדי להתכונן להקצאה הבאה.
> 
> גישה לדאטה בערימה איטי יותר מגישה לדאטה במחסנית משום שצריך לעקוב אחר מצביע כדי להגיע לדאטה. תהליכים מודרניים מהירים יותר ככל שהם צריכים לקפוץ פחות בזיכרון. אם נמשיך את האנלוגיה, חשבו על מלצר במסעדה שלוקח הזמנות משולחנות רבים. הדרך היעילה לעשות זאת היא לקחת את כל ההזמנות משולחן אחד לפני שעוברים לשולחן הבא. לקיחת הזמנה משולחן א', ואז משולחן ב', אז שוב מ-א', ואח"כ שוב מ-ב' תאט את התהליך. באופן דומה, תהליך יכול לבצע את עבודתו ביעילות רבה יותר אם הדאטה שהוא עובד איתו מרוכז כולו בקרבת מקום (כמו שקורה במחסנית) מאשר אם הדאטה נמצא במקומות מרוחקים (כפי שיכול לקרות בערימה).
> 
> כאשר הקוד שלכם קורה לפונקציה, הערכים המועברים לפונקציה (כולל, פוטנציאלית, מצביעים לדאטה על המחסנית) והמשתנים הלוקאלים של הפונקציה נדחפים למחסנית. כאשר הפונקציה מסתיימת, ערכים אלו מוקפצים אל מחוץ למחסנית.
> 
> המעקב אחר אלו חלקים של הקוד משתמשים בדאטה בערימה, מינימיזציה של כמות כפילות הדאטה בערימה, ושחרור של דאטה בערימה שלא בשימוש כדי שהזיכרון לא יגמר, הן כולן בעיות אליהן עקרון הבעלות מתייחס. ברגע שתבינו את יסודות הבעלות, לא תצטרכו לחשוב על המחסנית והערימה יותר מידי. ההבנה שהתפקיד המרכזי של בעלות הוא לנהל דאטה בערימה יכולה לסייע להסביר מדוע היא עובדת כמו שהיא עובדת.

### כללי בעלות

ראשית, הבה נתבונן בכללי הבעלות. זכרו כללים אלה בעודנו עוברים על הדוגמאות המדגימות אותם:

* לכל ערך ברסט יש בעל (owner).
* לכל ערך יש בדיוק בעל אחד בכל זמן נתון.
* כאשר הבעל יוצא מחוץ למתחם, הערך נעזב (dropped).

### המתחם של משתנה

כעת משיסודות התחביר של ראסט מאחורנו, לא נטרח לכתוב קוד כמו `fn main() {` בדוגמאות. לכן, בהנחה שאתם עוקבים ברצינות, וודאו למקם את הקוד בדוגמאות הבאות בתוך פונקציית `main`. כתוצאה מכך, הדוגמאות שלנו יהיה קצת יותר קצרות, מה שיאפשר לנו לנו להתמקד בפרטים המעניינים ולא בקוד סתמי (boilerplate code).

כדוגמא ראשונה לבעלות, נסתכל על *המתחם* של משתנים. המתחם הוא הטווח בתוך התוכנית בו אלמנט תקף. קחו למשל את המשתנה הבא:</p>

```rust
let s = "hello";
```

המשתנה `s` מתייחס למחרוזת מפורשת, וערך המחרוזת מובנה לתוך הטקסט של התכנית. המשתנה תקף מהנקודה בה הוא מוכרז עד לסוף *המתחם* הנוכחי. רשימה 4-1 מראה תכנית עם הערות המבארות היכן המשתנה `s` יהיה תקף.

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```


<span class="caption">רשימה 4-1: משתנה והמתחם בו הוא תקף</span>

במילים אחרות, יש פה שתי נקודות חשובות בזמן:

* מתי ש-`s` *נכנס* למתחם, ואז הוא תקף.
* הוא נשאר תקף עד שהוא *יוצא* מהמתחם.

בנקודה זאת הקשר בין מתחמים למתי משתנים הם זמינים דומה לזה שבשפות תכנות אחרות. כעת נבנה על הבנה זו ונציג את הטיפוס `String`.

### הטיפוס `String`

על מנת להדגים את כללי הבעלות אנו זקוקים לטיפוס דאטה יותר מורכב מאלו שפגשנו בסעיף ["טיפוסי דאטה"][data-types]<!-- ignore --> בפרק 3. הטיפוסים שכבר כיסינו הם בגודל ידוע, ניתנים לאכסון על המחסנית, ולכן ניתן להקפיץ אותם מחוץ למחסנית כאשר הם מגיעים לסוף המתחם שלכם, והם ניתנים להעתקה בקלות ובמהירות כדי ליצור מופעים חדשים ובלתי תלויים במידה וחלק אחר בקוד צריך להשתמש באותו ערך במתחם אחר. אבל אנחנו רוצים להתבונן בדאטה שמאוכסן בערימה ולראות כיצד ראסט יודעת מתי לשחרר הקצאות. הטיפוס `String` הוא דוגמא מצויינת בדיוק בשביל זה.

אנו נתרכז בחלקים של `String` שקשורים לבעלות. אספקטים אלה תקפים גם לטיפוסי דאטה מורכבים אחרים, בין אם הם מסופקים ע"י הספריה הסטנדרטית ובין אם אתם יצרתם אותם. אנו נדון ב- `String` יותר לעומק ב-[פרק 8][ch8]<!-- ignore -->.

במחרוזות מפורשות כבר נתקלנו, דהיינו כאשר הערך למחרוזת מקודד כחלק מהתכנית. מחרוזות מפורשות הן נוחות, אבל הן לא מתאימות לכל מצב בו נרצה להשתמש בטקסט. סיבה אחת לכך היא שהן מנועות-שינוי. סיבה אחרת היא שלא תמיד ניתן לדעת את הערך למחרוזת בזמן כתיבת התכנית: למשל, מה אם אנו רוצים לקבל קלט מהמשתמש? למצבים אלה לראסט יש טיפוס מחרוזת שני: `String`. טיפוס זה מנהל דאטה בערימה ולכן מסוגל לאכסן כמות של טקסט שאינה ידוע בזמן הקומפילציה. ניתן ליצור מופע של הטיפוס `String` ממחרוזת מפורשת ע"י שימוש בפונקציה `from`, כך:

```rust
let s = String::from("hello");
```

אופרטור הנקודותיים הכפולות `::` מאפשר לנו למקם את ה- `from` הספציפי הזה תחת הטיפוס `String` במקום להשתמש באיזשהו שם כמו `string_from`. אנו נדון עוד בתחביר זה בסעיף ["תחביר מתודות"][method-syntax]<!-- ignore --> בפרק 5, וכאשר נדבר על מיקומים (namepsacing) עם מודולים ב["מסלולים להפניה לאלמנט בעץ המודולים"][paths-module-tree]<!-- ignore --> בפרק 7.

סוג זה של מחרוזת *כן* ניתן לשינוי:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

אז, מה השוני כאן? מדוע ניתן לשנות משתנה מטיפוס `String` בעוד שערכים מפורשים לא ניתנים לשינוי? ההבדל נעוץ בדרך בה שני טיפוסים אלה מתנהלים מול הזיכרון.

### זיכרון והקצאות

במקרה של מחרוזת מפורשת, תוכן המחרוזת ידוע בזמן הקומפילציה, ולכן הטקסט מקודד ישירות לתוך קובץ ההרצה הסופי. זו הסיבה שמחרוזות מפורשות הן מהירות ויעילות. אבל מקור תכונות אלה נעוץ בכך שמחרוזות מפורשות הן מנועות-שינוי. לרוע המזל, לא ניתן לשים חתיכה של הזיכרון לתוך הקובץ הבינארי עבור כל פיסת טקסט שגודלה לא ידוע בזמן הקומפילציה ושגודלה יכול להשתנות במהלך ריצת התכנית.

עובר משתנים מטיפוס `String`, על מנת לתמוך בברות-שינוי ובפיסות טקסט שגודלן יכול להשתנות, עלינו להקצות כמות זיכרון בערימה שאינה ידועה בזמן הקומפילציה, על מנת לאכסן את התוכן. משמעות הדבר היא כי:

* צריך לבקש את הזיכרון בזמן הריצה.
* צריך לשחרר את הזיכרון כשאנחנו כבר לא צריכים את תוכן ה- `String`.

לחלק הראשון אנחנו אחראים: כאשר אנחנו קוראים למתודה `String::from`, היישום שלה מבקש את הזיכרון הנחוץ. גישה זו היא די אוניברסלית בקרב שפות תכנות.

אולם, החלק השני שונה. בשפות עם *מאסף אשפה* (garbage collector), מאסף האשפה עוקב אחר כל ההקצאות ומנקה זיכרון שכבר לא בשימוש, ואנחנו לא צריכים לחשוב על כך כלל. ברוב השפות ללא מאסף אשפה, זוהי האחריות שלנו לזהות מתי זיכרון כבר לא בשימוש ולקרוא לקוד לשחרור הזיכרון באופן מפורש, בדיוק כפי שעושים כשמבקשים להקצות זיכרון. ביצוע נכון של פעולות אלה היווה, באופן היסטורי, בעיית תכנות סבוכה. אם שוכחים לשחרר זיכרון, זה בזבוז. אם משחררים זיכרון מוקדם מידי, נקבל משתנה לא תקני. אם משחררים הקצאה פעמיים, זה גם באג. יש צורך לזווג בדיוק `allocate` אחד עם כל `free`, ולהיפך.

ראסט נוקטת בגישה שונה: ברגע שמשתנה יוצא מחוץ למתחם שלו, הזיכרון שבבעלותו משוחרר. הינה גרסה של דוגמת המתחם מרשימה 4-1 תוך שימוש ב-`String` במקום במחרוזת מפורשת:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

יש נקודה טבעית בה ניתן לשחרר את הזיכרון שה-`String` צורך: כאשר `s` יוצא מהמתחם. כאשר משתנה יוצא מהתמחם, ראסט קוראת עבורנו לפונקציה מיוחדת. פונקציה זו נקראת [`drop`][drop]<!-- ignore -->, וזה המקום בו הכותב של הטיפוס `String` יכול לכתוב את הקוד שמבצע את שחרור הזיכרון. ראסט קוראת ל- `drop` באופן אוטומטי בזמן סגירת הסוגר המסולסל.

> שימו לב: ב-++C, דפוס זה של שחרור משאבים בסוף הפז"מ (lifetime) של אלמנטים נקרא לעיתים *Resource Acquisition Is Initialization (RAII)*. הפונקציה `drop` בראסט תהיה מוכרת לכם אם אתם מכירים דפוסי RAII.

לדפוס זה יש השפעה עמוקה על דרך כתיבת קוד בראסט. זה אולי נראה פשוט כעת, אבל ההתנהגות של קוד יכולה להיות בלתי צפויה במקרים סבוכים יותר כאשר משתמשים בכמה משתנים שמתנהלים מול זיכרון המוקצה בערימה. הבה נתנסה בכמה מצבים כאלה עכשיו.

<!-- Old heading. Do not remove or links may break. -->
<a id="ways-variables-and-data-interact-move"></a>

#### אינטראקציה בין משתנים ודאטה באמצעות הזזה

יותר ממשתנה אחד יכול לבוא במגע עם אותו דאטה בדרכים שונות בראסט. הבה נראה דוגמא המשתמשת במשתנה מטיפוס מספר שלם ברשימה 4-2.

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```


<span class="caption">רשימה 4-2: השמת הערך השלם של המשתנה `x` ל-`y`</span>

אנחנו יכולים לנחש מה קורה כאן: "קשור את הערך `5` ל-`x`; ואז צור עותק של הערך ב- `x` וקשור אותו ל- `y`." עכשיו יש לנו שני משתנים, `x` ו-`y`, ושניהם שווים ל-`5`. זה אכן מה שקורה, כיוון ששלמים הם ערכים פשוטים בעלי גודל ידוע וקבוע, כך ששני ה-`5`-ים האלה נדחפים לתוך המחסנית.

הבה נתבונן כעת בגרסה עם הטיפוס `String`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```

הקוד נראה מאוד דומה, לכן ניתן לצפות שהוא יתנהג בצורה דומה: ז"א שהשורה השניה תיצור עותק של הערך ב- `s1` ותקשור אותו ל-`s2`. אבל פה זה לא מה שקורה.

התבוננו בתמונה 4-1 כדי להבין מה קורה ל- `String` במעמקי הזיכרון. מופע של `String` מורכב משלושה חלקים, אותם רואים משמאל: מצביע לזיכרון בו מאוכסן תוכן המחרוזת, אורך המחרוזת, וקיבולת המחרוזת. קבוצת הערכים האלה מאוכסנת במחסנית. מימין מוצג הזיכרון בערימה אשר מאכסן את התוכן.

<img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" />

<span class="caption">תמונה 4-1: הצגה בזיכרון של `String` המחזיק בערך `"hello"` ומקושר ל-`s1`</span>

האורך מאכסן את כמות הזיכרון, בבייטים, שתוכן ה-`String` תופס כרגע. הקיבולת מאכסנת את סך כל הזיכרון, בבייטים, שהוקצה ל-`String` בזיכרון. ההבדל בין האורך לקיבולת חשוב, אבל לא בקונטקסט הנוכחי. לכן, לבינתיים, זה בסדר להתעלם מהקיבולת.

כאשר אנו מבצעים השמה של `s1` ל-`s2`, הדאטה של ה-`String` מועתק, ז"א שאנו מעתיקים את המידע שנמצא במחסנית: המצביע, האורך, והקיבולת. אנחנו לא מעתיקים את הדאטה בערימה שאליו המצביע מצביע. במילים אחרות, ייצוג הדאטה בזיכרון נראה כמו בתמונה 4-2.

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap."
src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">תמונה 4-2: ייצוג בזיכרון של המשתנה `s2` שמכיל עותק של המצביע, האורך, והקיבולת של `s1`</span>

הייצוג *אינו* נראה כמו בתמונה 4-3, המראה כיצד הזיכרון היה נראה אילו ראסט היתה מעתיקה, בנוסף, את הדאטה מהערימה. לו ראסט היתה עושה כך, אז הפעולה `s2 = s1` היתה יכולה להיות יקרה מבחינת ביצועי זמן-ריצה במידה והדאטה בערימה היה גדול.

<img alt="Four tables: two tables representing the stack data for s1 and s2,
and each points to its own copy of string data on the heap."
src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">תמונה 4-3: אפשרות אחרת למשמעות ההשמה `s2 = s1` אם ראסט היתה מעתיקה דאטה מהערימה בנוסף לדאטה במחסנית</span>

מוקדם יותר, ראינו שכשמשתנה יוצא מהמתחם, ראסט אוטומטית קוראת לפונקציה `drop` אשר מנקה את הזיכרון בערימה המשוייך למשתנה. אבל תמונה 4-2 מראה ששני המצביעים מצביעים לאותו מקום. זו בעיה: כאשר `s2` ו- `s1` יוצאים מהמתחם, שניהם ינסו לשחרר את אותו מקום בזיכרון. בעיה זו נקראת בעיית *שחרור כפול* (double free) שהיא אחד מהבאגים הקשורים לבטיחות הקצאות זיכרון אותם הזכרנו בעבר. שחרור זיכרון פעמיים עלול להוביל להשחתת זיכרון, דבר שיכול להוביל לפגיעויות אבטחה.

כדי להבטיח בטיחות של הזיכרון, לאחר השורה `let s2 = s1;`, ראסט מחשיבה את `s1` כלא תקף. לכן, ראסט לא צריכה לשחרר שום דבר כאשר `s1` יוצא מהמתחם. בדקו מה קורה אם תנסו להשתמש ב- `s1` אחרי ש-`s2` נוצר; זה לא יעבוד:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

תקבלו הודעת שגיאה כמו ההודעה הבאה, כיוון שראסט מונעת ממכם מלהשתמש בהפניה הלא תקינה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

אם שמעתם על המושגים *העתקה רדודה* או *העתקה עמוקה* מעבודתכם בשפות אחרות, אז העיקרון של העתקת המצביע, האורך, והקיבולת ללא העתקת הדאטה, וודאי נשמע לכם כמו העתקה רדודה. אבל, בגלל שראסט גם מבטלת את המשתנה הראשון, במקום המונח העתקה רדודה, המינוח בראסט הוא *הזזה*. בדוגמא זו נאמר ש-`s1` *הוזז* ל-`s2`. וכך, מה שבאמת מתרחש מוצג בתמונה 4-4.

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.svg" class="center" style="width:
50%;" />

<span class="caption">תמונה 4-4: ייצוג בזיכרון לאחר ש-`s1` בוטל</span>

זה פותר את הבעיה שלנו! משרק `s2` פעיל, כאשר הוא ייצה מהמתחם הוא, ורק הוא, יבצע שחרור של הזיכרון, וסיימנו.

מהאמור לעיל נובעת בחירה תכנונית: ראסט לעולם לא תיצור באופן אוטומטי עותקים "עמוקים" של הדאטה שלכם. לכן, ניתן להניח שכל העתקה *אוטומטית* היא זולה מבחינת ביצועי זמן-ריצה.

<!-- Old heading. Do not remove or links may break. -->
<a id="ways-variables-and-data-interact-clone"></a>

#### אינטראקציה בין משתנים ודאטה באמצעות שיבוט

במידה ואנחנו *כן* מעוניינים ליצור עותק עמוק ע"י העתקת הדאטה המקושר למופע של `String` מהערימה, ולא רק מהמחסנית, נוכל להשתמש במתודה נפוצה הנקראת `clone`. נדון בתחביר של מתודות בפרק 5, אבל כיוון שמתודות הן מושג נפוץ בשפות תכנות רבות, סביר להניח שכבר נתקלתם בהן.

הינה דוגמא למתודה `clone` בפעולה:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

זה עובד מצוין ויוצר מפורשות את ההתנהגות המוצגת בתמונה 4-3, כאשר הדאטה בערימה *כן* הועתק.

כאשר רואים קריאה ל- `clone`, משמעות הדבר היא שקוד מסויים מבצע פעולה שעלולה להיות יקרה. כך הקריאה המפורשת הזו משמשת העדות וויזואלית לכך שדבר מה מתרחש. 

#### דאטה שכולו במחסנית: העתקה

ישנה עוד בעיה קטנה שעוד לא דיברנו עליה. הקוד הבא משתמש בשלמים -- וחלקו הוצג ברשימה 4-2 -- והוא עובד ותקין:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

אבל נראה שהקוד הזה סותר את מה שזה עתה למדנו: אנחנו לא קוראים ל-`clone`, ובכל זאת `x` עדיין תקף ולא הוזז ל-`y`.

הסיבה היא שטיפוסים כמו שלמים, שהם בעלי גודל ידוע בזמן הקומפילציה, מאוכסנים רק במחסנית. לכן העתקת הערכים עצמם נעשית במהירות. זאת אומרת שאין סיבה שנרצה למנוע מ-`x` מלהשאר תקף לאחר יצירת המשתנה `y`. במילים אחרות, אין הבדל בין העתקה עמוקה לרדודה במקרה זה, ולכן קריאה ל- `clone` לא תעשה שום דבר שונה בהשוואה להעתקה רדודה, ולכן אין בה צורך.

לראסט יש ביאור מיוחד הנקרא תכונת ה- `Copy` שניתנת לשימוש עם טיפוסים המאוכסנים במחסנית, כמו שלמים (נדון עוד בתכונות [בפרק 10][traits]<!-- ignore -->). אם טיפוס מיישם את התכונה `Copy`, אז משתנים שמשתמשים בו לא מוזזים, אלא מועתקים באופן טריוויאלי, וכך אם נשארים תקפים גם לאחר השמה למשתנה אחר.

ראסט לא תאפשר לנו לבאר טיפוס באמצעות `Copy` במידה והטיפוס, או כל חלק ממנו, יישם את התכונה `Drop`. אם הטיפוס דורש שמשהו מיוחד יקרה כאשר הערך יוצא מהמתחם ובכל זאת נוסיף ביאור `Copy` לטיפוס, אז נקבל שגיאת זמן קומפילציה. כדי ללמוד איך להוסיף ביאור `Copy` לטיפוסים משלכם כדי ליישם את התכונה, פנו ל-["תכונות נגזרות"][derivable-traits]<!-- ignore --> בנספח ג'.

אם כן, אלו טיפוסים מיישמים את התכונה `Copy`? תמיד תוכלו לבדוק את התיעוד עבור הטיפוס הנדון כדי להיות בטוחים, אבל באופן כללי, כל קבוצה של ערכים סקאלרים פשוטים יכולים ליישם את `Copy`, ואף טיפוס שדורש הקצאה או שהוא איזה סוג של משאב לא יכול ליישם את `Copy`. הינה כמה טיפוסים שמיישמים את `Copy`:

* כל טיפוסי השלמים, כמו `u32`.
* הטיפוס הבוליאני `bool`, בעל הערכים `true` ו- `false`.
* כל טיפוסי הנקודה הצפה, כמו `f64`.
* טיפוס התו `char`.
* רצפים, במידה והם רק מכילים טיפוסים שבעצמם מיישמים את `Copy`. למשל, `(i32, i32)` מיישם את `Copy`, אבל `(i32, String)` לא.

### בעלות ופונקציות

הפרטים הטכניים של העברת ערך לפונקציה דומים לאלה של השמת ערך למשתנה. העברת משתנה לפונקציה תגרום להזזה או להעתקה, בדיוק כמו בהשמה. ברשימה 4-3 יש דוגמא עם כמה ביאורים המראים היכן משתנים נכנסים ויוצאים מהמתחם.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```


<span class="caption">רשימה 4-3: פונקציות בתוספת ביאורי בעלות ומתחם</span>

אם היינו מנסים להשתמש ב- `s` אחרי הקריאה ל- `takes_ownership`, ראסט היתה נותנת לנו שגיאת זמן קומפילציה. בדיקות סטטיות אלה מגינות עלינו מטעויות. נסו להוסיף קוד ל-`main` שמשתמש ב- `s` וב-`x` כדי לראות איפה אתם יכולים להשתמש בהם והיכן כללי הבעלות מונעים ממכם לעשות זאת.

### ערכים חוזרים ומתחמים

החזרת ערכים יכולה גם להעביר בעלות. רשימה 4-4 מראה דוגמא של פונקציה שמחזירה ערך, בתוספת ביאורים דומים לאלה שברשימה 4-3.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```


<span class="caption">רשימה 4-4: העברת בעלות של ערכים מוחזרים</span>

הבעלות של משתנה עוקבת תמיד אחר אותה חוקיות: השמת ערך למשתנה אחר מזיזה אותו. כאשר משתנה שכולל דאטה בערימה יוצא מהמתחם, הערך ישוחרר ע"י `drop` אלא אם כן הבעלות על הדאטה הועברה למשתנה אחר.

בעוד שזה עובד היטב, לקיחת בעלות והחזרתה עם כל פונקציה היא דבר קצת מייגע. מה אם נרצה לאפשר לפונקציה להשתמש בערך אבל לא לקחת עליו בעלות? זה די מציק שכל מה שאנחנו מעבירים לפונקציה צריך להיות גם מוחזר, באם אנחנו רוצים להשתמש בו שוב, בנוסף לכל פיסת דאטה כתוצאה מקוד בגוף הפונקציה שייתכן שאנחנו גם רוצים להחזיר.

ראסט מאפשרת לנו להחזיר יותר מערך אחד תוך שימוש ברצף, כפי שרואים ברשימה 4-5.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

<span class="caption">רשימה 4-5: החזרת בעלות של פרמטרים</span>

אבל זה קצת יותר מידי מסורבל, ודי הרבה עבודה, בשביל מושג שצריך להיות נפוץ. למרבה המזל, ראסט מספקת את היכולת להשתמש במשתנה ללא העברת בעלות. יכולת זאת מסופקת באמצעות *הפניות* (references).

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
