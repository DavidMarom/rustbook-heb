04-01

## מהי בעלות?

_בעלות_ (ownership) היא מקבץ כללים הקובעים איך תכניות ראסט מנהלות את הזיכרון בו הן משתמשות. בזמן ריצה, כל תכנית מחשב דורשת משאבי זיכרון. לשפות מסויימות יש מאסף אשפה מובנה, שאחת לכמה זמן מאתר ומשחרר חלקות זיכרון שכבר לא נמצאות בשימוש; בשפות אחרות זהו המתכנת שצריך להקצות ולשחרר זיכרון באופן מפורש. ראסט נוקטת בגישה שלישית: השימוש במשאבי זיכרון מנוהל באמצעות מערכת של בעלות המוגדרת בהתאם למקבץ כללים אותם הקומפיילר מסוגל לוודא ולאכוף. אם אחד מהכללים מופר, התכנית לא תעבור קומפילציה. משום כך, אף אחת ממאפייני הבעלות לא מאטה את זמן הריצה של התכנית.

בגלל שבעלות היא מושג חדש עבור מתכנתים רבים, לוקח זמן מה כדי להתרגל אליו. החדשות הטובות הן שככל שהמיומנות שלכם בכללי מערכת הבעלות ובשפת ראסט תגדל, יהיה לכם קל יותר לפתח קוד שהוא גם בטוח וגם יעיל. כל שעליכם לעשות הוא להתמיד!

הפנמת מושג הבעלות תסייע לכם להבין חלק מתכונותיה של ראסט ההופכות אותה ליוצאת דופן ביחס לשפות אחרות. בפרק זה תלמדו על בעלות באמצעות כמה דוגמאות המתמקדות בטיפוס דאטה נפוץ: המחרוזת.

> ### המחסנית והערימה
>
> שפות תכנות רבות לא דורשות ממכם, לרוב, לחשוב על המחסנית והערימה. אבל, בשפת תכנות מערכות כגון ראסט, הסוגיה האם ערך מסוים מאוחסן בזיכרון המחסנית או בזיכרון הערימה משפיעה על האופן בו השפה מתנהגת, ולכן קריטי לתהליך קבלת ההחלטות שלכם כמתכנתים. היבטים של נושא הבעלות יידונו בהקשר של זיכרון המחסנית והערימה מאוחר יותר בפרק זה. כאן ניתן רק הסבר קצר.
>
> גם המחסנית וגם הערימה מהוות חלק מהזיכרון הזמין לשימוש הקוד שלכם בזמן ריצה, אבל הן מאורגנות בדרכים שונות. המחסנית מאחסנת ערכים בסדר בה הם מועברים אליה, ומוציאה ערכים בסדר ההפוך. לגישת אחסון זו קוראים _נכנס אחרון, יוצא ראשון_. חשבו על מחסנית של אקדח: הכדורים שנדחפו אחרונים למחסנית יהיו אלו שיצאו ראשונים. הוספת והוצאת כדורים מאמצע או מתחתית המחסנית אינה אפשרית! הוספת דאטה נקראת _דחיפה למחסנית_, והוצאת דאטה נקראת _הקפצה מהמחסנית_. כל פיסת דאטה המאוכסנת על זיכרון המחסנית חייבת להיות בעלת גודל ידוע ומקובע. דאטה שגודלו לא ידוע בזמן הריצה, או שגודלו יכול להשתנות, חייב להיות מוגדר בזיכרון הערימה.
>
> הערימה היא מבנה פחות מאורגן: כאשר מוסיפים דאטה לערימה, מתבצעת בקשה להקצאת כמות מסוימת של מקום. ספק הזיכרון מוצא מקום ריק בערימה שהוא גדול דיו, מסמן אותו כנמצא בשימוש, ומחזיר מצביע (_pointer_), שאינו אלא הכתובת של אותה חלקת זיכרון. תהליך זה נקרא _הקצאה בערימה_ (allocating on the heap) ולפעמים מקצרים ופשוט אומרים _הקצאה_ (דחיפת ערכים למחסנית אינה נחשבת הקצאה). כיוון שהמצביע לערימה הוא בעל גודל ידוע וקבוע, את המצביע עצמו ניתן לאחסן על המחסנית. אבל כאשר רוצים לגשת אל הדאטה עצמו, חייבים לעקוב אחר המצביע. חשבו על הושבה במסעדה. כאשר אתם נכנסים, אתם מציינים את מספר הסועדים בקבוצה שלכם, ואז המארחים שלכם מוצאים שולחן ריק עם מספיק כיסאות, ולוקחים אתכם אליו. אם מישהו מהקבוצה שלכם מגיע באיחור, הם יכולים לשאול איפה השולחן שהקצו לכם, ולהצטרף אליו. ללא מידע זה, המאחר לא יידע כיצד למצוא אתכם.
>
> דחיפה למחסנית היא פעולה מהירה יותר מהקצאה בערימה משום שאין צורך לחפש מקום אחסון לדאטה חדש; המיקום הוא תמיד בראש המחסנית. להשוואה, הקצאת מקום בערימה דורשת יותר עבודה כי צריך קודם למצוא איזור גדול מספיק בזיכרון כדי להחזיק את כל הדאטה, ולבצע במקביל עבודת רישום (bookkeeping) כדי להתכונן להקצאת הזיכרון הבאה.
>
> גישה לדאטה הנמצא בערימה איטי יותר מגישה לדאטה במחסנית משום שצריך לעקוב אחר מצביע כדי להגיע לדאטה. ככלל, תהליכים מודרניים מהירים יותר ככל שהם ממעטים בניסיונות גישה לזיכרון. אם נמשיך את האנלוגיה שהצגנו, חשבו על מלצר במסעדה שלוקח הזמנות משולחנות רבים. הדרך היעילה לעשות זאת היא לקחת את כל ההזמנות משולחן אחד לפני שעוברים לשולחן הבא. בניגוד לכך, לקיחת הזמנה משולחן א', ואז משולחן ב', אז שוב מ-א', ואח"כ שוב מ-ב' תאט את התהליך כולו.
> באופן דומה, תהליך יכול לבצע את עבודתו ביעילות רבה יותר אם הדאטה הדרוש לו מקובץ כולו במקום אחד (כמו שקורה במחסנית) מאשר אם יהיה מפוזר במקומות מרוחקים (כפי שיכול לקרות בערימה).
>
> כאשר הקוד שלכם קורא לפונקציה, הערכים המועברים לפונקציה (כולל, פוטנציאלית, מצביעים לדאטה שעל המחסנית) והמשתנים המקומיים של הפונקציה נדחפים למחסנית. כאשר הפונקציה מסתיימת, ערכים אלו מוקפצים אל מחוץ למחסנית.
>
> סוגיות ניהול הזיכרון הן סוגיות ליבה בכל שפת תכנות, וכל שפת תכנות מתמודדת עימן אחרת. סוגיות אלו כוללות, למשל, את הצורך לעקוב אחר אילו חלקים של הקוד משתמשים בדאטה הנמצא בערימה; כיצד ניתן לצמצם את כפילות הדאטה בערימה, ואיך לאתר ולשחרר מזיכרון הערימה דאטה שכבר לא נמצא בשימוש. עיקרון הבעלות בראסט הוא באופן בו ראסט נותנת מענה לסוגיות הללו. ברגע שתבינו את יסודות הבעלות, לא תצטרכו לחשוב הרבה על המחסנית והערימה. עם זאת, ההבנה שתפקידה המרכזי של הבעלות הוא ניהול הדאטה בערימה יכולה להסביר מדוע שפת ראסט עובדת כפי שהיא עובדת.

### כללי בעלות

ראשית, הבה נתבונן בכללי הבעלות. זכרו כללים אלה בעודנו עוברים על הדוגמאות להם:

- לכל ערך ברסט יש בעלים (owner).
- לכל ערך יש בדיוק בעלים אחד בכל זמן נתון.
- כאשר הבעלים יוצא מחוץ למתחם, הערך נעזב (dropped).

### המתחם של משתנה

כעת משיסודות התחביר של ראסט מאחורנו, לא נטרח לכתוב קוד כמו `fn main() {` בדוגמאות. לכן, בהנחה שאתם עוקבים ברצינות, וודאו למקם את הקוד בדוגמאות הבאות בתוך פונקציית `main`. כתוצאה מכך, הדוגמאות שלנו יהיה קצת יותר קצרות, מה שיאפשר לנו לנו להתמקד בפרטים המעניינים ולא בקוד סתמי (boilerplate code).

הנה דוגמה ראשונה לבעלות. הבה נתבונן ב*מתחם* של משתנים. המתחם הוא הטווח בתוכנית בו אלמנט תקף לשימוש. קחו למשל את המשתנה הבא:</p>

```rust
let s = "hello";
```

המשתנה `s` מתייחס למחרוזת מפורשת, וערך המחרוזת מובנה לתוך הטקסט של התכנית. המשתנה תקף מהנקודה בה הוא מוכרז עד לסוף _המתחם_ הנוכחי. רשימה 4-1 מראה תכנית עם הערות המבארות היכן המשתנה `s` יהיה תקף.

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

<span class="caption">רשימה 4-1: משתנה והמתחם בו הוא תקף</span>

במילים אחרות, יש פה שתי נקודות חשובות בזמן:

- כאשר ש-`s` _נכנס_ למתחם, ואז הוא תקף.
- כאשר -`s` _יוצא_ מהמתחם, ואז פגה תקפותו.

בנקודה זאת, הקשר בין מתחמים לזמינות המשתנים דומה לזה שבשפות תכנות אחרות. כעת נרחיב תובנה זו ונציג את הטיפוס `String`.

### הטיפוס `String`

על מנת להדגים את כללי הבעלות אנו זקוקים לטיפוס דאטה מורכב יותר מאלו שפגשנו בסעיף ["טיפוסי דאטה"][data-types]<!-- ignore --> בפרק 3. הטיפוסים שכבר כיסינו הם בגודל ידוע, ניתנים לאחסון על המחסנית, ולכן ניתן להקפיץ אותם מחוץ למחסנית כאשר הם מגיעים לסוף המתחם שלהם. במידה וחלק אחר בקוד צריך להשתמש באותו הערך במתחם אחר, ניתן להעתיק אותם בקלות ובמהירות וליצור מהם מופעים חדשים ובלתי-תלויים. אך כעת אנו רוצים להתבונן בדאטה שמאוחסן בערימה, ולהבין כיצד ראסט יודעת מתי לשחרר הקצאות הנמצאות שם. הטיפוס `String` הוא דוגמא מצויינת לכך.

אנו נתרכז בחלקים של `String` הנוגעים לבעלות. היבטים אלה תקפים גם לטיפוסי דאטה מורכבים אחרים, בין אם הם מסופקים ע"י הספריה הסטנדרטית, ובין אם אתם יצרתם אותם. אנו נדון ב- `String` יותר לעומק ב-[פרק 8][ch8]<!-- ignore -->.

במחרוזות מפורשות כבר נתקלנו, דהיינו כאשר הערך למחרוזת מקודד כחלק מהתכנית. מחרוזות מפורשות הן נוחות, אבל הן לא מתאימות לכל מצב בו נרצה להשתמש בטקסט. סיבה אחת לכך היא שהן מנועות-שינוי. סיבה אחרת היא שלא תמיד ניתן לדעת את הערך למחרוזת בזמן כתיבת התכנית: למשל, מה אם אנו רוצים לקבל קלט מהמשתמש? למצבים אלה לראסט יש טיפוס מחרוזת שני: `String`. טיפוס זה מנהל את הדאטה שלו בערימה, ולכן מסוגל לאחסן כמות של טקסט שאינה ידועה בזמן הקומפילציה. ניתן ליצור מופע של הטיפוס `String` ממחרוזת מפורשת ע"י שימוש בפונקציה `from`, כך:

```rust
let s = String::from("hello");
```

אופרטור הנקודותיים הכפולות `::` מאפשר לנו למקם את ה- `from` הספציפי הזה תחת הטיפוס `String` במקום להשתמש באיזשהו שם כמו `string_from`. אנו נדון עוד בתחביר זה בסעיף ["תחביר מתודות"][method-syntax]<!-- ignore --> בפרק 5, וכאשר נדבר על מיקומים (namepsacing) עם מודולים ב["מסלולים להפניה לאלמנט בעץ המודולים"][paths-module-tree]<!-- ignore --> בפרק 7.

סוג זה של מחרוזת _כן_ ניתן לשינוי:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

אז, מה השוני כאן? מדוע ניתן לשנות משתנה מטיפוס `String` בעוד שערכים מפורשים לא ניתנים לשינוי? ההבדל נעוץ בדרך בה שני טיפוסים אלה מנוהלים בזיכרון.

### זיכרון והקצאות

במקרה של מחרוזת מפורשת, תוכן המחרוזת ידוע בזמן הקומפילציה, ולכן הטקסט מקודד ישירות לתוך קובץ ההרצה הסופי. זו הסיבה שמחרוזות מפורשות הן מהירות ויעילות. אבל תכונות אלה נובעות מכך שמחרוזות מפורשות הן מנועות-שינוי. לרוע המזל, לא ניתן להגדיר בקובץ הבינארי טווח זיכרון עבור כל פיסת טקסט אפשרית שגודלה לא-ידוע בזמן הקומפילציה ועשוי להשתנות בזמן ריצה.

עבור משתנים מטיפוס `String`, על-מנת לתמוך בברות-שינוי ובפיסות טקסט שגודלן אינו-ידוע, עלינו להקצות בזיכרון הערימה כמות זיכרון בלתי-ידועה בזמן הקומפילציה. רק כך נוכל לאחסן את התוכן העתידי. משמעות הדבר היא כי:

- צריך לבקש את הזיכרון בזמן הריצה.
- צריך לשחרר את הזיכרון כשאנחנו כבר לא צריכים את תוכן ה- `String`.

לחלק הראשון אנחנו אחראים: כאשר אנחנו קוראים למתודה `String::from`, היישום שלה בראסט מבקש את הזיכרון הנחוץ. גישה זו היא די אוניברסלית בקרב שפות תכנות.

אולם, החלק השני שונה מהותית בראסט. בשפות עם _מאסף אשפה_ (garbage collector), מאסף האשפה עוקב אחר כל ההקצאות ו"אוסף," כלומר משחרר זיכרון שכבר לא בשימוש, ואנחנו לא צריכים לחשוב על כך כלל. בשפות ללא מאסף אשפה, זוהי האחריות שלנו, המתכנתים, לזהות מתי זיכרון כבר לא בשימוש ולשחרר את הזיכרון באופן מפורש, בדיוק כפי שעושים כשמבקשים להקצות זיכרון.
ביצוע נכון של פעולות אלה היווה, באופן היסטורי, בעיה תכנותית סבוכה. אם שוכחים לשחרר זיכרון, זה בזבוז. אם משחררים זיכרון מוקדם מידי, נקבל משתנה לא תקני. אם משחררים הקצאה פעמיים, גם זה באג. יש צורך לזווג`allocate` אחד עם`free` אחד בלבד, ולהיפך.

אך ראסט נוקטת בגישה שונה: ברגע שמשתנה יוצא מחוץ למתחם שלו, הזיכרון שבבעלותו משוחרר באופן אוטומטי. הנה גרסה של דוגמת המתחם מרשימה 4-1 תוך שימוש ב-`String` במקום במחרוזת מפורשת:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

כאשר `s` יוצא מהמתחם, זוהי נקודה טבעית בה ניתן לשחרר את הזיכרון שה-`String` צורך. כאשר משתנה יוצא מהמתחם, ראסט קוראת בשמנו לפונקציה מיוחדת. פונקציה זו נקראת [`drop`][drop]<!-- ignore -->, וזו הנקודה בה כותב הטיפוס `String` קורא לקוד שמבצע את שחרור הזיכרון. ראסט קוראת ל- `drop` באופן אוטומטי בזמן סגירת הסוגר המסולסל.

> שימו לב: ב-++C, דפוס זה של שחרור משאבים בסוף משך החיים (lifetime) של אלמנטים נקרא לעיתים _Resource Acquisition Is Initialization (RAII)_. הפונקציה `drop` בראסט תהיה מוכרת לכם אם אתם מכירים דפוסי RAII.

לדפוס זה יש השפעה עמוקה על אופן כתיבת הקוד בראסט. זה אולי נראה פשוט כעת, אבל התנהגות של קוד עלולה להיות בלתי-צפויה במקרים מורכבים יותר, כאשר קיימים כמה וכמה משתנים המנוהלים בזיכרון המוקצה בערימה. הבה נתנסה בכמה מצבים כאלה עכשיו.

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-move"></a>

#### אינטראקציה בין משתנים ודאטה באמצעות הזזה

בראסט, מספר רב של משתנים עשוי יכול לבוא במגע עם אותו הדאטה. הבה נראה דוגמא המשתמשת במשתנה מטיפוס מספר שלם ברשימה 4-2.

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

<span class="caption">רשימה 4-2: השמת הערך השלם של המשתנה `x` ל-`y`</span>

אנחנו יכולים לנחש מה קורה כאן: "קשור את הערך `5` ל-`x`; ואז צור עותק של הערך ב- `x` וקשור אותו ל- `y`." עכשיו יש לנו שני משתנים, `x` ו-`y`, ושניהם שווים ל-`5`. זה אכן מה שקורה, כיוון ששלמים הם ערכים פשוטים בעלי גודל ידוע וקבוע, כך ששני ערכי ה-`5` הללו נדחפים לתוך המחסנית.

הבה נתבונן כעת בגרסה עם הטיפוס `String`:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```

הקוד הזה נראה מאוד דומה, לכן ניתן לצפות שהוא יתנהג בצורה דומה, כלומר שהשורה השניה תיצור עותק של הערך ב- `s1` ותקשור אותו ל-`s2`. אך זה לא מה שקורה.

התבוננו בתמונה 4-1 כדי להבין מה קורה ל- `String` במעמקי הזיכרון. מופע של `String` מורכב משלושה חלקים, אותם רואים משמאל: מצביע לזיכרון בו מאוכסן תוכן המחרוזת, אורך המחרוזת, וקיבולת המחרוזת. קבוצת הערכים האלה נמצאת במחסנית. מימין מוצג תוכן המשתנה, כלומר הדאטה עצמו, כפי שהוא מיוצג בזיכרון הערימה.

<img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" />

<span class="caption">תמונה 4-1: הצגה בזיכרון של `String` המחזיק בערך `"hello"` ומקושר ל-`s1`</span>

נתון האורך מציין מספרית את כמות הזיכרון בבייטים, שתוכן ה-`String` תופס כרגע. הקיבולת מציינת את סך כל הזיכרון, בבייטים, שהוקצה ל-`String` בזיכרון. ההבדל בין אורך לקיבולת חשוב, אם כי לא בהקשר הנוכחי. לכן, בינתיים, זה בסדר להתעלם מנתון הקיבולת.

כאשר אנו מבצעים השמה של `s1` ל-`s2`, הדאטה של ה-`String` מועתק, במילים אחרות, אנו מעתיקים את המידע שנמצא במחסנית: המצביע, האורך, והקיבולת. בניגוד לכך, אנחנו לא מעתיקים את הדאטה שבערימה שאליו המצביע מצביע. במילים אחרות, יצוג הדאטה בזיכרון נראה כמו בתמונה 4-2.

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap."
src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">תמונה 4-2: ייצוג בזיכרון של המשתנה `s2` שמכיל עותק של המצביע, האורך, והקיבולת של `s1`</span>

הייצוג _אינו_ נראה כמו בתמונה 4-3, המראה כיצד נראה היה הזיכרון לו היתה ראסט מעתיקה את הדאטה הנמצא בזיכרון הערימה. לו ראסט היתה עושה כך, והדאטה שבערימה היה גדול, הפעולה `s2 = s1` היתה הופכת ליקרה מבחינת ביצועי זמן ריצה.

<img alt="Four tables: two tables representing the stack data for s1 and s2,
and each points to its own copy of string data on the heap."
src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">תמונה 4-3: אפשרות אחרת למשמעות ההשמה `s2 = s1` אם ראסט היתה מעתיקה דאטה מהערימה בנוסף לדאטה שבמחסנית</span>

מוקדם יותר ראינו שכאשר משתנה יוצא מהמתחם, ראסט קוראת אוטומטית לפונקציה `drop` אשר מנקה את זיכרון הערימה המשוייך לאותו המשתנה. אבל תמונה 4-2 מראה ששני המצביעים מצביעים לאותו מקום. זו בעיה: כאשר `s2` ו- `s1` יוצאים מהמתחם, שניהם ינסו לשחרר את אותו מקום בזיכרון. בעיה זו נקראת בעיית _שחרור כפול_ (double free) שהיא אחת מאותם הבאגים הקשורים לבטיחות הקצאות זיכרון שהוזכרו מוקדם יותר בפרק זה. שחרור כפול של אותו הזיכרון עלול להוביל להשחתת זיכרון, מה שעלול להוביל בתורו לפרצות אבטחה.

כדי להבטיח בטיחות זיכרון, לאחר השורה `let s2 = s1;`, ראסט מחשיבה את `s1` כלא תקף. משום כך, כאשר `s1` יוצא מהמתחם, ראסט לא צריכה לשחרר שום דבר. בדקו מה קורה אם תנסו להשתמש ב- `s1` אחרי שמוגדר `s2`; זה לא יעבוד:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

כיוון שראסט מונעת מכם מלהשתמש בהפניה הלא-תקינה, תקבלו הודעת שגיאה כגון ההודעה הבאה:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

אם שמעתם על המושגים _העתקה רדודה_ או _העתקה עמוקה_ הקיימים בשפות אחרות, אז העיקרון של העתקת המצביע ונתוני האורך והקיבולת ללא העתקת הדאטה עצמו, ודאי נשמע לכם מקרה של העתקה רדודה. אבל, בגלל שראסט גם מבטלת את המשתנה הראשון, במקום המונח העתקה רדודה, המינוח בראסט הוא _הזזה_. בדוגמא זו נאמר ש-`s1` _הוזז_ ל-`s2`. וכך, מה שבאמת מתרחש מוצג בתמונה 4-4.

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.svg" class="center" style="width:
50%;" />

<span class="caption">תמונה 4-4: ייצוג בזיכרון לאחר ש-`s1` בוטל</span>

זה פותר את הבעיה שלנו! כיוון שרק המשתנה`s2` פעיל, הוא, ורק הוא, יבצע שחרור של הזיכרון בעת יציאתו מהמתחם.

מהאמור לעיל נובעת בחירה תכנונית: ראסט לעולם לא תיצור באופן אוטומטי עותקים "עמוקים" של הדאטה שלכם. לכן, ניתן להניח שכל העתקה _אוטומטית_ היא זולה מבחינת ביצועי זמן-ריצה.

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-clone"></a>

#### אינטראקציה בין משתנים ודאטה באמצעות שיבוט

בכל זאת, אם אנחנו _כן_ מעוניינים ליצור עותק עמוק על-ידי העתקת הדאטה המקושר למופע של `String` מהערימה, ולא רק מהמחסנית, נוכל להשתמש במתודה נפוצה הנקראת `clone`. נדון בתחביר של מתודות בפרק 5, אבל כיוון שמתודות הן מושג נפוץ בשפות תכנות רבות, סביר להניח שכבר נתקלתם בהן.

הינה דוגמא למתודה `clone` בפעולה:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

זה עובד מצוין ויוצר מפורשות את ההתנהגות המוצגת בתמונה 4-3, כאשר הדאטה בערימה _כן_ הועתק.

כאשר רואים קריאה ל- `clone`, משמעות הדבר היא שקוד מסויים מבצע פעולה שעלולה להיות יקרה. כך משמשת הקריאה המפורשת כעדות ויזואלית לכך שמדובר כאן בהעתקת הדאטה עצמו.

#### דאטה שכולו במחסנית: העתקה

ישנה עוד בעיה קטנה שעוד לא דיברנו עליה. הקוד הבא משתמש בשלמים -- וחלקו הוצג ברשימה 4-2 -- והוא עובד ותקין:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

אבל נראה שהקוד הזה סותר את מה שזה עתה למדנו: אנחנו לא קוראים ל-`clone`, ובכל זאת `x` עדיין תקף ולא הוזז ל-`y`.

הסיבה היא שטיפוסים כמו שלמים, שהם בעלי גודל ידוע בזמן הקומפילציה, מאוחסנים אך ורק במחסנית. לכן העתקת הערכים עצמם נעשית במהירות. זאת אומרת שאין סיבה שנרצה למנוע מ-`x` מלהשאר תקף לאחר יצירת המשתנה `y`. במילים אחרות, במקרה כזה, של העתקת משתנים הנמצאים רק על המחסנית, אין הבדל בין העתקה עמוקה לרדודה. קריאה ל- `clone` לא תעשה אפוא שום דבר שונה בהשוואה להעתקה רדודה, ולכן אין בה צורך.

לראסט יש ביאור מיוחד הנקרא תכונת ה- `Copy` שניתנת לשימוש עם טיפוסים המאוחסנים במחסנית, כמו שלמים. נדון בתכונות באופן מורחב [בפרק 10][traits]<!-- ignore -->). אם טיפוס מיישם את התכונה `Copy`, אז משתנים מאותו טיפוס לא מוזזים, אלא מועתקים באופן טריוויאלי, וכך נשארים תקפים גם לאחר השמה למשתנה אחר.

ראסט לא תאפשר לנו לבאר טיפוס באמצעות `Copy` במידה והטיפוס, או כל חלק ממנו, מיישם את התכונה `Drop`. אם הטיפוס דורש שמשהו מיוחד יקרה כאשר הערך יוצא מהמתחם, ובכל זאת נוסיף ביאור `Copy` לטיפוס, נקבל שגיאת קומפילציה. כדי ללמוד איך להוסיף ביאור `Copy` לטיפוסים משלכם כדי ליישם את התכונה, פנו ל-["תכונות נגזרות"][derivable-traits]<!-- ignore --> בנספח ג'.

אם כן, אלו טיפוסים מיישמים את התכונה `Copy`? תמיד תוכלו לבדוק את התיעוד עבור הטיפוס הנדון כדי להיות בטוחים, אבל באופן כללי, כל קבוצה של ערכים סקאלרים פשוטים יכולים ליישם את `Copy`, ואף טיפוס שדורש הקצאת זיכרון, או סוג כזה או אחר של משאב, לא יכול ליישם את `Copy`. הנה כמה טיפוסים שמיישמים את `Copy`:

- כל טיפוסי השלמים, כמו `u32`.
- הטיפוס הבוליאני `bool`, בעל הערכים `true` ו- `false`.
- כל טיפוסי הנקודה הצפה, כמו `f64`.
- טיפוס התו `char`.
- רצפים, במידה והם רק מכילים טיפוסים שבעצמם מיישמים את `Copy`. למשל, `(i32, i32)` מיישם את `Copy`, אבל `(i32, String)` לא.

### בעלות ופונקציות

הפרטים הטכניים של העברת ערך לפונקציה דומים לאלה של השמת ערך למשתנה. העברת משתנה לפונקציה תגרום להזזה או להעתקה, בדיוק כמו בהשמה. ברשימה 4-3 יש דוגמא עם כמה ביאורים המראים היכן משתנים נכנסים ויוצאים מהמתחם.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

<span class="caption">רשימה 4-3: פונקציות בתוספת ביאורי בעלות ומתחם</span>

אם היינו מנסים להשתמש ב- `s` אחרי הקריאה ל- `takes_ownership`, ראסט היתה נותנת לנו שגיאת קומפילציה. בדיקות סטטיות אלה מגינות עלינו מטעויות. נסו להוסיף קוד ל-`main` שמשתמש ב- `s` וב-`x` כדי לראות איפה אתם יכולים להשתמש בהם והיכן כללי הבעלות מונעים מכם לעשות זאת.

### ערכים חוזרים ומתחמים

גם החזרת ערכים יכולה להעביר בעלות. רשימה 4-4 מציגה דוגמה של פונקציה המחזירה ערך, בתוספת ביאורים דומים לאלה שברשימה 4-3.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

<span class="caption">רשימה 4-4: העברת בעלות של ערכים מוחזרים</span>

בעלות על משתנה מצייתת תמיד לאותה חוקיות: השמת ערך למשתנה אחר מזיזה אותו. כאשר משתנה שכולל דאטה בערימה יוצא מהמתחם, הערך ישוחרר ע"י `drop` אלא אם כן הבעלות על הדאטה הועברה למשתנה אחר.

בעוד שמנגנון זה עובד היטב, לקיחת בעלות על משתנה אחד או יותר כל אימת שפונקציה נקראת, והחזרת בעלות עליהם בתום כל קריאה, היא דבר קצת מייגע. זה די מציק שכל מה שאנחנו מעבירים לפונקציה צריך להיות מוחזר באם אנחנו רוצים להשתמש בו שוב, וזאת בנוסף לכל פיסת דאטה שייתכן שגם אותה נרצה להחזיר מגוף הפונקציה. מה אם נרצה לאפשר לפונקציה להשתמש בערך אבל לא לקחת עליו בעלות?

ובכן, אפשרות אחת תהיה להשתמש במרצף. כזכור, ראסט מאפשרת לנו להחזיר יותר מערך אחד תוך שימוש במרצף, כפי שרואים ברשימה 4-5.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

<span class="caption">רשימה 4-5: החזרת בעלות של פרמטרים</span>

אבל זה קצת יותר מדי מסורבל, ודי הרבה עבודה, בשביל פעולה כה נפוצה. למרבה המזל, ראסט מספקת את היכולת להשתמש במשתנה ללא העברת בעלות עליו. יכולת זאת מסופקת באמצעות _הפניות_ (references).

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
