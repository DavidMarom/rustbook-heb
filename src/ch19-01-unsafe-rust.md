## ראסט לא מאובטח

בכל הקוד בו דנו עד כה ערובות בטיחות הזיכרון של ראסט היו בתוקף בזמן הקומפילציה. אבל, לראסט יש שפה שניה, מוחבאת מעט, שלא מיישמת את ערובות הביטחון האלה: היא נקראת *ראסט לא מאובטחת* והיא עובדת כמו ראסט, אבל מספקת למתכנתים כוחות-על נוספים.

ראסט לא מאובטחת קיימת כי, באופן טבעי, ניתוח סטטי הוא שמרני. כאשר הקומפיילר מנסה לקבוע אם קוד מסויים מקיים את דרישות הבטיחות הקפדניות של ראסט, הקומפיילר נוקט בקפדנות רבה ומעדיף לדחות קוד תקין מאשר לקבל קוד בעייתי. למרות שהקוד *עשוי* להיות תקין, אם לקומפיילר של ראסט אין מספיק מידע כדי לקבוע זאת בוודאות, הוא ידחה את הקוד. במקרים כאלה, ניתן להשתמש בקוד לא מאובטח כדי לאמר לקומפיילר, "סמוך עלי, אני יודע מה אני עושה." אבל, היו מודעים לכך ששימוש בראסט לא מאובטחת הוא באחריותכם: אם אתם משתמשים בראסט לא מאובטחת בצורה שגויה, אתם עלולים להתקל בבעיות שנובעות מחוסר בטיחות בניהול זיכרון, כמו דירף של מצביעי null.

סיבה נוספת לכך שלראסט יש תאומה לא מאובטחת היא שחומרת המחשב ביא ביסודה לא מאובטחת. אם ראסט לא הייתה מאפשרת פעולות לא מאובטחות, משימות מסויימות לא היו ניתנות לביצוע. ראסט צריכה לאפשר ביצוע תכנות מערכות ברמת סף, כמו התעסקות ישירות עם מערכת ההפעלה או אפילו כתיבה של מערכת הפעלה. עבודה ברמת סף עבור תכנות מערכות היא אחת ממטרות השפה. הבה נראה מה ניתן להשגה באמצעות ראסט לא מאובטחת.

### כוחות-על לא מאובטחים

כדי לעבור לכתיבת ראסט לא מאובטחת, יש להשתמש במילת המפתח `unsafe` ואז להתחיל בלוק חדש עבור הקוד הלא מאובטח. בראסט לא מאובטחת, ניתן לבצע חמש פעולות שלא ניתן לבצע בראסט מאובטחת, ולפעולות אלה אנו קוראים *כוחות-על לא מאובטחים</0. כוחות-על אלה כוללים את היכולות לבצע את הפעולות הבאות:</p>

* ביצוע דירף למצביע גולמי (raw pointer)
* קריאה לפונקציה או מתודה לא מאובטחת
* גישה או שינוי של משתנה סטטי בר-שינוי
* מימוש של תכונה לא מאובטחת
* גישה לשדות של `union`

חשוב להבין ש- `unsafe` לא מכבה את בודק ההשאלות או מנטרל אי-אלו מבדיקות הבטיחות של ראסט: אם תשתמשו בהפניה בקוד לא מאובטח, ראסט עדיין תבצע בדיקות. כל שמילת המפתח `unsafe` עושה היא לספק לכם גישה לחמשת התכונות האלה, ובטיחות הזיכרון בקשר לפעולות אלה לא נבדקת על-ידי הקומפיילר. עדיין תהנו ממידה מסויימת של בטיחות בתוך בלוק לא מאובטח.

בנוסף, `unsafe` לא אומר שהקוד בתוך הבלוק הוא בהכרח מסוכן או שהוא בוודאות כולל בעיות בטיחות זיכרון: הכוונה היא שהמתכנת לוקח את האחריות על כך שהקוד בבלוק לא מאובטח ניגש לזיכרון בצורה תקינה.

טעויות תמיד יכולות לקרות, אבל הדרישה למקם פעולות לא מאובטחות בבלוקים שמבוארים עם `unsafe` משמעה שתדעו ששורש כל בעיה שקשורה לביטחון זיכרון חייבת להימצא בבלוק לא מאובטח. יש לשמור על כך שבלוקים לא מאובטחים יהיו קצרים; זה יקל עליכם מאוחר יותר כאשר תטפלו בבאגים הקשורים לזיכרון.

כדי לבודד קוד לא מאובטח ככל שניתן, מומלץ להקיף קוד לא מאובטח בתוך אבסטרקציית קוד מאובטח ולספק API מאובטח, נושא בו נדון מאוחר יותר בפרק זה כשנתבונן בפונקציות ומתודות לא מאובטחות. חלקים מהספריה הסטנדרטית ממומשים כאבסטרקציות על פני קוד לא מאובטח שאבל בדיקה קפדנית. עיטוף קוד לא מאובטח באבסטרקציה מאובטחת מונעת זליגה של שימוש ב- `unsafe` לתוך כל החלקים בהם אתם, או המשתמשים שלכם, רוצים לעשות שימוש בפונקציונאליות שממומשת עם קוד לא מאובטח, מכיוון ששימוש באבסטרקציה מאובטחת הוא בטוח.

הבה נתבונן בכל אחד מחמשת כוחות-העל הלא מאובטחים, אחד לאחד. נראה גם כמה אבסטרקציות שמספקות ממשק מאובטח לקוד לא מאובטח.

### דירף למצביע גולמי

בפרק 4, בסעיף ["הפניות משתלשלות"](),<!-- ignore
--> הזכרנו שהקומפיילר מוודא תקפות של הפניות. בראסט לא מאובטחת יש שני סוגים חדשים של טיפוסים שנקראים 

*מצביעים גולמיים* (raw pointers), והם דומים להפניות. כמו עם הפניות, מצביעים גולמיים יכולים להיות מנועי-שינוי או ברי-שינוי והתחביר לכך הוא `*const T` ו-`*mut T`, בהתאמה. הכוכבית אינה אופרטור הדי-הפניה; היא מהווה חלק משם הטיפוס. בהקשר של מצביעים גולמיים, המשמעות של *מניעות-שינוי* היא שלא ניתן לבצע השמה ישירות למבציע לאחר ביצוע די-רף.

בשונה מהפנייות ומצביעים חכמים, התכנונות הבאות תקפות עבור מצביעים גולמיים:

* ניתן להתעלם מכללי הבעלות, וליצור מצביעים מנועי-שינוי וברי-שינוי, או ריבוי מצביעים ברי-שינוי, לאותו מיקום בזיכרון
* אין ערובה לכך שהמצביע מפנה למיקום תקין בזיכרון
* מצביעי null הם אפשריים
* חסרים מימוש אוטומטי לניכוי זיכרון

על-ידי בחירה מודעת לנטרל את בדיקות ערובות הביטחון בניהול זיכרון של ראסט, ניתן להחליף את קבלת הערובות בתמורה לביצועים טובים יותר או ליכולת לנהל תקשורת עם שפה אחרת, או עם חומרה, עבורם הערובות של ראסט אינן תקפות.

רשימה 19-1 מראה כיצד ליצור מצביע גולמי מנוע-שינוי ובר-שינוי מהפניות.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}
```

<span class="caption">רשימה 19-1: יצירת משתנים גולמיים מהפניות</span>

שימו לב שלא הכללנו את מילת המפתח `unsafe` בקוד זה. ניתן ליצור מצביעים גולמיים בקוד מאובטח; אבל לא נוכל לבצע די-רף מחוץ לבלוק לא מאובטח למצביעים גולמיים, כפי שתראו בקרוב.

יצרנו מצביעים גולמיים על-ידי שימוש ב-`as` כדי להתמיר הפניה מנועת-שינוי והפניה ברת-שינוי לטיפוסי המצביעים הגולמיים המתאימים להם. כיוון שיצרנו אותם מהפניות שתקפותן מובטחת, אנו יודעים שמצביעים גולמיים אלה תקפים גם הם, אבל אי-אפשר להניח זאת עבור כל מצביע גולמי כלשהוא.

כדי להדגים זאת, מייד ניצור מצביע גולמי שלא ניתן להיות כל-כך בטוחים בקשר לתקפותו. רשימה 19-2 מראה כיצד ליצור מצביע גולמי למיקום שרירותי בזיכרון. שימוש במקום אקראי בזיכרון יכול להוביל להתנהגות בלתי-צפויה: יתכן שיש דאטה בכתובת, ויתכן שלא, וכן יכול להיות שהקומפיילר יבצע אופטימיזצית קוד כך שלא תהיה גישה לזיכרון, ויתכן גם שהתוכנית תיצור שגיאה מסוג segmentation fault. לרוב, אין סיבה מוצדקת לכתוב קוד שכזה, אבל זו אפשרות.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}
```


<span class="caption">רשימה 19-2: יצירת מצביע גולמי לכתובת שרירותית בזיכרון</span>

זכרו שניתן ליצור מצביעים גולמיים בראסט מאובטחת, אבל לא ניתן לבצע *דירף* למצביעים גולמיים ולקרוא את הדאטה אליהם הם מצביעים. ברשימה 19-3, אנו משתמשים באופרט הדירף `*` על מצביע גולמי, וזה דורש בלוק לא מאובטח.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}
```


<span class="caption">רשימה 19-3: דירף למצביע גולמי בתוך בלוק לא מאובטח</span>

יצירת מצביע לא יכולה לגרום נזק; רק כאשר ניגשים לערך אליו המצביע מצביע יכולה להיווצר בעיה של גישה לערך לא תקף.

שימו לב שברשימה 19-1 וברשימה 19-3 יצרנו את מצביעים הגולמיים `*const i32` ו-`*mut i32`, ושניהם מצביעים לאותו מקום בזיכרון, קריא למקום בו `num` מאוכסן. אם, לחילופין, היינו מנסים ליצור הפניה מנועת-שינוי והפניה ברת-שינוי ל-`num`, הקוד לא היה עובר קומפילציה מכיוון שכללי הבעלות של ראסט לא מאפשרים להפניה ברת-שינוי להיות בתוקף באותו זמן בו הפניה מנועת-שינוי קיימת לאותו ערך. עם מצביעים גלומיים כן ניתן ליצור מצביע בר-שינוי ומצביע מנוע-שינוי לאותו מקום בזיכרון ולשנות דאטה דרך המצביע בר-השינוי, ופוטנאציאלית להוביל למרוץ דאטה. על כן יש לנקטו בזהירות!

עם כל הסכנות העורבות מסביב, מדוע שנרצה בכלל להשתמש במצביעים גולמיים? אחד מהשימושים העיקריים במצביעים גולמיים הוא כאשר עובדים על ממשק שמתקשר עם קוד בשפת C, כפי שתראו בסעיף הבא, ["קריאה לפונקציה או מתודה לא מאובטחת".](#calling-an-unsafe-function-or-method)<!-- ignore --> שימוש נוסף הוא בעת יצירת אבסטרקציות מאובטחות שבודק ההשאלות לא יכול להבין. אנו נציג פונקציות לא מאובטחות ולאחר מכן נראה דוגמא לאבסטרקציה מאובטחת שמשתמשת בקוד לא מאובטח.

### קריאה לפונקציה או למתודה לא מאובטחת

הסוג השני של פעולות שניתן לבצע בבלוק לא מאובטח הוא קריאה לפונקציות לא מאובטחות. פונקציות ומתודות לא מאובטחות נראות בדיוק כמו פונקציות ומתודות רגילות, פרט לכך שהן מוכרזות עם `unsafe` בתחילת ההגדרה. מילת המפתח `unsafe` בהקשר זה מציינת שלפונקציה יש דרישות שעלינו לקיים כאשר קוראים לפונקציה, מכיוון שראסט לא יכולה להבטיח שדרישות אלה מתקיימות. על-ידי קריאה לפונקציה לא מאובטחת בתוך בלוק לא מאובטח אנו מתחייבים שקראנו את התיעוד של הפונקציה ושאנחנו לוקחים אחריות על ווידוא נכונות התנאים לפעולה תקינה של הפונקציה.

הינה פונקציה לא מאובטח בשם `dangerous` שלא דבר:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}
```

חייבים לקרוא לפונקציה זו בתוך בלוק לא מאובטח נפרד. אם ננסה לקרוא ל- `dangerous` מחוץ לבלוק לא מאובטח, נקבל הודעת שגיאה:

```console
{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}
```

בעצם השימוש בבלוק לא מאובטח, אנחנו מידעים את ראסט שקראנו את התיעוד של הפונקציה, אנחנו מבינים כיצד להישתמש בה בצורה נכונה, ושבדקנו שכל התנאים להרצה תקינה של הפונקציה מתקיימים.

הגוף של פונקציה לא מאובטחת הוא למעשה לא מאובטח, ולכן אין צורך לציין בלוק לא מאובטח נוסף בתוך גוף הפונקציה במידה ואנחנו רוצים לבצע פעולות לא מאובטחות כחלק מהפונקציה.

#### יצירת אבסטרקציה מאובטחת לקוד לא מאובטח

פונקציה יכולה להכיל קוד לא מאובטח ועדיין להיות מאובטחת בעצמה. למעשה, פונקציה מאובטחת שעוטפת קוד לא מאובטח זה אבסטרקציה נפוצה. כדוגמא, הבה נתבונן בפונקציה `split_at_mut` מהספריה הסטנדרטית, שמשתמשת בקוד לא מאובטח. אנחנו נראה כיצד לממש זאת. מתודה מאובטחת זו מוגדרת על חיתוכים ברי-שינוי: היא מקבלת חיתוך אחד ומייצרת ממנו שני חיתוכים על-ידי פיצול החיתוך הנתון באינדקס שמועבר כארגומנט. רשימה 19-4 מראה שימוש ב-`split_at_mut`.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}
```


<span class="caption">רשימה 19-4: שימוש בפונקציה הלא מאובטחת `split_at_mut`</span>

לא ניתן לממש פונקציה זו רק באמצעות ראסט מאובטחת. ניסיון לעשות זאת יראה בערך כמו הקוד ברשימה 19-5, אשר לא עובר קומפילציה. למען הפשטות, נממש את `split_at_mut` כפונקציה במקום כמתודה ורק עבור ערכי חיתוך `i32` במקום להשתמש בטיפוס גנרי `T`.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}
```


<span class="caption">רשימה 19-5: ניסון לממש את `split_at_mut` באמצעות ראסט מאובטחת בלבד</span>

פונקציה זו מחשבת תחילה את אורך החיתוך. אחר-כך היא מוודאת שהאינדקס שהיא קיבלה כפרמטר מייצג מיקום בתוך החיתוך על-ידי בדיקה האם האינדקס קטן או שווה לאורך החיתוך. משמעות הבדיקה היא שאם מעבירים אינדקס לביצוע הפיצול שגדול מאורך החיתוך, הפונקציה תיכנס לפאניקה לפני שתנסה להשתמש באינדקס.

לבסוף, הפונקציה מחזירה מרצף של שני חיתוכים ברי-שינוי: אחד מתחילת החיתוך המקורי על לאינדקס `mid`, והשני מ-`mid` עד לסוף החיתוך.

כאשר מנסים לקמפל את הקוד ברשימה 19-5, מקבלים שגיאה.

```console
{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}
```

בודק ההשאלות של ראסט לא יכול להבין שאנו שואלים חלקים שונים של החיתוך; כל שהוא יודע זה שאנחנו שואלים מאותו החיתוך פעמיים. ההשאלה של חלקים השונים האלה של החיתוך היא פעולה תקינה ביסודה כיוון שהחלקים זרים זה לזה, אבל ראסט אינה חכמה מספיק כדי להסיק זאת. כאשר אנו יודעים שקוד מסויים הוא תקין, אבל ראסט לא יודעת זאת, זה הזמן לעשות שימוש בקוד לא מאובטח.

רשימה 19-6 מראה כיצד להשתמש בבלוק לא מאובטח, מצביע גולמי, וכמה קריאות לפונקציות לא מאובטחות כדי לגרום למימוש של `split_at_mut` לעבוד.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}
```


<span class="caption">רשימה 19-6: שימוש בקוד לא מאובטח במימוש של הפונקציה `split_at_mut`</span>

זכרו, מסעיף ["טיפוס החיתוך"][the-slice-type]<!-- ignore --> מפרק 4, שחיתוך הינו מצביע לדאטה יחד עם אורך החיתוך. אנחנו משתמשים במתודה `len` כדי לקבל את אורך החיתוך ובמתודה `as_mut_ptr` כדי לגשת אל המצביע הגולמי של החיתוך. במקרה זה, בגלל שיש לנו חיתוך בר-שינוי לערכי `i32`, הפונקציה `as_mut_ptr` מחזירה מצביע גולמי מטיפוס `*mut i32`, שאותו אנו מאכסנים למשתנה `ptr`.

אנו שומרים על הבדיקה שהאינדקס `mid` מייצג ערך תקין. ואז אנו מגיעים לקוד הלא מאובטח: הפונקציה `slice::from_raw_parts_mut` מקבלת מצביע גולמי ואורך, ויוצרת חיתוך. אנו משתמשים בפונקציה זו כדי ליצור חיתוך שמתחיל ב-`ptr` ואורכו `mid`. אחר-כך, אנו קוראים למתודה `add` על `ptr` עם `mid` כארגומנט על מנת לקבל מצביע גולמי שמתחיל ב-`mid`, ואנחנו יוצרים חיתוך באמצעות מצביע זה שאורכו כמספר שארית הפריטים אחרי `mid`.

הפונקציה `slice::from_raw_parts_mut` אינה מאובטחת כיוון שהיא משתמשת במצביע גולמי ולכן חייבת להניח שהבצביע תקף. המתודה `add` על מצביעים גולמיים גם היא לא מאובטחת, ביות והיא חייבת לסמוך על כך שהמיקום המוזז גם הוא מצביע תקף. לכן היה עלינו למקם את הקריאות ל-`slice::from_raw_parts_mut` ול-`add` בבלוק לא מאובטח, שכן לולא זאת היה ניתן לקרוא להן. על-ידי התבוננות בקוד והוספת הבדיקה ש-`mid` חייב להיות קטן או שווה ל-`len`, אנו, המתכנתים, יכולים להסיק שהמצביעים הגולמיים בהם אנו משתמשים בתוך הבלוק הלא מאובטח תמיד יהיו מצביעים תקינים לדאטה בתוך החיתוך. זהו שימוש נאות ומקובל במילת המפתח `unsafe`.

שימו לב שאין צורך לסמן את הפונקציה `split_at_mut` עצמה כלא מאובטחת, ושניתן לקרוא לפונקציה זו כחלק מקוד מאובטח של ראסט. יצרנו אבסטרקציה מאובטחת לקוד הלא מאובטח עם מימוש של הפונקציה שמשתמש בקוד לא-מאובטח בצורה בטוחה, כיוון שהוא יוצר אך ורק מצביעים תקפים מהדטא אליו לפונקציה יש גישה.

בניגוד לכך, בסבירות גבוהה השימוש ב-`slice::from_raw_parts_mut` ברשימה 19-7 יגרום לקריסה בזמן שימוש בחיתוך. קוד זה מקבל מיקום שרירותי בזיכרון ויוצר חיתוך בארך 10,000 פריטים.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}
```


<span class="caption">רשימה 19-7: יצירת חיתוך ממיקום שרירותי בזיכרון</span>

אין לנו בעלות על הזיכרון במיקום זה, ואין שוב ערובה שהחיתוך שקוד זה יוצר מכיל ערכי `i32` תקפים. שימוש ב-`values` כאילו מדובר בחיתוך תקף יוביל להתנהגות שאינה מוגדרת היטב.

#### שימוש בפונקציות מסוג `extern` לקריאה לקוד חיצוני

לפעמים, על קוד ראסט להשתלב עם קוד שכתוב בשפה אחרת. לצורך כך, לראסט יש את מילת מפתח `extern` אשר מיישמת שימוש ב-*Foreign Function Interface (FFI)*. FFI הוא ממשק שמאפשר לשפת תכנות להגדיר פונקציות ולאפשר לשפה אחרת לקרוא לפונקציות אלה.

רשימה 19-8 מדגימה כיצד לבצע אינטגרציה בראסט עם הפונקציה `abs` מהספריה הסטנדרטית של C. פונקציות שמוכרזות בתוך בלוק חיצוני (extern block) הן תמיד לא מאובטחות לקריאה מתוך קוד ראסט. הסיבה לכך היא ששפות אחרות לא כופות את כללי הבטיחות של ראסט, וראסט לא יכולה לבדוק אותם, ולכן האחריות לבטיחות הקוד נופלת על המתכנת.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}
```


<span class="caption">רשימה 19-8: הכרזה על פונקציה כפונקציה חיצונית המוגדרת בשפה אחרת</span>

בתוך הבלוק `extern "C"`, אנו רושמים את השמות והחותמים של הפונקציות החיצוניות מהשפה האחרת להן אני מעוניינים לקרוא. הסימון `"C"` מצהיר באיזה ממשק ABI (application binary interface) הפונקציה החיצונית משתמשת: ה-ABI מגדיר כיצד לקרוא לפונקציה ברמת האסמבלי. הישמוש ב-`"C"` כ-ABI הוא השימוש הנפוץ ביותר והוא עוקב אחר ה-ABI של שפת התכנות C.

> #### קריאה לפונקציות ראסט משפות אחרות
> 
> ניתן גם להשתמש ב-`extern` על מנת ליצור ממשק שמאפשר לשפות אחרות לקרוא לפונקציות ראסט. במקום ליצור בלוק `extern` שלם, אנו מוסיפים את מילת המפתח `extern` ומציינים את ה-ABI בו אנו רוצים להשתמש מייד לפני מילת המפתח `fn` עבור הפונקציה הרלוונטית. יש גם להוסיף את הביאור `#[no_mangle]` כדי לאמר לקומפיילר של ראסט לא להשחית את שם הפונקציה. *השחתה* (manglin) זהו התהליך בו הקומפיילר משנה את השם שאנחנו נתנו לפונקציה מסויימת לשם אחר (הרבה פחות קריא למשתמש) שכולל יותר מידע, וזאת כהכנה עבור חלקים אחרים של הקומפיילר כחלק מתהליך הקומפילציה. קומפיילרים שונים של שפות תכנות שונות משחיתים שמות בצורות קצת שונות זו מזו, כך שעל מנת שיהיה ניתן לקרוא לפונקציה של ראסט על-ידי שפות אחרות, חייבים למנוע מהקומפיילר של ראסט להשחית את שם הפונקציה.
> 
> בדוגמא הבאה, אנו הופכים את הפונקציה `call_from_c` לזמינה מקוד C, לאחר שהיא מקומפלת לספריה משותפת ומקושרת מ-C:
> 
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
> 
> השימוש ב-`extern` לא מחייב שימוש ב-`unsafe`.

### גישה ושינוי משתנים סטטיים ברי-שינוי

בספר זה, עוד לא דיברנו על *משתנים גלובלים*, לא משום שהם לא קיימים בראסט, אלה בגלל שהשימוש בהם עלול להיות בעייתי בהתחשב בכללי הבעלות של ראסט. אם שני פתילים ניגשים לאותו משתנה גלובלי, עלול להיווצר מרוץ דאטה.

בראסט, משתנים גלובלים נקראים משתנים *סטטים*. רשימה 19-9 מציגה דוגמא להכרזה ושימוש במשתנה סטטי עם חיתוך מחרוזת בתור ערך.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}
```


<span class="caption">רשימה 19-9: הגדרה ושימוש במשתנה סטטי מנוע-שינוי</span>

משתנים סטטים דומים לקבועים, בהם דנו בסעיף ["הבדלים בין משתנים לקבועים"]()<!-- ignore --> בפרק 3. קונבנצית השמות למשתנים סטטים בראסט היא `SCREAMING_SNAKE_CASE`. משתנים סטטים יכולים לאכסן הפניות אך ורק עם משך חיים `'static`, ומשמעות הדבר היא כי הקומפיילר של ראסט יכול להסיק לבדו מהו משך החיים ואנחנו לא מוחייבים לבאר אותו מפורשות. גישה למשתנה סטטי מנוע-שינוי היא פעולה בטוחה.

הבדל עדין בין קבועים ומשתנים סטטים מנועי-שינוי הוא שלערכים במשתנים סטטים יש כתובת קבועה בזיכרון. שימוש בערך תמיד ייגש לאותו דאטה. קבועים, לאומת זאת, יכולים לשכפל את הדאטה שלהם בכל פעם שמשתמשים בהם. הבדל נוסף הוא שמשתנים סטטים יכולים להיות ברי-שינוי. גישה ושינוי של משתנים סטטים ברי-שינוי אינן פעולות מאובטחות. רשימה 19-10 מראה כיצד ליצור, לגשת, ולשנות משתנה סטטי בר-שינוי בשם `COUNTER`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}
```


<span class="caption">רשימה 19-10: קריאה וכתיבה עם משתנה סטטי בר-שינוי אינם מאובטחות</span>

כמו עם משתנים רגילים, אנו מציינים ברות-שינוי באמצעות מילת המפתח `mut`. כל קוד שקורא או כותב אל `COUNTER` חייב להיות בתוך בלוק לא מאובטח. הקוד לעיל עובר קומפילציה ומדפיס `COUNTER: 3`, כצפוי, כיוון שזהו פתיל חישוב יחיד. לו היו כמה פתילי חישוב שניגשים ל-`COUNTER`, היתה סכנה להיווצרות מרוץ דאטה.

עם דאטה גלובלי שנגיש גלובלית, קשה להבטיח שאין מרוצי דאטה, ולכן ראסט מתייחס למשתנים סטטים ברי-שינוי כלא מאובטחים. עדיף, ככל שניתן, להשתמש בטכניקות המקביליות ובמצביעים כחמים בטוחי-פתילים שראינו בפרק 16, כדי שהקומפיילר יבדוק שדאטה שהגישה אליו מפתילים שונים נעשית בצורה בטוחה.

### מימוש תכונה לא מאובטחת

ניתן להשתמש ב-`unsafe` כדי לממש תכונה לא מאובטחת. תכונה נחשבת לא מאובטחת כאשר לפחות לאחת המתודות שבה יש אינווריאנט שהקומפיילר אינו יכול לוודא. אנו מכריזים על תכונה כלא מאובטחת על-ידי הוספת מילת המפתח `unsafe` לפני השימוש ב-`trait` ומסמנים את המימוש של התכונה גם כן כ-`unsafe`, כמוצג ברשימה 19-11.

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}
```


<span class="caption">רשימה 19-11: הגדרה ומימוש של תכונה לא מאובטחת</span>

על-ידי השימוש ב-`unsafe impl`, אנו מבטיחים לקחת את האחריות על כל האינווריאנטים שהקומפיילר לא יכול לוודא.

למשל, הזכרו בסמני התכונה `Sync` ו-`Send` בהם דנו בסעיף ["מקביליות ניתנת להרחבה עם `Sync` ו-`Send`"]()<!-- ignore -->
בפרק 16: הקומפיילר מממש תכונות אלה באופן אוטומטי במידה והטיפוסים שלנו מורכבים אך ורק מטיפוסי `Sync` ו-`Send`. אם אנו מממשים טיפוס שמכיל טיפוס שאינו מסוג `Sync` או `Send`, כמו מצביע גולמי, ואנחנו רוצים לסמן אותו כ`Sync` או `Send`, עלינו להשתמש ב-`unsafe`. ראסט לא יכולה לוודא שהטיפוס מקיים את כל הדרישות שמבטיחות שניתן לשלוח אותו בבטחה לאורך פתילי חישוב או שניתן לגשת אליו בבטחון מפתילי-חישוב מרובים; לכן, עלינו לבצע בדיקות אלה באופן ידני, ולציין זאת באמצעות `unsafe`.

### גישה לשדות של איחוד

הפעולה האחרונה שדורשת שימוש ב-`unsafe` היא גישה לשדות את *איחוד*. `איחוד` (union) דומה למבנה, אבל רק שדה אחד שלו יכול להיות פעיל בכל מופע שהוא בכל זמן שהוא. באיחודים משתמשים בדרך-כלל כחלק מממשקים עם איחודים של קוד C. גישה לשדות של איחוד היא פעולה לא מאובטחת משום שראסט לא יכולה להבטיח את הטיפוס של הדאטה שכרגע מאוכסן במופע האיחוד. תוכלו ללמוד עוד אודות איחודים [בתיעוד של ראסט][reference].

### מתי להשתמש בקוד לא מאובטח

שימוש ב- `unsafe` על מנת לנקוט באחת מחמש פעולות (העל) בהן דנו לעיל אינו טעות וגם לא מושא לנזיפה. אבל, יותר מאתגר לייצר קוד לא מאובטח שעובד בצורה בטוחה מכיוון שהקומפיילר לא מבצע עבורנו בדיקות בטיחות זיכרון. כאשר ישנה סיבה להשתמש בקוד לא מאובטח, ראוי לעשות זאת. שימוש בביאור `unsafe` מבהיר את המתרחש ומקל על איתור אחר מקורות בעיות לכשהן נוצרות.
ch04-02-references-and-borrowing.html#dangling-references ch03-01-variables-and-mutability.html#constants ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits

[the-slice-type]: ch04-03-slices.html#the-slice-type
[reference]: ../reference/items/unions.html
