## נושאים מתקדמים אודות פונקציות וסגורים

סעיף זה ידון בכמה תכונוות מתקדמות הקשורות לפונקציות ולסגורים, כולל מצביעי פונקציות והחזרת סגורים.

### מצביעי פונקציות

דיברו על איך להעביר סגורים לפונקציות; ניתן גם להעביר פונקציות רגילות לפונקציות! טכניקה זו שימושית כאשר רוצים להעביר פונקציה שכבר הגדרתם במקום להגדיר סגור חדש. פונקציות מותמרות לטיפוס `fn` (עם 'f' קטנה), שהוא טיפוס שונה מתכונת הסגור `Fn`. הטיפוס `fn` נקראה *מצביע פונקציה*. העברת פונקציות באמצעות מצביעי פונקציות מאפשרת להעביר פונקציות כארגומנטים לפונקציות אחרות.

התחביר כדי לציין שפרמטר הוא מצביע פונקציה דומה לזה של סגורים, כפי שמוצג ברשימה 19-27, שם הגדרנו את הפונקציה `add_one` שמוסיפה אחד לפרמטר שלה. הפונקציה `do_twice` מקבלת שני פרמטרים: מצביע פונקציה לפונקציה שמקבלת פרמטר מטיפוס `i32` ומחזירה ערך `i32`, וערך אחד מטיפוס `i32`. הפונקציה `do_twice` קוראת לפונקציה `f` פעמיים, בעודה מעבירה לה את הערך `arg`, ואז מחברת את שני הערכים המוחזרים. הפונקציה `main` קוראת ל- `do_twice` עם הארגומנטים `add_one` ו-`5`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-27/src/main.rs}}
```


<span class="caption">רשימה 19-27: שימוש בטיפוס `fn` כדי לקבל מצביע פונקציה כארגומנט</span>

קוד זה ידפיס: `The answer is: 12`. אנו מציינים שהפרמטר `f` ב-`do_twice` הוא `fn` שמקבלת פרמטר אחד מטיפוס `i32` ומחזירה ערך `i32`. כך ניתן לקרוא לפונקציה `f` מתוך גוף הפונקציה `do_twice`. בפונקציה `main`, אנחנו יכולים להעביר את שם הפונקציה `add_one` כארגומנט הראשון ל-`do_twice`.

שלא כמו סגורים, `fn` הוא טיפוס ולא תכונה, ולכן מציינים את `fn` כטיפוס הפרמטר ישירות במקום להכריז על פרמטר טיפוס גנרי עם אחת מתכונות ה-`Fn` כמגבלת תכונה.

מצביעי פונקציות מממשות את כל שלושת תכונות הסגורים (`Fn`, `FnMut`, ו-`FnOnce`), ומכן משתמע שתמיד ניתן להעביר מצביע פונקציה כארגומנט עבור פונקצה שמצפה לסגור. מומלץ לכתוב פונקציות תוך שימוש בטיפוס גנרי ובאחד מתכונות הסגור כדי שהפונקציות שלכם יוכלו לקבל גם פונקציות וגם סגורים.

אבל, מקרה בו יש להעדיף לקבל רק `fn` ולא סגורים הוא כאשר באים במגע עם קוד חיצוני שבו אין סגורים: פונקציות C יכולות לקבל פונקציות כארגומנטים, אבל ב-C אין סגורים.

כדוגמא בה תוכלו להשתמש או בסגור מוגדר פנימית או בפונקציה בעלת שם, הבה נתבונן בשימוש במתודה `map` שמסופקת על-ידי התכונה `Iterator` בספריה הסטנדרטית. כדי להשתמש בפונקציה `map` כדי להפוך ווקטור של מספרים לווקטור של מחרוזות, נוכל להשתמש בסגור, כך:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-15-map-closure/src/main.rs:here}}
```

לחילופין, נוכל גם להעביר שם של פונקציה כארגנומנט ל-`map` במקום הסגור, בצורה הבאה:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-16-map-function/src/main.rs:here}}
```

שימו לב שחייבים להשתמש בתחביר מוסמך לחלוטין עליו דיברנו לעיל בסעיף ["נושאים מתקדמים אודות תכונות"]()<!-- ignore --> מכיוון שיש כמה פונקציות זמינות בשם `to_string`. כאן, אנו משתמשים בפונקציה `to_string` שמוגדרת בתכונה `ToString`, שהספריה הסטנדרטית מממשת עבור כל טיפוס שמממש את `Display`.

זכרו מסעיף ["ערכי מבחר"][enum-values]<!-- ignore --> מפרק 6 שהשם של כל ווריאנט של מבחר שאנו מגדירים הוא גם השם של פונקציה מאתחלת. ניתן להשתמש בפונקציות מאתחלות אלה כמצביעי פונקציות שמממשות את תכונות הסגור, משמע שניתן לספק פונקציות מאתחלות כארגומנטים עבור מתודות שמקבלות סגורים, למשל כך:

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-17-map-initializer/src/main.rs:here}}
```

כאן אנו יוצרים מופעים של `Status::Value` תוך שימוש בכל ערכי ה-`u32` בטווח שעליו קוראים את `map` על-ידי שימוש בפונקציה מאתחלת של `Status::Value`. יש המעדיפים סגנון זה, ויש המעדיפים שימוש בסגורים. שתי האפשרויות עוברות קימפול לאותו קוד, כך שאתם מוזמנים לבחור את הסגנון המועדף עליכם.

### החזרת סגורים

סגורים מיוצגים על-ידי תכונות, ולכן לא ניתן להחזיר סגורים בצורה ישירה. ברוב המקרים בהם תרצו להחזיר תכונה, תוכלו במקום זאת להשתמש בטיפוס קונקרטי שמממש את התכונה כערך המוחזר של הפונקציה. אולם, לא ניתן לעשות זאת עם סגורים משום שאין להם טיפוס קונקרטי ניתן להחזרה; אסור להשתמש במצביע הפונקציה `fn` כטיפוס מוחזר, למשל.

הקוד הבא מנסה להחזיר סגור ישירות, אבל הוא לא עובר קומפילציה:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-18-returns-closure/src/lib.rs}}
```

שגיאת הקומפילציה היא:

```console
{{#include ../listings/ch19-advanced-features/no-listing-18-returns-closure/output.txt}}
```

השגיאה מתייחסת שוב לתכונה `Sized`! ראסט לא יודעת כמה מקום בזיכרון יש עליה להקצות עבור הסגור. כבר ראינו פתרון לבעיה זו. נוכל להשתמש באובייקט תכונה:

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-19-returns-closure-trait-object/src/lib.rs}}
```

קוד זה עובר קומפילציה בלי שום בעיה. לעוד אודות אובייקטי תכונה, פנו לסעיף ["שימוש באובייקטי תכונה שמאפשרים ערכים מטיפוסים שונים"]()<!--
ignore --> בפרק 17.

וכעת, הבה נפנה להתבוננות במאקרואים!
ch19-03-advanced-traits.html#advanced-traits ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types

[enum-values]: ch06-01-defining-an-enum.html#enum-values
