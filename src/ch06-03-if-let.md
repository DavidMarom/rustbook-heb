## בקרת זרימה מקוצרת עם `if let`

המבנה התחבירי `if let` מאפשר לשלב `if` ו- `let` בניסוח מקוצר על-מנת לטפל בערכים שמתאימים לדפוס יחיד, תוך התעלמות מהשאר. התבוננו בתכנית ברשימה 6-6 שמבצעת התאמה על ערך מטיפוס `Option<u8>` שבמשתנה `config_max`, אבל מריצה קוד רק אם הערך הוא הווריאנט `Some`.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
```

<span class="caption">רשימה 6-6: התאמת `match` שמעוניינת להריץ קוד רק כאשר הערך הוא `Some`</span>

אם הערך הוא `Some`, אנו מדפיסים את הערך הפנימי של הווריאנט `Some` על-ידי קשירת הערך למשתנה `max` בדפוס. אנחנו לא רוצים לעשות דבר עם הערך `None`. כדי לספק את ביטוי ה- `match`, עלינו להוסיף `_ => ()` אחרי שטיפלנו בווריאנט אחד בלבד, וזה הרבה קוד סתמי להוסיף.

במקום זאת, ניתן לכתוב את הקוד בצורה קצרה יותר תוך שימוש בתחביר `if let`. הקוד הבא מתנהג באותה הצורה כמו ה- `match` מרשימה 6-6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
```

התחביר `if let` לוקח דפוס וביטוי המופרדים באמצעות סימן השוויון. ביצוע הקוד הוא כמו במקרה של `match` בו הביטוי מועבר ל-`match` והדפוס הוא הזרוע הראשונה. במקרה זה, הדפוס הוא `Some(max)`, וה- `max` נקשר לערך הפנימי של ה-`Some`. אז, אנחנו יכולים להשתמש ב- `max` בגוף הבלוק של ה- `if let` באותה דרך בה השתמשנו ב-`max` בזרוע המתאימה ב- `match`. הקוד בבלוק של ה-`if let` לא יבוצע אם הערך לא מתאים לדפוס.

שימוש ב- `if let` משמעו פחות כתיבה, פחות הזחה, ופחות קוד סתמי. אבל, מאבדים את הבדיקות הממצות ש-`match` כופה. הבחירה בין `match` ל- `if let` תלויה במה שאתם עושים בסיטואציה המסויימת, ובשאלה האם החיסכון בשורות קוד מצדיק את אובדן הבדיקות המקיפות של הקומפיילר.

במילים אחרות, ניתן לחשוב על `if let` כעל סוכר תחבירי (syntactic sugar) עבור ביטוי `match` שמריץ קוד כאשר הערך עליו הוא מופעל מותאם לדפוס נתון, ומתעלם מכל שאר הערכים.

ניתן להוסיף `else` ל- `if let`. בלוק הקוד אחרי ה-`else` מתנהג כמו בלוק הקוד שהיה מופיע אחרי `_` במקרה של ביטוי `match` השקול ל- `if let` עם `else`. הזכרו בהגדרת המבחר `Coin` מרשימה 6-4, בה הווריאנט `Quarter` מוגדר כך שיש בו את הערך `UsState`. לו רצינו לספור את כל המטבעות שאינם רבע-דולר בעודנו מדפיסים את המדינה המשוייכת לכל מטבע רבע-דולר, היינו יכולים לעשות זאת באמצעות ביטוי `match`, כך:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
```

לחילופין, היינו יכולים לעשות זאת באמצעות ביטוי `if let` עם `else`, כך:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
```

אם לתכנית שלכם יש לוגיקה סבוכה מדי להבעה באמצעות `match`, זכרו שבארגז הכלים שלכם נמצאת גם האופציה להשתמש ב- `if let`.

## סיכום

עתה ראינו כיצד להשתמש במבחרים כדי ליצור טיפוסים משלנו, שיכולים להיות אחד מאוסף של ערכים שניתנים למניה. הראינו איך הטיפוס `if let` מהספריה הסטנדרטית עוזר לכם להשתמש במערכת הטיפוסים כדי למנוע שגיאות. כאשר ערכי מבחר מכילים דאטה, ניתן להשתמש ב-`match` או ב-`if let` כדי להפיק ולהשתמש בערכים אלה, כתלות במספר המקרים בהם יש לטפל.

תכניות הראסט שלכם יכולות כעת לבטא מושגים בתחום שלכם תוך שימוש במבנים ובמבחרים. יצירת טיפוסים לשימוש כחלק מה-API שלכם מוודא בטיחות טיפוסים: הקומפיילר יוודא שהפונקציות שלכם מקבלות רק ערכים מהטיפוס להם הפונקציה מצפה.

בשביל לספק API מאורגן היטב עבור המשתמשים שלכם, כזה שהוא פשוט לשימוש וחושף בדיוק מה שהמשתמשים שלכם צריכים, הבה נפנה כעת לדון במודולים בראסט.
