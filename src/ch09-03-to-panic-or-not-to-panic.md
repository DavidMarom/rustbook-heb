## להיכנס לפאניקה -- כן או לא

אם כן, כיצד מחליטים מתי לקרוא ל- `panic!` ומתי יש להחזיר `Result`? כאשר קוד נכנס לפאניקה, אין דרך שיקום. ניתן לקרוא ל-`panic!` בשל שגיאות בכל סיטואציה, בין אם יש יכולת שיקום ובין אם אין, אבל כך מחליטים בשם הקוד הקורא שאין דרך שיקום. כאשר מחזירים ערך `Result`, מקנים אפשרויות פעולה לקוד הקורא. הקוד הקורא יכול לבחור לנסות לבצע פעולות שיקום בצורה שמתאימה לסיטואציה בה הוא נמצא, או הוא יוכל להחלטי שערך `Err` במקרה זה אינו מצב בר-שיקום, ולכן הוא יקרא ל-`panic!` ויהפוך את מה שסופק לו כשגיאה ברת-שיקום לשגיאה סופנית. לכן, החזרת `Result` היא בחירה טובה כאשר את מצהירים שפונקציה עלולה להכשל.

במקרים כמו דוגמאות, קוד פרוטוטייפ, ובדיקות, יותר מתאים לכתוב קוד שנכנס לפאניקה במקום להחזיר `Result`. הבה נראה מדוע, ולאחר מכן נדון במקרים בהם הקומפיילר לא יכול להסיק שכשלון הוא אופציה, אבל אתם, כבני-אדם, כן יכולים. הפרק יסתיים עם כמה קווים מנחים כלליים לסיוע בהחלטה האם להיכנס לפאניקה בקוד ספריה.

### דוגמאות, קוד פרוטוטייפ, ובדיקות

כאשר כותבים דוגמא כדי להמחיש מושג, אם כוללים בזה טיפול מלא בשגיאות זה יכול בנקל להוביל להפוך את הדוגמא לפחות ברורה. מובן מאליו שבדוגמאות, שהכוונה בקריאה למתודה שעלולה להיכנס לפאניקה, כמו `unwrap`, משמשת כתופס-מקום עבור דרך נאותה לטיפול בשגיאות, וזו עשויה להשתנות בהתאם לנעשה בשאר הקוד.

באופן דומה, המתודות `unwrap` ו-`expect` הן שימושיות מאוד כאשר כותבים קוד פרוטוטייפ, לפני שאתם מוכנים לבצע החלטות אודות טיפול בשגיאות. הן משאירות סמנים ברורים בקוד שלכם שמחכים שם עד שתהיו מוכנים לשדרג את הקוד.

אם קריאה למתודה נכשלת בבדיקה, תרצו שכל הבדיקה תכשל, אפילו אם מתודה זו אינה הפונקציונאליות שנבדקת. בגלל ש-`panic!` הוא הדרך בה בדיקה מסומנת ככזו שנכשלה, קריאה ל-`unwrap` או `expect` היא בדיוק מה שצריך לקרות.

### מקרים בהם יש לכם יותר מידע מלקומפיילר

יהיה זה נכון לקרוא ל-`unwrap` או ל-`expect` כאשר ברשותכם מידע לוגי שמבטיח שערך ה-`Result` תמיד יהיה ערך `Ok`, אבל לוגיקה זו אינה זמינה לקומפיילר. עדיין יהיה לכם ערך `Result` שצריך לטפל בו: הפעולה אותה אתם מפעילים עדיין יכולה, באופן כללי, להכשל, אפילו שבמקרה הפרטי שלכם, זו אינה אפשרות לוגית. אם אתם יכולים להבטיח על ידי בחינה ידנית של הקוד שאף-פעם לא יתקבל הווריאנט `Err`, זה מקובל לחלוטין לקרוא ל-`unwrap`, ואז גם מומלץ, בארגומנט הטקסט בקריאה ל-`expect`, לתעד את הסיבה שמנחה אתכם לדעת שהווריאנט `Err` לא יכול להתקבל. הינה דוגמא:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

אנו יוצרים מופע של `IpAddr` על-ידי ניתוח מחרוזת שמקודדת ישירות בתכנית. אנחנו יכולים לראות ש- `127.0.0.1` היא כתובת IP תקינה, ולכן זה בסדר לקרוא כאן ל-`expect`. אולם, העובדה שמדובר במחרוזת תקינה המקודדת ישירות לתכנית לא משנה את טיפוס הערך המוחזא מהמתודה `parse`: אנחנו עדיין מקבלים ערך `Result`, והקומפיילר עדיין יחייב אותנו לטפל ב-`Result`, כאילו שהווריאנט `Err` אפשרי. הרי הקומפיילר אינו חכם דיו כדי לראות שמחרוזת זו היא תמיד כתובת IP תקינה. אם מחרוזת כתובת ה-IP מגיעה מהמשתמש במקום להיות מקודדת לתוך התכנית, ולכן באמת היתה אפשרות לכשלון, בוודאי שנרצה לטפל ב-`Result` בדרך נאותה. הוספת ההנחה שכתובת IP זו מקודדת לתוך התכנית תקל עלינו לראות שצריך לשנות את `expect` לקוד שמנהל נכון את השגיאה האפשרית בעתיד, במידה ונצטרך לקבל את כתובת ה-IP ממקור אחר.

### קווים מנחים לטיפול בשגיאות

מומלץ לתת לקוד להיכנס לפאניקה אם יש סיכוי שהקוד יגיע למצב מסוכן. בהקשר זה, *מצב מסוכן* הוא מצב בו הנחה, אבטחה, חוזה, או אינווריאנטה לא ממומשים, כמו למשל כאשר ערכים לא תקניים, ערכים שסותרים זה את זה, או ערכים חסרים מועברים לקוד שלכם -- או אחד או יותר מהבאים:

* המצב המסוכן הוא דבר מה לא צפוי, בניגוד למשהו שסביר שיקרא מפעם לפעם, כמו משתמש שמכניס דאטה בפורמט שגוי.
* הקוד לאחד נקודה זו מסתמך על כך שהוא לא יהיה במצב המסוכן, במקום לבדוק זאת בכל צעד.
* אין דרך טובה לקודד מידע זה בטיפוסים בהם אתם משתמשים. אנו נעבור על דוגמא שתבהיר למה אנו מתכוונים בסעיף ["קידוד מצבים והתנהגות כטיפוסים"][encoding]<!-- ignore --> בפרק 17.

אם מתבצעת קריאה לקוד שלכם ומועברים ערכים לא הגיוניים, מומלץ להחזיר שגיאה כדי משתמשי הספריה שלכם יוכלו להחליט מה הם רוצים לעשות במקרה זה. אולם, במקרים המשך הריצה עלולה להיות מסוכנת או מזיקה, הבחירה הטובה ביותר היא לקרוא ל-`panic!` ולהתריע בפני המשתמשים אודות הבאג בקוד שלהם כדי שהם יוכלו לתקן אותו בזמן הפיתוח. באופן דומה, `panic!` הוא לרוב הבחירה המתאימה כאשר אתם קוראים לקוד חיצוני שאינו תחת שליטתחם והוא מחזיר מצב לא תקני שאין לכם שום דרך לשקם.

אבל, כאשר ניתן לפצות לכשלון, עדיף להחזיר `Result` מאשר להיכנס לפאניקה. דוגמאות לכך כוללות דאטה בצורה לא תקנית שמועבר לפרסר, או בקשת HTTP שמחזירה מצב שמציין הגעה לקצב מקסימלי. במקרים אלה, החזרה של `Result` i מציינת שכשלון הוא אפשרות ניתנת לצפיה מראש ועל הקוד הקורא להחליט כיצד לפעול.

כאשר הקוד שלכם מבצע פעולה שעלולה לשים את המשתמש בסכנה במידה וקוראים לפעולה עם ערכים לא תקניים, על הקוד שלכם לוודא תחילה שהערכים תקינים, ולהיכנס לפאניקה אם הם לא. הסיבה העיקרית לכך היא בטיחות: ניסיון לפעול על דאטה לא תקני יכול לחשוף את הקוד שלכם לרגישויות. זוהי הסיבה המרכזית לכך שהספריה הסטנדרטית קוראת ל-`panic!` אם מנסים לגשת לזיכרון מחוץ לגבולות תקניים: ניסיון לגשת לזיכרון שלא שייך למבנה נתונים ספציפי הוא גורם מרכזי לבעיות בטיחות. לרוב, לפונקציות יש *חוזים*: ההתנהגות שלהם מובטחת רק אם הקלטים שלהם עובדים בתנאים מסויימים. כניסה לפאניקה כאשר חוזה כזה לא ממומש היא פעולה סבירה ביותר כיוון שהפרת חוזה תמיד ניתנת לפירוש כבאג מצידו של הקוד הקורא, וזה לא סוג שגיאה שאתם רוצים לתת לקוד הקורא לטפל בה. למעשה, אין דרך מתקבלת על הדעת לקוד הקורא לבצע שיקום; אלה *המתכנתים* שקראו לקוד שצריכים לטפל בבעיה. חוזים לפונקציה, במיוחד כאשר הפרת חוזה תוביל לפאניקה, צריכים להיות מוסברים בתיעוד ה-API של הפונקציה.

אולם, ריבוי בדיקות בכל הפונקציות שלכם יהפוך במהירות את הקוד שלכם לרב-מלל ומציק. למרבה המזל, ניתן להשתמש במערכת הטיפוסים של ראסט (ולכן בבדיקות הטיפוסים שמבצע הקומפיילר) על מנת לבצע רבות מהבדיקות עבורכם. אם לפונקציה שלכם יש טיפוס מסויים כפרמטר, תוכלו להמשיך להתרכז בלוגיה התפעולית מתוך ידיעה שהקומפיילר מבטיח שיש לכם ערכים מתאימים. לדוגמא, אם יש לכם טיפוס במקום `Option`, התכנית שלכם מצפה לקבל *משהו* ולא *כלום*. כך הקוד שלכם לא צריך לטפל בשני מקרים עבור הווריאנטים `Some` ו- `None`: יהיה רק מקרה אחד עבור ערך וודאי. קוד שינסה להעביר כלום לפונקציה שלכם לא יעבור קומפילציה, ולכן הפונקציה שלכם לא צריכה לבדוק עבור מקרה זה בזמן הריצה. דוגמא נוספת היא שימוש בטיפוס שלם לא מסומן כמו `u32`, שמבטיח שהפרמטר אף פעם לא יהיה שלילי.

### יצירת טיפוסים מותאמים למטרת ווידוא

הבה ניקח את הרעיון להשתמש במערכת הטיפוסים של ראסט על מנת לוודא תקינות ערכים צעד אחד הלאה ונתבונן ביצירת טיפוסים מותאמים למטרת ווידוא. הזכרו במשחק ניחוש המספר מפרק 2, שם הקוד שלנו ביקש מהמשתמש לנחש מספר בין 1 ל-100. לא ביצענו ווידוא לכך שהניחוש של המשתמש באמת היה בין ערכים אלה לפני שהשוונו אותו מול המספר הסודי; הסתפקנו בלוודא שהניחוש היה חיובי. במקרה זה, תוצאות התרשלות זו אינן הרות גורל: הפלט שלנו של “Too high” או “Too low” עדיין יהיה נכון. אבל זה יהיה שיפור מועיל להנחות את המשתמש לעבר ניחושים תקפים ולהתאים את ההתנהגות כאשר המשתמש מנחש מספר מחוץ לטווח לאומת, למשל, כאשר המשתמש מקליד אותיות כחלק מהניחוש.

דרך אחת לעשות זאת תהיה להמיר את הקלט לטיפוס `i32` במקום לטיפוס `u32` על מנת לזהות מספרים שליליים ולהוסיף בדיקה להימצאות הניחוש בטווח הרלוונטי, כך:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

ביטוי ה-`if` בודק אם הערך מחוץ לטווח, מדווח על הבעיה למשתמש, וקורא ל-`continue` כדי להתחיל את האיטרציה הבאה של הלולאה ולבקש ניחוש נוסף. לאחר ביטוי ה-`if`, ניתן להמשיך עם ההשואה בין `guess` לבין המספר הסודי ביודענו כי `guess` נמצא בין 1 ל-100.

אבל זה לא פתרון אידיאלי: אם זה היה קריטי שהתכנית פועלת אך ורק על ערכים בין 1 ל-100, ולו היו בה פונקציות רבות עם דרישה זו, הצורך לבדוק זאת בכל פונקציה היה מאוד מתיש (ועשוי גם להשפיע על ביצועי הריצה).

במקום זאת, נוכל ליצור טיפוס חדש ולמקם את הווידוא בפונקציה ליצירת מופע של טיפוס זה במקום לחזור על הבדיקות בכל מקום. כך מובטח לכל פונקציה שמשתמשת בטיפוס זה בחותם שלה שכל ערך שיועבר אליה מוודא כערך תקין. רשימה 9-13 מציגה דרך אחת להגדיר טיפוס `Guess` עבורו הפונקציה `new` תיצור מופע חדש מטיפוס זה בתנאי שהערך המועבר הוא בין 1 לא 100.

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-13/src/main.rs:here}}
```


<span class="caption">רשימה 9-13: טיפוס `Guess` שימשיך אך ורק עם ערכים בין 1 ל-100</span>

ראשית, אנו מגדירים מבנה בשם `Guess` שלו שדה בשם `value` שמאכסן `i32`. זה המקום בו יאוכסן המספר.

כעת אנו מממשים פונקציה משוייכת על `Guess` בשם `new` שיוצרת מופעים של ערכי `Guess`. הפונקציה `new` מוגדרת כך שיש לה רק פרמטר אחד בשם `value` מטיפוס `i32` והיא מחזירה ערך מטיפוס `Guess`. הקוד בגוף הפונקציה `new` בודק האם `value` נמצא בטווח המספרים בין 1 ל-100. אם `value` אינו עובר בדיקה זו, אנו נכנסים לפאניקה, דבר שיעיר את תשומת לב המתכנתת שכותבה את הקריאה לקוד ויאמר לה שיש לה באג שהיא צריכה לתקן, כיוון שיצירת `Guess` עם ערך מחוץ לטווח יפר את החוזה עליו `Guess::new` מסתמכת. התנאים בהם `Guess::new` עשויה להיכנס לפאניקה צריכים להיות ברורים מתיעוד ה-API למשתמשי הקוד שלנו; אנו נדון מוסכמות תיעוד וציון האפשרויות לכניסה לפאניקה כחלק מה-API שתצרו בפרק 14. אם `value` כן עובר את הבדיקה, אנו יוצרים מופע חדש של `Guess` שבו השדה `value` מקבל את ערך הפרמטר `value`, ומחזירים את המופע הזה של `Guess`.

לאחר מכן, אנו מממשים את המתודה `value` ששואלת את `self`, אין לה פרמטרים כלל, ומחזירה ערך מטיפוס `i32`. מתודה מסוג זה נקראת לעיתים *לקחנית* (getter), כיוון שמטרתה היא לקחת דאטה מהשדות של המבנה ולהחזיר אותו. מתודה פומבית זו חיונית משום שהשדה `value` של `Guess` הוא שדה פרטי. זה חשוב שהשדה `value` פרטי כי כך לקוד שמשתמש ב-`Guess` כלל אין אפשרות לשנות את `value` ישירות: קוד מחוץ למודול *must* להשתמש בפונקציה `Guess::new` כדי ליצור מופע חדש של `Guess`, וכך מובטח שאין דרך שמופע של `Guess` יכיל `value` שלא עבר את הבדיקה לתנאים תקינות הערכים שממוקמת בפונקציה `Guess::new`.

פונקציה עם פרמטר או שמחזירה רק ערכים בין 1 ל-100 תוכל להצהיר בחותם שלה שהיא מקבלת ערכי `Guess` במקום `i32`, והיא לא תצטרך לבצע בדיקות נוספות ווידוא ערכים נוספות בגופה.

## סיכום

תכונות ניהול השגיאות בראסט בנויות על מנת לסייע לכם לכתוב קוד נקי ובטוח. המקרו `panic!` משמש כדי לסמן שהתכנית שלכם נמצאת במצב שהיא לא יכולה לנהל, ומאפשר לכם לאמר לתהליך לעצור במקום לנסות להמשיך עם ערכים בעיתיים. המבחר `Result` משתמש במערכת הטיפוסים של ראסט כדי לציין שפעולות מסויימות יכולות להכשל בצורה כזו שהקוד שלכם מסוגל לשקם. ניתן להשתמש ב-`Result` כדי לאמר לקוד שקורה לקוד שלכם שהוא צריך לטפל בהצלחות וכשלונות אפשריים בעצמו. שימוש ב-`panic!` וב-`Result` בסיטואציות המתאימות יהפוך את הקוד שלכם לקריא בהעדר בעיות ולשימושי יותר כאשר הבלתי נמנע קורה ובעיות צצות.

כעת משראיתם דרכים שימושיות בהן הספריה הסטנדרטית משתמשת בטיפוסים גנריים עם המבחרים `Option` ו-`Result`, נעבור לדון בטיפוסים גנריים באופן כללי וכיצד תוכלו להשתמש בהם בקוד שלכם.

[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
