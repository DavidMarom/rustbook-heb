## להיכנס לפאניקה -- כן או לא
כיצד מחליטים, אם כן, מתי לקרוא ל- `panic!` ומתי יש להחזיר `Result`? הרי, כאשר קוד נכנס לפאניקה, אין דרך להשתקם מכך. ניתן לקרוא ל-`panic!` בגין שגיאות בכל סיטואציה, בין אם ברת-שיקום או לא, אבל בכך מחליטים עבור הקוד הקורא שאין דרך שיקום, והתוכנית הגיעה למעשה לקיצה המוקדם. לעומת זאת, כאשר מחזירים ערך `Result`, מאפשרים לקוד הקורא להחליט כיצד לפעול. הקוד הקורא יוכל לנקוט בפעולות שיקום בהתאם לצרכיו, או להחליט שערך `Err` במקרה זה אינו בר-שיקום, ולכן יקרא ל-`panic!` בעצמו, ויהפוך את מה שסופק לו כשגיאה ברת-שיקום לשגיאה סופנית. לכן, החזרת `Result` היא בחירה טובה כאשר מצהירים שפונקציה עלולה להכשל.

במקרים כמו דוגמאות, קוד אב-טיפוס, ובדיקות, מתאים יותר לכתוב קוד שנכנס לפאניקה במקום להחזיר `Result`. הבה נראה מדוע, ולאחר-מכן נדון במקרים בהם הקומפיילר אינו יכול להסיק שכשלון אינו אופציה, אבל אתם כמתכנתים כן יכולים. הפרק יסתיים עם כמה קווים מנחים כלליים לגבי ההחלטה האם להיכנס לפאניקה בקוד ספריה.

### דוגמאות, קוד אבטיפוס, ובדיקות

כאשר כותבים דוגמה בכדי להמחיש מושג, טיפול מלא בשגיאות עשוי בנקל להפוך את הדוגמה לברורה פחות. כמובן שכאשר כותבים דוגמה, קריאה למתודה שעלולה להיכנס לפאניקה, כגון `unwrap`, אינה אלא שומר-מקום עבור דרך עתידית, נאותה יותר, לטיפול בשגיאות, וזו עשויה להיות זו או אחרת בהתאם לשאר הקוד.

באופן דומה, המתודות `unwrap` ו-`expect` הן שימושיות מאוד כאשר כותבים קוד אב-טיפוס, הרבה לפני שאתם מוכנים לבצע החלטות אודות טיפול בשגיאות. מתודות כאלה הן סמנים ברורים בקוד שלכם לכך שאתם מתכוונים לשדרג אותו בשלב מאוחר יותר.
אם קריאה למתודה נכשלת בבדיקה, תרצו שהבדיקה כולה תכשל, אפילו אם מתודה זו אינה הפונקציונאליות שנבדקת. בגלל ש-`panic!` הוא הדרך בה בדיקה מסומנת ככזו שנכשלה, קריאה ל-`unwrap` או `expect` היא בדיוק הבחירה הנכונה לכך.

### מקרים בהם יש לכם יותר מידע מאשר הקומפיילר

יהיה זה נכון לקרוא ל-`unwrap` או ל-`expect` כאשר ברשותכם קיים מידע לוגי שמבטיח שערך ה-`Result` יהיה תמיד `Ok`, אבל לוגיקה זו אינה ידועה לקומפיילר. בכל זאת, עדיין יהיה מדובר בערך `Result` שצריך לטפל בו. הפעולה בה אתם נוקטים יכולה עדיין באופן עקרוני להיכשל, אפילו שבמקרה הפרטי שלכם זו אינה אפשרות לוגית. אם אתם יכולים להבטיח על ידי בחינה ידנית של הקוד שאף-פעם לא יתקבל הווריאנט `Err`, זה מקובל לחלוטין לקרוא ל-`unwrap`. במקרה כזה אף מומלץ, בארגומנט הטקסט שבקריאה ל-`expect`, לתעד מדוע אתם יודעים בוודאות שהווריאנט `Err` לא יכול להתקבל. להלן דוגמה:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

אנו יוצרים מופע של `IpAddr` על-ידי מחרוזת מפורשת המקודדת ישירות בתכנית. אנחנו יכולים לראות ש-`127.0.0.1` היא כתובת IP תקינה, ולכן זה בסדר לקרוא כאן ל-`expect`. אולם, העובדה שמדובר במחרוזת תקינה המקודדת ישירות בתכנית לא משנה את טיפוס הערך המוחזר מהמתודה `parse`: אנחנו עדיין מקבלים ערך `Result`, והקומפיילר עדיין יחייב אותנו לטפל ב-`Result`, כאילו שהווריאנט `Err` עדיין אפשרי. הרי הקומפיילר אינו חכם דיו כדי לראות שמחרוזת זו היא תמיד כתובת IP תקינה. לעומת זאת, אם מחרוזת כתובת ה-IP מגיעה ממשתמש חיצוני, באמת קיימת אפשרות לכשלון, ולכן בוודאי שנרצה לטפל ב-`Result` בדרך נאותה. ציון ההנחה שכתובת IP זו מקודדת לתוך התכנית תסייע לנו לראות שצריך לשנות את `expect` לקוד שמנהל נכון את השגיאה האפשרית בעתיד, במידה ונצטרך לקבל את כתובת ה-IP ממקור אחר.

### קווים מנחים לטיפול בשגיאות

מומלץ לתת לקוד להיכנס לפאניקה אם יש סיכוי שהקוד יגיע למצב מסוכן. בהקשר זה, *מצב מסוכן* הוא מצב בו הנחה, אבטחה, חוזה, או ישות כלשהי אינם ממומשים, כגון כאשר מועברים לקוד שלכם ערכים לא תקניים, ערכים שסותרים זה את זה, או ערכים חסרים -- או אחד או יותר מהבאים:

* המצב המסוכן הוא דבר-מה בלתי-צפוי, בניגוד למשהו שסביר שיקרה מפעם-לפעם, כמו משתמש שמכניס דאטה בפורמט שגוי.
* המשך הקוד תלויה בכך שהוא לא יהיה במצב המסוכן; לא מתבצעות בדיקות נאותות בהמשך הקוד.
* אין דרך טובה לקודד מידע זה בטיפוסים בהם אתם משתמשים. נעבור על דוגמה שתבהיר למה אנו מתכוונים בסעיף ["קידוד מצבים והתנהגות כטיפוסים"][encoding]<!-- ignore --> בפרק 17.

אם מתבצעת קריאה לקוד שלכם ומועברים ערכים לא הגיוניים, מומלץ להחזיר שגיאה כדי שמשתמשי הספריה שלכם יוכלו להחליט מה לעשות במקרה זה. אולם, במקרים המשך הריצה עלולה להיות מסוכנת או מזיקה, הבחירה הטובה ביותר היא לקרוא ל-`panic!` ולהתריע בפני המשתמשים אודות הבאג בקוד שלהם, כדי שיוכלו לתקן אותו בשלבי הפיתוח. באופן דומה, `panic!` הוא לרוב הבחירה המתאימה כאשר אתם קוראים לקוד חיצוני שאינו תחת שליטתכם, והוא מחזיר מצב לא תקני שאין לכם שום דרך לשקם.

אבל, כאשר ניתן לפצות על כשלון, עדיף להחזיר `Result` מאשר להיכנס לפאניקה. דוגמאות לכך כוללות דאטה שמועבר לנתח התחבירי (parser) בצורה לא-תקנית, או בקשת HTTP שמחזירה מצב שמציין הגעה לקצב מקסימלי. במקרים אלה, החזרה של `Result` מציינת שכשלון הוא אפשרות שניתן לצפותה מראש, ועל הקוד הקורא להחליט כיצד לפעול.

כאשר הקוד שלכם מבצע פעולה שעלולה לשים את המשתמש בסכנה במידה וקוראים לפעולה עם ערכים לא תקניים, על הקוד שלכם לוודא תחילה שהערכים תקינים, ולהיכנס לפאניקה אם הם לא. הסיבה העיקרית לכך היא בטיחות המידע: ניסיון לפעול על דאטה לא תקני יכול לחשוף את הקוד שלכם לרגישויות. זוהי הסיבה המרכזית לכך שהספריה הסטנדרטית קוראת ל-`panic!` אם מנסים לגשת לזיכרון מחוץ לגבולות תקניים מוגדרים: ניסיון לגשת לזיכרון שלא שייך למבנה נתונים ספציפי הוא גורם מרכזי לבעיות בטיחות. פונקציות הן לרוב בעלות *חוזים*: ההתנהגות שלהן מובטחת רק אם הקלטים שלהם תואמים לדרישות מסוימות. כניסה לפאניקה כאשר חוזה כזה מופר היא פעולה סבירה, כיוון שהפרת חוזה ניתנת תמיד להבנה כבאג מצידו של הקוד הקורא, וזה לא סוג שגיאה שאתם רוצים לתת לקוד הקורא לטפל בה. למעשה, אין דרך מתקבלת על הדעת לקוד הקורא לבצע שיקום; אלה *המתכנתים* שקראו לקוד שצריכים לטפל בבעיה. חוזים לפונקציה, במיוחד כאשר הפרת חוזה תוביל לפאניקה, צריכים להיות מוסברים בתיעוד ה-API של הפונקציה.
אולם, ריבוי בדיקות בכל הפונקציות שלכם יהפוך במהירות את הקוד שלכם לרב-מלל ומציק. למרבה המזל, ניתן להשתמש במערכת הטיפוסים של ראסט (קרי, בבדיקות הטיפוסים שמבצע הקומפיילר) על מנת לבצע רבות מהבדיקות עבורכם. אם לפונקציה שלכם מקבלת טיפוס מסויים כפרמטר, תוכלו להמשיך להתרכז בלוגיקה התפעולית מתוך ידיעה שהקומפיילר מבטיח שיש לכם ערכים מתאימים. לדוגמה, אם יש לכם כל טיפוס שאינו `Option`, הרי שהתכנית שלכם מצפה לקבל *משהו* ולא *כלום*. כך הקוד שלכם לא צריך לטפל בשני מקרים עבור הווריאנטים `Some` ו- `None`: יהיה רק מקרה אחד המניח קבלת ערך ודאי. קוד שינסה להעביר כלום לפונקציה שלכם לא יעבור קומפילציה, ולכן הפונקציה שלכם לא צריכה לבדוק מקרה זה בזמן הריצה. דוגמא נוספת היא שימוש בטיפוס שלם לא-מסומן כמו `u32`, שמבטיח שהפרמטר אף-פעם לא יהיה שלילי.

### וידוא דאטה באמצעות יצירת טיפוסים מותאמים 

הבה ניקח את הרעיון להשתמש במערכת הטיפוסים של ראסט בכדי לוודא תקינות ערכים צעד אחד קדימה, ונתבונן ביצירת טיפוסים מיוחדים המאפשרים וידוא דאטה תקני. היזכרו במשחק ניחוש המספר מפרק 2, שם הקוד שלנו ביקש מהמשתמש לנחש מספר בין 1 ל-100. שם, לא בדקנו שהניחוש של המשתמש אכן נמצא בין ערכים אלה בטרם השוונו אותו למספר הסודי; הסתפקנו בלוודא שהניחוש היה חיובי. במקרה זה, תוצאות רשלנות זו אינן הרות-גורל: הפלט שלנו של “Too high” או “Too low” עדיין יהיה נכון. אבל יהיה זה שדרוג מועיל להנחות את המשתמש להכניס ניחושים תקפים, ולהתאים את התנהגות הקוד למקרים בהם המשתמש מנחש מספר שמחוץ לטווח, לעומת, למשל, מקרים בהם המשתמש מקליד אותיות כחלק מהניחוש.

דרך אחת לעשות זאת תהיה להמיר את הקלט לטיפוס `i32` במקום לטיפוס `u32` על-מנת לזהות מספרים שליליים, ולהוסיף בדיקה להימצאות הניחוש בטווח הרלוונטי, כך:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

ביטוי ה-`if` בודק אם הערך נמצא מחוץ לטווח, מדווח על הבעיה למשתמש, וקורא ל-`continue` כדי להתחיל את האיטרציה הבאה של הלולאה ולבקש ניחוש נוסף. לאחר ביטוי ה-`if`, ניתן להמשיך עם ההשואה בין `guess` לבין המספר הסודי ביודענו כי `guess` נמצא בין 1 ל-100.

אבל זה לא פתרון אידיאלי: אם היה זה קריטי שהתכנית תפעל אך ורק על ערכים בין 1 ל-100, ולו היו בה פונקציות רבות עם דרישה זו, היינו נדרשים לבדוק זאת בכל פונקציה ופונקציה, מה שהיה הופך במהרה למתיש (ועלול היה גם להשפיע על ביצועי הריצה).

במקום זאת, נוכל ליצור טיפוס חדש, ולכלול את וידוא תקינות הדאטה כחלק מובנה מתהליך יצירת מופע חדש של אותו הטיפוס. כך לא נצטרך לחזור על הבדיקות בכל מקום; כך מובטח לכל פונקציה שמשתמשת בטיפוס זה בחותם שלה שכל ערך שיועבר אליה יהיה בהכרח ערך תקין. רשימה 9-13 מציגה דרך אחת להגדיר טיפוס `Guess`: הפונקציה `new` תיצור מופע חדש מטיפוס זה רק בתנאי שהערך המועבר הוא בין 1 ל-100.

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-13/src/main.rs:here}}
```


<span class="caption">רשימה 9-13: טיפוס `Guess` שימשיך ביצירת המופע אך ורק עם ערכים בין 1 ל-100</span>

ראשית, אנו מגדירים מבנה בשם `Guess` שלו שדה בשם `value` שמאחסן ערך מטיפוס `i32`, שם יאוחסן המספר.


כעת אנו מממשים פונקציה משוייכת על `Guess` בשם `new` שיוצרת מופעים של ערכי `Guess`. הפונקציה `new` מוגדרת כך שיש לה רק פרמטר אחד הנקרא `value` מטיפוס `i32`, והיא מחזירה ערך מטיפוס `Guess`. הקוד בגוף הפונקציה `new` בודק האם `value` נמצא בטווח המספרים שבין 1 ל-100. אם `value` אינו תואם דרישה זו, אנו נכנסים לפאניקה, מה שיסב בהכרח את תשומת לב המתכנתת שקראה לקוד, ויאמר לה שיש לה באג שהיא צריכה לתקן, כיוון שיצירת `Guess` עם ערך שמחוץ לטווח יפר את החוזה עליו `Guess::new` מסתמכת. התנאים בהם `Guess::new` עשויה להיכנס לפאניקה צריכים להיות ברורים מתיעוד ה-API למשתמשי הקוד שלנו; אנו נדון במוסכמות תיעוד וציון תנאי לכניסה לפאניקה כחלק מה-API שתיצרו בפרק 14. אם `value` כן תואם לדרישה, אנו יוצרים מופע חדש של `Guess` שבו השדה `value` מקבל את ערך הפרמטר `value`, ומחזירים את המופע הזה של `Guess`.

לאחר מכן, אנו מממשים את המתודה `value` ששואלת את `self`. אין לה פרמטרים כלל, והיא מחזירה ערך מטיפוס `i32`. מתודה מסוג זה נקראת לעיתים *לקחנית* (getter), כיוון שמטרתה היא לקחת דאטה מהשדות של המבנה ולהחזיר אותו. מתודה פומבית זו חיונית משום שהשדה `value` של `Guess` הוא שדה פרטי. חשוב שהשדה `value` יוגדר כפרטי. כך תימנע מן הקוד שמשתמש ב-`Guess` את אפשרות לשנות את `value` ישירות: קוד מחוץ למודול *מחויב* להשתמש בפונקציה `Guess::new` בכדי ליצור מופע חדש של `Guess`. כך מובטח שלא יתכן שמופע של `Guess` יכיל `value` שלא עבר את בדיקת תקינות הערכים המובנית בפונקציה `Guess::new`.

פונקציה עם פרמטר, או שמחזירה רק ערכים בין 1 ל-100, תוכל להצהיר בחותם שלה שהיא מקבלת ערכי `Guess` במקום `i32`, ובכך לא תצטרך לבצע בדיקות ערכים נוספות.

## סיכום
תכונות ניהול השגיאות בראסט בנויות על-מנת לסייע לכם לכתוב קוד נקי ובטוח. המאקרו `panic!` נועד לסמן למשתמש שהתכנית שלכם נמצאת במצב שאין היא יכולה לנהל, ומאפשר לכם לעצור את הריצה באותו הרגע, במקום לנסות להמשיכה עם ערכים בעיתיים. כמו-כן, המבחר `Result` משתמש במערכת הטיפוסים של ראסט כדי לציין שפעולות מסויימות יכולות להכשל בצורה כזו שהקוד שלכם מסוגל לשקם. ניתן להשתמש ב-`Result` כדי לומר לקוד שקורא לקוד שלכם שעליו לטפל בהצלחות וכשלונות אפשריים בעצמו. שימוש ב-`panic!` וב-`Result` בסיטואציות המתאימות יהפוך את הקוד שלכם לקריא יותר מחד, ולאמין יותר מאידך, כאשר יתגלו בעיות.

כעת, משראיתם דרכים שימושיות בהן הספריה הסטנדרטית משתמשת בטיפוסים גנריים עם המבחרים `Option` ו-`Result`, נעבור לדון בטיפוסים גנריים באופן כללי וכיצד תוכלו להשתמש בהם בקוד שלכם.

[encoding]: ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types