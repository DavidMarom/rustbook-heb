## נושאים מתקדמים בתכונות

דיברנו על תכונות לראשונה בסעיף ["תכונות: הגדרת התנהגות משותפת"]()<!-- ignore --> בפרק 10, אבל לא דנו בנושאים מתקדמים של תכונות. עכשיו שאתם בקיאים ביסודות ראסט, נוכל לדון ברזי השפה, ונתמקד בתכונות.

### ציון טיפוסי שומרי-מקום בהגדרות תכונות עם טיפוסים מקושרים

*טיפוסים מקושרים* מחברים טיפוס שומר-מקום לתכונה בשביל שהגדרות המתודות של התכונה יוכלו להשתמש בטיפוסי שומרי-המקום בחותמים שלהם. על מי שמממש את התכונה יהיה לציין מהו הטיפוס הקונקרטי שבו יש להשתמש, במקום טיפוס שומר-המקום, עבור המימוש הספציפי. בדרך זו, ניתן להגדיר תכונה שמשתמשת בטיפוסים כלשהם ללא צורך לדעת בדיוק מהם הטיפוסים האלה עד לרגע המימוש של התכונה.

תארנו את רוב הנושאים המתקדמים בפרק זה ככאלו שמשתמשים בהם לעיתים נדירות. נושט הטיפוסים המשוייכים הוא במקום כלשהו באמצע: בפועל משתמשים טיפוסים משוייכים פחות מבמנגנונים אחרים אותם ראינו בשאר הספר, אבל הם בשימוש יותר תכוף משאר הנושאים בפרק זה.

דוגמא אחת לתכנוה עם טיפוס משוייך היא התכונה `Iterator` שהספריה הסטנדרטית מספקת. הטיפוס המשוייך נקרא `Item` והוא משמש עבור הטיפוס של הערכים שעליהם הטיפוס שמממש את התכונה `Item` מבצע איטרציה. ההגדרה של התכונה `Item` מוצגת ברשימה 19-12.

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}
```


<span class="caption">רשימה 19-12: ההגדרה של התכונה `Iterator` שלה הטיפוס המשוייך `Item`</span>

הטיפוס `Item` הוא שומר-מקום, והגדרת המתודה `next` מציינת שהיא תחזיר ערכים מטיפוס `Option<Self::Item>`. מממשים של התכונה `Iterator` יציינו מהו הטיפוס הקונקרטי עבור `Item`, והמתודה `next` תחזיר ערך מטיפוס `Option` שמכיל את ערך מהטיפוס הקונקרטי שסופק.

יש דמיון מסוים בין טיפוסים משוייכים לטיפוסים גנריים, שכן שניהם מאפשים להגדיר פונקציה מבלי לציין בדיוק אלו טיפוסים היא דורשת. על מנת להבין את ההבדל בין שני המושגים האלה, נתבונן במימוש של התכונה `Iterator` על טיפוס בשם `Counter` שמציין כי הטיפוס `Item` הוא `u32`:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

תחביר זה מאוד בר-השוואה לזה של ג'נריקס. אם כן, מדוע לא להגדיר את התכונה `Iterator` פשוט באמצעות ג'נריקס, כמוצג ברשימה 19-13?

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}
```


<span class="caption">רשימה 19-13: הגדרה היפותטית של התכונה `Iterator` באמצעות ג'נריקס</span>

ההבדל נעוץ בכך שכשמשתמשים בג'נריקס, כמו ברשימה 19-13, חייבים לבאר את הטיפוסים בכל מימוש; כיוון שניתן גם לממש את `Iterator<String> עבור Counter` או כל טיפוס אחר, יכולים להיות מימושים אבים של `Iterator` עבור `Counter`. במילים אחרות, כאשר תכונה מלווה בטיפוס גנרי, ניתן לממש אותה ליותר מטיפוס אחד, כאשר משנים את הטיפוסים הקונקרטים של הטיפוס הגנרי בכל פעם. כאשר משתמשים במתודה `next` על `Counter` יש צורך לספק ביאורי טיפוסים כדי לציין באיזה מימוש של `Iterator` יש להשתמש.

עם טיפוסים משוייכים, אין צורך לבאר את הטיפוסים שכן לא ניתן לממש את התכונה על טיפוס יותר מפעם אחת. ברשימה 19-12, עם ההגדרה שמשתמשת בטיפוסים משוייכים, ניתן לבחור איזה טיפוס `Item` יהיה רק פעם אחת, מכיוון שיכול להיות רק `impt Iterator for Counter` יחיד. אין צורך לציין שאנו רצוים איטרטור של ערכי `u32` בכל מקום בו אנו קוראים ל-`next` על `Counter`.

טיפוסים משוייכים הופכים גם להיות חלק מחוזה התכונה: מממשיםשל התכונה מספקים טיפוס שמחליף את הטיפוס המשוייך שמהווה שומר-מקום. לרוב, לטיפוסים משוייכים יש שם שמתאר את אופן השימוש בטיפוס, ותיעוד של הטיפוס המשוייך כחלק מתיעוד ה-API הוא הרגל טוב.

### ברירת מחדל עבור פרמטרי טיפוס גנריים והעמסת אופרטורים

כאשר משתמשים בפרמטרי טיפוס גנריים, ניתן לציין טיפוס קונקרטי שיתפקד כברירת מדחל עבור הטיפוס הגנרי. אפשרות זו מונעת את הצורך של כל מממש של התכונה לציין טיפוס קונקרטי, במידה וברירת המחדל עושה את המלאכה. מציינים טיפוס ברירת מחדל בעת ההכרזה על הטיפוס הגנרי, באמצעות התחביר `<PlaceholderType=ConcreteType>`.

דוגמא מצויינת למצב בו טכניקה זו היא שימושית היא *העמסת אופרטורים*, משמע כאשר מבצעים התאמות לדרך הפעולה של אופרטורים (כמו `+`) בנסיבות מסויימות.

ראסט אינה מאפשרת ליצור אופרטורים משלכם או להעמיס אופרטורים שרירותיים. אבל כן ניתן להעמיס את הפעולות והתכונות השייכות להם שמופיעים ב-`std::ops` על-ידי מימוש התכונות המשוייכות עם האופרטור. למשל, ברשימה 19-14 אנו מעמיסים את האופרטור `+` על מנת לחבר שני מופעים של `Point`. אנו עושים זאת על-ידי מימוש התכונה `Add` עבור המבנה `Point`:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
```


<span class="caption">רשימה 19-14: מימוש התכונה `Add` כדי להעמיס את האופרטור `+` עבור מופעי `Point`</span>

המתודה `add` מוסיפה את ערכי השדה `x` של שני מופעים של `Point` ואת ערכי השדה `y` שלהם כדי ליצור מופע חדש של `Point`. לתכונה `Add` יש טיפוס משוייך בשם `Output` שקובע את הטיפוס שהמתודה `add` מחזירה.

ברירת המחדל עבור טיפוס גנרי זה מופיע בתכונה `Add`. הינה הגדרתו:

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

קוד זה צריך להראות די מוכל: תכונה עם מתודה אחת וטיפוס משוייך. החלק החדש כאן הוא `Rhs=Self`: תחביר זה מספק *ברירת מחדל עבור פרמטר הטיפוס*. פרמטר הטיפוס הגנרי `Rhs` (קיצור ל-right-hand side, משמע, צד ימין, בדרך-כלל של משוואה) מגדיר את הטיפוס של הפמטר `rhs` במתודה `add`. אם לא מציינים טיפוס קונקרטי עבור `Rhs` כאשר ממשים את התכונה `Add`, הטיפוס של `Rhs` יהיה, כברירת-מחדל, הטיפוס `Self`, שהוא הטיפוס עבורו מתבצע המימוש של `Add`.

כאשר מימשנו את `Add` עבור `Point`, השתמשנו בברית המחדל עבור `Rhs` כיוון שרצינו לחבר שני מופעים של `Point`. הבא נתבונן בדוגמא של מימוש של התכונה `Add` בה אנו מעוניינים להתאים את הטיפוס `Rhs`, ולא להשתמש בברירת-המחדל.

יש לנו שני מבנים, `Millimeters` ו-`Meters`, שמאכסנים ערכים ביחידות שונות. מעטפת דקה זו של טיפוס קיים בתוך מבנה נקראת *תבנית טיפוס-חדש*, ונתאר אותו ביתר פירוט בסעיף ["שימוש בתבנית טיפוס-חדש כדי לממש תכונות חיצוניות עבור טיפוסים חיצוניים"][newtype]<!-- ignore
--> . אנו מעוניינים לחבר ערכים במילימטרים לערכים במטרים ולוודא שהמימוש של 

`Add` יבצע את ההמרה בצורה נכונה. נוכל לממש את `Add` עבור `Millimeters` עם `Meters` בתור הטיפוס עבור `Rhs`, כפי שמוצג ברשימה 19-15.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}
```


<span class="caption">רשימה 19-15: מימוש התכונה `Add` עבור המבנה `Millimeters` כדי לחבר מופע של `Millimeters` עם מופע של `Meters`</span>

כדי לחבר `Millimeters` עם `Meters`, אנו מציינים `impl Add<Meters>` כדי להציב את הטיפוס `Meters` ב-`Rhs` במקום ברירת-המחדל <0>Self</0>.

משתמשים בברירת-מחדל עבור פרמטרי טיפוסים בשני אופנים מרכזיים:

* על מנת להרחיב טיפוס מבלי לשבור קוד קיים
* בכדי לאפשר התאמות קוד במקרים ספציפיים שאינן נוגעות לרוב המשתמשים

התכונה `Add` מהספריה הסטנדרטית היא דוגמא לשימוש מהסוג השני: בדרך-כלל, מחברים שני מופעים של אותו טיפוס, אבל התכונה `Add` מספקת את היכולת להתאמות שחורגות מהכלל. שימוש בברירת-מחדל עבור פרמטר הטיפוס בהגדרת התכונה `Add` משמעה שרוב הזמן אין צורך לציין פרמטר נוסף. במילים אחרות, נוצר חיסכון קל בקוד סתמי, ובכך התכונה נוחה יותר לשימוש.

השימוש הראשון דומה לשני, במהופך: אם רוצים להוסיף פרמטר טיפוס לתכונה קיימת, ניתן לספק ברירת-מחדל ובכך לאפשר את הרחבת הפונקציונאליות ללא פגיעה תפעולית של המימוש הקיים.

### תחביר מוסמך לחלוטין לביטול דו-משמעות: קריאה למתודות בעלות אותו שם

בראסט, דבר אינו מונע מתכונה אחת להכיל מתודה בעלת שם זהה למתודה בתכונה אחרת, וראסט גם אינה מונעת ממכם לממש את שתי התכונות עבור טיפוס אחד. ניתן גם לממש מתודה ישירות עבור הטיפוס עם אותו שם כמו מתודות מתכונות.

כאשר קוראים למתודות בעלות אותו שם, יש צורך לאמר לראסט לאיזו מתודה אתם מתכוונים. התבוננו בקוד ברשימה 19-16 שם הגדרנו שתי תכונות, `Pilot` ו-`Wizard`, ושתיהן מכילות את המתודה `fly`. אנו מממשים את שתי התכונות עבור הטיפוס `Human`, שעבורו כבר ממומשת מתודה בשם `fly`. כל אחת ממתודות ה-`fly` האלה מבצעת פעולה שונה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
```


<span class="caption">רשימה 19-16: שתי תכונות המוגדרות להכיל מתודה בשם `fly` וממומשות עבור הטיפוס `Human`, ומתודה בשם `fly` שממומשת ישירות עבור `Human`</span>

כאשר קורים ל-`fly` על מופע של `Human`, הקומפיילר קורא, כברירת מחדל, למתודה שמוגדרת ישירות על הטיפוס, כפי שקורא ברשימה 19-17.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
```


<span class="caption">רשימה 19-17: קריאה ל-`fly` על מופע של `Human`</span>

הרצת קוד זה תדפיס `*waving arms furiously*`, כך שאכן ראסט קראה למתודה `fly` אשר מוגדרת ישירות עבור `Human`.

על מנת לקרוא למתודה `fly` של התכונה `Pilot` או התכונה `Wizard`, יש להשתמש בתחביר מפורש כדי לציין לאיזו מתודה אנו מתכוונים. רשימה 19-19 מדגימה תחביר זה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
```


<span class="caption">רשימה 19-18: ציון התכונה שאת המתודה בשם `fly` שלה אנו רוצים לקרוא</span>

ציון שם התכונה לפני שם המתודה מבהיר לראסט לאיזה מימוש של `fly` אנו רוצים לקרוא. ניתן גם לכתוב `Human::fly(&person)`, וזה שקול ל-`person.fly()` כפי שעשינו ברשימה 19-18, אבל כתיב זה ארוך יותר והוא אינו נחוץ כאן לשם מניעת כפל משמעות.

הרצת קוד זה תדפיס את הפלט:

```console
{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
```

כיוון שהמתודה `fly` מקבלת פרמטר `self`, לו היו לנו שני *טיפוסים* שמממשים *תכונה* אחת, ראסט היתה יכולה להסיק, בהתבסס על הטיפוס `self`, באיזה מימוש של התכונה להשתמש.

אולם, לפונקציות משוייכות שאינן מתודות אין את הפרמטר `self`. כאשר יש כמה טיפוסים, או כמה תכונות, שמגדירים פונקציות שאינן מתודות בעלות אותו שם, ראסט לא תמיד יכולה לדעת לאיזה טיפוס מתכוונים, אלמלא משתמשים *בתחביר מוסמך לחלוטין*. למשל, ברשימה 19-19 אנו יוצרים תכונה עבור מקלט לחיות שרוצה לקרוא לכל גורי הכלבים *Spot*. אנו יוצרים את התכונה `Animal` עם פונקציה משוייכת, שאינה מתודה, בשם `baby_name`. התכונה `Animal` ממומשת עבור המבנה `Dog`, ועבורו אנו גם מספקים את הפונקציה משוייכת `baby_name`, שאינה מתודה, באופן ישיר.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
```


<span class="caption">רשימה 19-19: תכונה עם פונקציה משוייכת וטיפוס עם פונקציה משוייכת בעלת אותו שם שגם מממש את התכונה</span>

מימשנו את הקוד כך ששמות כל גורי הכלבים יהיו Spot בפונקציה המשוייכת `baby_name` המוגדרת עבור `Dog`. הטיפוס `Dog` מממש גם את התכונה `Animal`, אשר מתארת אפיונים שיש לכל החיות. גור של כלב נקרא puppy, וזה מבוטא במימוש של התכונה `Animal` עבור `Dog` בפונקציה המשוייכת `baby_name` עם התכונה `Animal`.

בפונקציה `main`, אנו קוראים לפונקציה `Dog::baby_name`, שקוראת לפונקציה המשוייכת המוגדרת ישירות עבור `Dog`. קוד זה מפיק את הפלט:

```console
{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
```

פלט זה אינו הפלט שרצינו. אנו רוצים לקרוא לפונקציה `baby_name` שהיא חלק מהתכונה `Animal` שמימשנו עבור `Dog` כך שהקוד ידפיס `A baby dog is called a puppy`. הטכניקה לציון שם התכונה, בה השתמשנו ברשימה 19-18, לא תעזור כאן; אם נשנה את הקוד ב-`main` לקוד שברשימה 19-20, נקבל שגיאת קומפילציה.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}
```


<span class="caption">רשימה 19-20: ניסיון לקרוא לפונקציה `baby_name` מהתכונה `Animal`, אבל ראסט אינה יודעת באיזה מימוש להשתמש</span>

כיוון של-`Animal::baby_name` אין פרמטר `self`, והיות ויכולים להיות כמה טיפוסים שמממשים את התכונה `Animal`, ראסט לא יכולה להסיק לאיזה מימוש אנחנו מתכוונים. נקבל את שגיאת הקומפילציה הבאה:

```console
{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
```

על מנת לפתור את כפל המשמעות ולאמר לראסט שאנחנו מעוניינים במימוש של `Animal` עבור `Dog`, ולא במימוש של `Animal` לכל טיפוס אחר, עלינו להשתמש בתחביר מוסמך לחלוטין. רשימה 19-21 מדגימה כיצד להשתמש בתחביר מוסמך לחלוטין במקרה זה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
```


<span class="caption">רשימה 19-21: שימוש בתחביר מוסמך לחלוטין על מנת לציין שאנו רוצים לקרוא לפונקציה `baby_name` מהתכונה `Animal` הממומשת עבור `Dog`</span>

אנו מספקים לראסט ביאור טיפוס בתוך סוגריים משולשים, וזה מציין לראסט שאחנו רוצים לקרוא למתודה `baby_name` מהתכונה `Animal` הממומשת עבור `Dog` על-ידי כך שאנחנו אומרים לראסט להתייחס לטיפוס `Dog` כ-`Animal` עבור קריאת פונקציה זו. כעת, הקוד ידפיס את המבוקש:

```console
{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
```

באופן כללי, תחביר מוסמך לחלוטין מוגדר באופן הבא:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

עבור פונקציות משוייכות שאינן מתודות, לא יהיה `receiver`: תהיה רק את רשימת הארגומנטים. ניתן להשתמש בתחביר מוסמך לחלוטין בכל מקום בו קוראים לפונקציה או למתודה. אבל, מותר להשמיט כל חלק בתחביר זה שראסט יכולה להסיק לבדה מתוך ההקשר של התכנית. חובה להשתמש בתחביר מילולי זה במקרים בהם יש ריבוי מימושים לאותו שם וראסט צריכה סיוע כדי לזהות בוודאות לאיזה מימוש מתכוונים.

### שימוש בתכונת-על כדי לדרוש פונקציונאליות של תכונה אחת בתוך תכונה אחרת

לעיתים אתם עשויים למצוא את עצמכם כותבים הגדרה של תכונה שמסמכת על תכונה אחרת: בשביל שטיפוס יממש את התכונה הראשונה, אתם רוצים לדרוש שהטיפוס מממש גם את התכונה השניה. בכך תבטיחו שבהגדרת התכונה שלכם יש באפשרותכם להשתמש בפרטים המשוייכים לתכונה השניה. התכונה עליה התכונה שלכם מסתמכת נקראת *תכונת-על* של התכונה שלכם.

למשל, נניח שאנחנו רוצים ליצור את התכונה `OutlinePrint` עם מתודה בשם `outline_print` שתדפיס ערך נתון מוקף בכוכביות. זאת אומרת שבהינתן מבנה כמו `Point` שמממש את התכונה `Display` של הספריה הסטנדרטית כדי להפיק `(x, y)`, כאשר נקרא למתודה `outline_print` על מופע של `Point` שבו `x` מכיל את הערך `1` ו- `y` מכיל את הערך `3`, מה שיודפס יראה כך:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

במימוש של המתודה `outline_print`, אנו רוצים להשתמש בפונקציונאליות של התכונה `Display`. לכן, יש לדרוש שהתכונה `OutlinePrint` תעבוד אך ורק עם טיפוסים שמממשים את `Display` ומספקים את הפונקציונאליות לה `OutlinePrint` זקוקה. ניתן לעשות זאת בהגדרת התכונה על-ידי ציון `OutlinePrint: Display`. טכניקה זו דומה להוספת מגביל תכונה לתכונה. רשימה 19-22 מציגה מימוש של התכונה `OutlinePrint`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
```


<span class="caption">רשימה 19-22: מימוש של התכונה `OutlinePrint` שדורש את הפונקציונאליות של `Display`</span>

כיוון שציינו ש- `OutlinePrint` דורשת את התכונה `Display`, ניתן להשתמש בפונקציה `to_string` שממומשת אוטומטית עבור כל טיפוס המממש את `Display`. לו היינו מנסים להשתמש ב-`to_string` ללא הוספת הנקודותיים וציון התכונה `Display` אחרי שם התכונה, איינו מקבלים שגיאת קומפילציה שאומרת לנו לא נמצא מתודה בשם `to_string` עבור הטיפוס `&Self` במתחם הנוכחי.

הבה נראמ מה קורא כאשר מנסים למממש את `OutlinePrint` עבור טיפוס שלא מממש את `Display`, למשל המבנה `Point`:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

מתקבלת הודעת שגיאה שאומרת שהתכונה `Display` נחוצה, אבל לא ממומשת:

```console
{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

על מנת לפתור זאת, נממש את `Display` עבור `Point` ובכך נספק את התנאי ש-`OutlinePrint`, בצורה הבאה:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

כעת המימוש של `OutlinePrint` עבור `Point` יעבור קומפילציה בהצלחה, ונוכל לקרוא ל-`outline_print` על מופעים של `Point` כדי להציג את אותם מוקפים בכוכביות.

### שימוש בתבנית הטיפוס החדש כדי לממש תכונות חיצוניות וטיפוסים חיצוניים

בפרק 10, הסעיף ["מימוש תכונה עבור טיפוס"]()<!-- ignore --> , הזכרנו את כלל היתמות, לפיו מותר לנו לממש תכונה עבור טיפוס רק אם התכונה או הטיפוס נמצאים לוקאלית במכולה שלנו. ניתן לעקוף מגבלה זו על-ידי שימוש *בתבנית הדפוס החדש*, אשר מערבת יצירת טיפוס חדש במבנה מרצף. (דיברנו על מבני מרצף בסעיף ["שימוש במבני מרצף ללא שדות בעלי שם בכדי ליצור טיפוסים שונים"][tuple-structs]<!--
ignore --> בפרק 5.) למבנה המרצף יהיה שדה יחיד והוא יהיה מעטפת דקה מסביב לטיפוס שעבורו אנו רוצים לממש תכונה. ואז, טיפוס המעטפת הוא לוקאלי למכולה שלנו, ולכן ניתן לממש את התכונה עבור המעטפת. 

*Newtype* is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.

כדוגמא, הבה נניח שאנחנו רוצים לממש את `Display` עבור `Vec<T>`, דבר שכלל היתמות מונע מאיתנו לעשות ישירות מכיוון שגם התכונה `Display` וגם הטיפוס `Vec<T>` מוגדרים מחוץ למכולה שלנו. נוכל ליצור את המבנה `Wrapper` שמאכסן מופע של `Vec<T>`; ואז נוכל לממש את `Display` על `Wrapper` ולהשתמש בערך של `Vec<T>`, כפי שרואים ברשימה 19-23.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
```


<span class="caption">רשימה 19-23: יצירת הטיפוס `Wrapper` מסביב ל-`Vec<String>` בכדי לממש את `Display`</span>

המימוש של `Display` משתמש ב-`self.0` כדי לגשת ל-`Vec<T>` הפנימי, כיוון ש-`Wrapper` הוא מבנה מרצף ו- `Vec<T>` הוא הפריט במיקום 0 במרצף. כך ניתן להשתמש בפונקציונאליות של התכונה `Display` עבור `Wrapper`.

החיסרון שבשימוש בטכניקה זו היא ש- `Wrapper` הוא טיפוס חדש, ולכן המתודות הזמינות עבור הערך הפנימי שבו אינן זמינות עבורו. יהיה עלינו לממש את כל המתודות של `Vec<T>` ישירות עבור `Wrapper`, בצורה כזו שהמתודות יעבירו את אחריות הביצוע ל- `self.0`, כדי שיתאפשר לנו להתייחס אל `Wrapper` בדיוק כמו אל `Vec<T>`. אם היינו רוצים שלטיפוס החדש יהיו את כל המתודות שיש לטיפוס הפנימי, מימוש התכונה `Deref` (בה דנו בפרק 15 בסעיף ["התייחסות אל מצביעים חכמים כאל הפניות רגילות באמצעות התכונה `Deref`"][smart-pointer-deref]<!-- ignore --> ) עבור `Wrapper` כדי לחזור אל הטיפוס הפנימי יהיה פתרון. אם אנחנו לא רוצים של- `Wrapper` יהיו את כל המתודות של הטיפוס הפנימי -- למשל, כדי להגביל את התנהגות הטיפוס `Wrapper` -- יהיה עלינו לממש רק את המתודות הבן אנו מעוניינים.

תבנית הטיפוס החדש הזו שימושית גם ללא קשר לתכונות. הבה נשנה את המיקוד כרגע ונעבור להתבונן בדרכים מתקדמות לבוא במגע עם מערכת הטיפוסים של ראסט.
ch10-02-traits.html#implementing-a-trait-on-a-type ch10-02-traits.html#traits-defining-shared-behavior

[newtype]: ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
