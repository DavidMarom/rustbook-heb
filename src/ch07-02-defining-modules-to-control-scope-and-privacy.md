## שימוש במודולים לשליטה על מתחמים ופרטיות

בסעיף זה נעסוק במודולים ובחלקים אחרים של מערכת המודולים, קריא: *מסלולים* שמאפשרים לנקוב בשמות של עצמים, מילת המפתח `use` המכניסה מסלול למתחם, ומילת המפתח `pub` אשר הופכת עצמים לפומביים. נדון גם במילת המפתח `as`, חבילות חיצוניות, ובאופרטור גלוב.

אבל קודם כל נתחיל עם רשימת כללים למען הנוחות לכשתארגנו את הקוד שלכם בעתיד. נסביר כל אחד מכללים אלה בפירוט.

### שליף למודולים

כאן אנו מספקים הפניה מהירה אודות מודולים, מסלולים, מילת המפתח `use` ומילת המפתח `pub`, ומנגנוני הפעולה שלהם עם הקומפיילר, וכיצד רוב המפתחים מארגנים את הקוד שלהם. נדגים כל אחד מהכללים האלה במהלך הפרק הזה, וזהו מקום מצויין לחזור אליו כדי לקבל תזכורות בדבר עבודה עם מודולים.

- **יש להתחיל בבסיס המכולה**: כאשר מקמפלים מכולה, הקומפיילר קודם כל ניגש לקובץ בסיס המכולה (בדר"כ *src/lib.rs* עבור ספריה או *src/main.rs* עבור מכולה בינארית) ומחפש קוד לקימפול.
- **הכרזה על מודולים**: ניתן להכריז על מודולים חדשים בקובץ בסיס המכולה; נניח שאתם מגדירים את המודול “garden” באמצעות השורה `mod garden;`. הקומפיילר יחפש אחר הקוד של המודול במקומות הבאים:
  - מקומית בקובץ, בתוך סוגריים מסולסלים במקום הנקודה-פסיק שמופיעה מייד אחרי `mod
garden`
  - בקובץ *src/garden.rs*
  - בקובץ *src/garden/mod.rs*
- **הכרזה על תתי-מודולים**: בכל קובץ חוץ מבסיס המכולה, ניתן להגדיר תתי-מודולים. למשל, ניתן להכריז `mod vegetables;` בקובץ *src/garden.rs*. הקומפיילר יחפש אחר הקוד של תת-המודול בתוך התיקייה ששמה כשם מודול-האב במקומות הבאים:
  - כחלק מהקובץ, מייד לאחר `mod vegetables`, בתוך סוגריים מסולסלים במקום הנקודה-פסיק
  - בקובץ *src/garden/vegetables.rs*
  - בקובץ *src/garden/vegetables/mod.rs*
- **מסלולים לקוד במודולים**: ברגע שמודול מסויים הוא חלק מהמכולה, ניתן לפנות לקוד במודול הזה מכל מקום אחר באותה מכולה תוך שימוש במסלול לקוד, במידה וכללי הפרטיות מאפשרים זאת. לדוגמא, אם הטיפוס `Asparagus` נמצא במודול vegetables אשר במודול garden, ניתן לגשת אליו באמצעות `crate::garden::vegetables::Asparagus`.
- **פרטי לעומת פומבי**: קוד שבתוך מודול, כברירת מחדל, הוא פרטי ביחס למודולי-האב שלו. כדי להפוך מודול לפומבי, יש לבצע את ההכרזה באמצעות `pub mod` במקום `mod`. כדי להפוך עצמים בתוך מודול פומבי לפומביים בעצמם, יש להשתמש ב-`pub` לפני ההכרזות של העצמים.
- **מילת המפתח `use`**: מילת המפתח `use` בתוך מתחם מייצרת קיצורי דרך לעצמים במטרה ליתר את השימוש בשמות מסלולים ארוכים. בכל מתחם שיכול להפנות ל-`crate::garden::vegetables::Asparagus`, ניתן ליצור קיצור דרך באמצעות `use crate::garden::vegetables::Asparagus;` ומרגע זה, על מנת להשתמש בטיפוס הנדון במתחם, כל שצריך לעשות הוא לכתוב `Asparagus`.

בדוגמא כאן אנו יוצרים מכולה בינארית בשם `backyard` שמדגימה כללים אלה. תיקיית המכולה, שגם היא נקראת `backyard`, מכילה את הקבצים והתיקיות הבאות:

```text
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
```

קובץ בסיס המכולה במקרה זה הוא *src/main.rs*, ותוכנו הוא:

<span class="filename">Filename: src/main.rs</span>

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/main.rs}}
```

השורה `pub mod garden;` אומרת לקומפיילר להכיל את הקוד שנמצא בקובץ *src/garden.rs*, שבמקרה זה הוא:

<span class="filename">Filename: src/garden.rs</span>

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden.rs}}
```

כאן, משמעות השורה `pub mod vegetables;`, היא שהקוד בקובץ *src/garden/vegetables.rs* מוכל אף הוא. קוד זה הוא:

```rust,noplayground,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/quick-reference-example/src/garden/vegetables.rs}}
```

הבה נביט בפרטים של הכללים לעיל ונדגים אותם בפעולה!

### איגוד של פיסות קוד המקושרות זו לזו לתוך מודולים

*מודולים* מאפשרים לנו לארגן קוד בתוך מכולה בצורה קריאה ונוחה לשימוש חוזר. מודולים גם מאפשרים לשלוט על הפרטיות של עצמים, כיוון שברירת המחדל היא שקוד הממוקם בתוך מודול הוא פרטי. עצמים פרטיים הם פרטי יישומים פנימיים ואינם זמינים לשימוש חיצוני. ניתן לבחור להפוך מודולים ואת העצמים שבתוכם לפומביים, פעולה שחושפת אותם ומאפשרת לקוד חיצוני להשתמש בהם ולהסתמך עליהם.

כדוגמא, הבה נכתוב מכולת ספריה שמספקת את הפונקציונאליות של מסעדה. אנו נגדיר את חותמי הפונקציות, אבל נשאיר את גופי הפונקציות ריקים על מנת להתרכז בארגון הקוד במקום במימוש של המסעדה.

בתעשיית המסעדות, אזורים מסויימים במסעדה נקראים *קדמת הבית* ואחרים נקראים *אחורי הבית*. אזור קדמת הבית הוא היכן שנמצאים הלקוחות; אזור זה כולל את אזור הושבת הלקוחות, את המקומות ללקיחת הזמנות וביצוע תשלומים, והיכן שברטנדרים מכינים משקאות. אזור אחורי הבית מתייחס למקומות בהם שפים וטבחים עובדים במטבח, שותפי כלים מנקים, ומנהלים מבצעים עבודה אדמיניסטרטיבית.

על מנת לעצב את המכולה שלנו בצורה זו, יש ביכולתנו לארגן את הפונקציות לתוך מודולים מקוננים. צרו ספריה חדשה בשם `restaurant` ע"י הרצת `cargo new
restaurant --lib`; ואז הקלידו את הקוד מרשימה 7-1 לתוך הקובץ *src/lib.rs* כדי להגדיר כמה מודולים וחותמי פונקציות. הינה החלק עבור אזור קדמת הבית:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-01/src/lib.rs}}
```


<span class="caption">רשימה 7-1: מודול עבור `front_of_house` המכיל מודולים אחרים שבעצמם מכילים פונקציות</span>

מגדירים מודול באמצעות מילת המפתח `mod` ולאחריה שם המודול (במקרה זה, `front_of_house`). גוף המודול מוכנס לתוך סוגריים מסולסלים. בתוך מודולים ניתן למקם מודולים אחרים, כמו שרואים בדוגמא זו עם המודולים `hosting` ו-`serving`. מודולים יכולים גם להכיל הגדרות עבור עצמים אחרים, כמו מבנים, מבחרים, קבועים, תכונות, וגם -- כמו ברשימה 7-1 -- פונקציות.

ע"י שימוש במודולים, ניתן לאגד יחדיו הגדרות הקשורות זו לזו ולספק שם לסיבת הקשר. מתכנתים שמשתמשים בקוד יכולים כך לנווט את עצמם תוך התבססות על קבוצות הקוד במקום להאלץ לקרוא את כל ההגדרות. כך יותר קל להם למצוא את ההגדרות הרלווניות להם. מתכנתים שמוסיפים פונקציונאליות חדשה לקוד ידעו היכן למקם את הקוד החדש מתוך שאיפה לשמור על הארגון הקיים.

מוקדם יותר, הזכרנו שהקבצים *src/main.rs* ו- *src/lib.rs* נקראים בסיסי המכולה. הסיבה למינוח זה היא שהתוכן של כל אחד מקבצים אלה יוצרים מכולה שנקראת `crate` בבסיס מבנה המודולים של המכולה, הידוע בשם *עץ המודולים*.

רשימה 7-2 מציגה את עץ המודולים עבור המבנה מרשימה 7-1.

```text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```


<span class="caption">רשימה 7-2: עץ המודולים עבור הקוד מרשימה 7-1</span>

עץ זה מראה כיצד חלק מהמודולים מקוננים אחד בתוך השני; למשל, `hosting` מקונן בתוך `front_of_house`. העץ גם מראה שמודולים מסויימים הם אחים (siblings) אחד של השני, דהיינו שהם מוגדרים באותו מודול; `hosting` ו- `serving` הם אחים המוגדרים שניהם בתוך `front_of_house`. אם מודול A מוכל בתוך מודל B, אנו אומרים שמודול A הוא *בן* (child) של מודול B, ושמודול B הוא *אב* (parent) של מודול A. שימו לב שעץ המודולים כולו מתחיל מהמודול ב-`crate`, ושזהו מודול שמוגדר באופן לא מפורש.

ייתכן שעץ המודולים מזכיר לכם את עץ התיקייות במערכת הקבצים של המחשב שלכם; זוהי השוואה מאוד ראויה! בדיוק כמו תיקייות במערכת הקבצים, מודולים משמשים לארגון קוד. ובדיוק כמו קבצים בתיקייה, אנחנו צריכים דרך למצוא את המודולים שלנו.
