## תחביר תבניות

בסעיף זה נדון בכל אפשרויות התחביר סביב תבניות ונדון בסיבות להשתמש בכל אחת מהאפשרויות.

### התאמת ערכים מפורשים

כפי שראיתם בפרק 6, ניתן להתאים תבניות ישירות מול ערכים מפורשים. הקוד הבא מספק כמה דוגמאות:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}
```

קוד זה מדפיס `one` משום שהערך ב- `x` בוא 1. תחביר זה שימושי כאשר רוצים שהקוד יבצע פעולה מסויימת אם הוא מקבל ערך קונקרטי ספציפי.

### התאמת משתנים בעלי שמות

משתנים בעלי שמות הם תבניות לא ניתנות להפרכה שתואמות כל ערך שהוא, והשתמשנו בהן מספר רב של פעמים במהלך הספר. אבל, ישנו סיבוך מסוים כאשר משתמשים במשתנים בעלי שם בביטויי `match`. כיוון ש- `match` מתחיל מתחם חדש, משתנים שמוגדרים כחלק מתבנית בתוך ביטוי `match` יאפילו על משתנים מחוץ למתחם ה- `match` בעלי אותו שם. ברשימה 18-11, אנו מגדירים משתנה בשם `x` שלו הערך `Some(5)` ומשתנה בשם `y` עם הערך `10`. ואז אנחנו יוצרים ביטוי `match` על הערך `x`. התבוננו בתבניות בזרועות ה-match וב-`println!` שבסוף, ונסו להבין, לפני שתריצו את הקוד או שתמשיכו לקרוא, מה הקוד ידפיס.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-11/src/main.rs:here}}
```


<span class="caption">רשימה 18-11: ביטוי `match` עם זרוע שגורמת להאפלה של המשתנה `y`</span>

הבה נעבור צעד-צעד על המתרחש כאשר ביטוי ה- `match` רץ. התבנית בזרוע הראשונה לא מתאימה לערך המוגדר של `x`, ולכן הקוד ממשיך הלאה.

התבנית בזרוע השניה מגדיר משתנה חדש בשם `y` שמתאים לכל ערך שבתוך ערך מטיפוס `Some`. כיוון שאנו כרגע במתחם חדש בתוך ביטוי ה- `match`, המשתנה `y` הוא משתנה חדש, ובפרט אינו המשתנה `y` שהוגדר בהתחלה עם הערך 10. קישור חדש זה עבור `y` יתאים לבכל ערך שבתוך `Some`, וזה מה שיהיה לנו ב- `x`. לכן, ה- `y` החדש הזה נקשר לערך הפנימי של `Some` ב-`x`. הערך הוא `5`, והביטוי עבור הזרוע מורץ ומדפיס `Matched, y = 5`.

אם `x` היה הערך `None` במקום `Some(5)`, התבניות בשתי הזרועות הראשונות לא היתה מותאמת, ולכן הערך היה מותאם למקף התחתי. לא הכרזנו על משתנה `x` בתבנית של המקף התחתי, ולכן ה- `x` בביטוי הוא עדיין ה- `x` החיצוני, שאינו מואפל. במקרה הופותטי זה, ה-`match` היה מדפיס `Default
case, x = None`.

כאשר ביטוי ה- `match` מסתיים, המתחם שלו מגיע לקיצו, ואיתו גם המתחם של המשתנה הפנימי `y`. שורת ה-`println!` שבסוף הקוד מפיקה `at the end: x = Some(5), y = 10`.

כדי ליצור ביטוי `match` שמשווה את הערכים של המשתנים `x` ו-`y` החיצוניים, מבלי להאפיל על משתנים אלה, יש צורך להשתמש במגן התאמה מותנה. נדון במגני התאמה מותנים בסעיף ["התניות נוספות באמצעות מגני התאמה"](#extra-conditionals-with-match-guards)<!--
ignore --> .

### ריבוי תבניות

בביטויי `match`, ניתן להתאים מול כמה תבניות באמצעות התחביר `|`, הנקרא אופרטור *האיווי* לתבניות. למשל, בקוד הבא אנו מתאימים את הערך של `x` מול זרועות ההתאמה, ובראשונה שבהן מופיע אופצית *או*, שמשמעה שאם הערך של `x` מתאים לאחת מהערכים בזרוע, אז הקוד בזרוע זו יופעל:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}
```

כתוצאה מקוד זה יודפס `one or two`.

### התאמות טווחי ערכים באמצעות `..=`

התחביר `..=` מאפשר להתאים מול טווח אינקלוסיבי של ערכים. בקוד הבא, כאשר תבנית תואמת כל ערך שהוא בטווח הנתון, הזרועה תבוצע:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}
```

אם `x` הוא 1, 2, 3, 4, או 5, הזרוע הראשונה תבוצע. עבור ערכי התאמה מרובים, תחביר זה נוח יותר מהשימוש באופרטור `|` שמבטא את אותו הרעיון; לו היינו משתמשים ב- `|` היה עלינו לציין `1 | 2 | 3 | 4 | 5`. ציון של טווח הוא קצר יותר, ביחוד כאשר רוצים להתאים, נניח, כל מספר בין 1 ל-1000!

הקומפיילר בודק שהטווח אינו ריק, ומשום שהטיפוסים היחידים עבורם ראסט יכול לקבוע אם טווח הוא ריק או לא הם `char` וערכים נומריים, טווחים מותרים לשימוש רק עבור ערכים נומריים וערכי `char`.

הינה דוגמא שמשתשמת בערכי `char`:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}
```

ראסט יכולה לזהות כי `'c'` נמצאת בטווח התבנית הראשונה, ומדפיסה `early
ASCII letter`.

### פירוק ערכים

ניתן גם להשתמש בתבניות כדי לפרק מבנים, מבחרים, ומרצפים כדי להשתמש בחלקים שונים של ערכים אלה. הבה נעבור על אופציות זו אחת אחת.

#### פירוק מבנים

רשימה 18-12 מציגה את המבנה `Point` שלו שני שדות, `x` ו- `y`, שניתן לפרק באמצעות תבנית עם פקודת `let`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-12/src/main.rs}}
```


<span class="caption">רשימה 18-12: פירוק שדות של מבנה למשתנים נפרדים</span>

קוד זה יוצר את המשתנים `a` ו- `b` שתואמים לערכים של השדות `x` ו- `y` של המבנה `p`. דוגמא זו מראה שהשמות של המשתנים בתבנית לא חייבים לתאום את שמות השדות של המבנה. אולם, מקובל כן להתאים את שמות המשתנים לשמות השדות בכדי להקל על זכירת מקור המשתנים. בעקבות שימוש נפוץ זה, וכיוון שכתיבה של קוד מהצורה `let Point { x: x, y: y } = p;` כוללת שכפול רב, ראסט מספקת תחביר מקוצר עבור תבניות שמתאימות שדות של מבנים: צריך לציין ארק את השם של שדה במבנה, ואז השמות של המשתנים שההתאמה לתבנית תיצור יהיו זהים לשמות השדות. רשימה 18-13 מתנהגת באותה צורה כמו הקוד מרשימה 18-12, אבל המשתנים שנוצרים בתבנית ה-`let` הם `x` ו- `y` במקום `a` ו- `b`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-13/src/main.rs}}
```


<span class="caption">רשימה 18-13: פירוק שדות של מבנה באמצעות תחביר מקוצר לשדות</span>

קוד זה יותר את המשתנים `x` ו- `y` שמותאמים לשדות `x` ו-`y` שבמשתנה `p`. התוצאה היא שהמשתנים`x` ו- `y` מכילים את הערכים מהמבנה `p`.

ניתן גם לבצע פירוק עם ערכים מפורשים כחלק מתבנית המבנה במקום ליצור משתנים עבור כל השדות. לעשות כך עוזר לבדוק את הערך של חלק מהשדות מול ערכים ספציפים בזמן שמיצרים משתנים כדי לפרק את השדות האחרים.

ברשימה 18-14, יש לנו ביטוי `match` שמפריד ערכי `Point` לשלושה מקרים: נקודות שנמצאות על ציר ה- `x` (זאת אומרת, כאשר `y = 0`), על ציר ה-`y` (כאשר (`x = 0`), או לא על אף אחד מהצירים.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-14/src/main.rs:here}}
```


<span class="caption">רשימה 18-14: פירוק והתאמה עם ערכים מפורשים בתבנית אחת</span>

הזרוע הראשונה תתאים כל נקודה שנמצאת על ציר ה- `x` על-ידי הדרישה שעל מנת להתאים חובה על השדה `y` להיות שווה לערך המפורש `0`. התבנית עדיין מייצרת את המשתנה `x` בו ניתן להשתמש בקוד של הזרוע הזו.

באופן דומה, הזרוע השניה תתאים כל נקודה על ציר ה- `y` על-ידי הדרישה שכדי שתהיה התאמה, ערך השדה `x` חייב להיות `0`, ונוצר המשתנה `y` עבור הערך בשדה `y`. הזרוע השלישית אינה כוללת ערכים מפורשים, ולכן היא תואמת כל ערך `Point` אחר ויוצרת את המשתנים `x` ו-`y` עבור השדות המקבילים במבנה.

בדוגמא זו, הערך `p` מתאים לזרוע השניה תודות לכך ש-`x` מכיל את הערך 0, ולכן הקוד הזה ידפיס `On the y axis at 7`.

זכרו שביטוי `match` מפסיק לבדוק מול הזרועות שבו ברגע שהוא מצא את התבנית התואמת הראשונה, כך שאפילו ש- `Point { x: 0, y: 0}` נמצאת על ציר ה- `x` וגם על ציר ה- `y`, קוד זה ידפיס אך ורק `On the x axis at 0`.

#### פירוק מבחרים

כבר ביצענו פירוקים של מבחרים בספר זה (למשל, ברשימה 6-5 בפרק 6), אבל לא ערכנו דיון מפורש על כך שתבנית לפירוק מבחר מתאימה לדרך שבה הדאטה שמאוכסן במבחר הוגדר. כדוגמא, רשימה 18-15 משתמשת במבחר `Message` מרשימה 6-2 ומציגה `match` עם תבניות שמפרקות כל ערך פנימי.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-15/src/main.rs}}
```


<span class="caption">רשימה 18-15: פירוק ווריאנטים של מבחר שמאכסנים סוגים שונים של ערכים</span>

קוד זה ידפיס `Change the color to red 0, green 160, and blue 255`. נסו לשנות את הערך של `msg` כדי לראות את תוצאת ריצת הקוד בזרועות האחרות.

עבור ווריאנטים של מבחרים ללא דאטה, כמו `Message::Quit`, לא ניתן להמשיך ולפרק את הערך. כל שאפשר לעשות הוא להתאים מול הערך המפורש `Message::Quit`, ואין משתנים בתבנית הזו.

עבור ווריאנטים של מבחרי דמויי-מבנים, כמו `Message::Move`, ניתן להשתמש בתבנית דומה לתבנית בה השתמשנו עבור התאמות מבנים. אחרי שם הווריאנט, אנו ממקמים סוגריים מסולסלים ואז את רשימת השדות עם המשתנים ובכך מפרקים את הפיסות לשימוש בקוד של הזרוע. כאן אנו משתמשים בצורה המקוצרת, כפי שעשינו ברשימה 18-13.

עבור ווריאנטים של מבחרים דמויי-מרצפים, כמו `Message::Write` שמאכסן מרצף עם אלמנט אחד ו-`Message::ChangeColor` שמאכסן מרצף עם שלושה אלמנטים, התבנית דומה לתבנית בה משתמשים עבור מרצפים. מספר הווריאנטים בתבנית חייב להתאים למספר האלמנטים בווריאנט עליו מתאימים.

#### פירוק מבנים ומבחרים מקוננים

עד כה, הדוגמאות שלנו היו כולן של התאמות מבנים או מבחרים בעומק של רמה אחת, אבל התאמות עובדות גם עם עצמים מקוננים! למשל, ניתן לשכתב את הקוד מרשימה 18-15 כך שיתמוך בצבעים בפורמט RGB ו-HSV בהודעת `ChangeColor`, כמוצג ברשימה 18-16.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-16/src/main.rs}}
```

<span class="caption">רשימה 18-16: התאמות על מבחרים מקוננים</span>

התבנית של הזרוע הראשונה בביטוי ה-`match` מתאימה לווריאנט הבמחר `Message::ChangeColor` שמכילה ווריאנט `Color::Rgb`; התבנית מקשרת לשלות ערכי ה- `i32` הפנימיים. התבנית של הזרוע השניה גם מתאימה לווריאנט המבחר `Message::ChangeColor`, אבל הפעם הערך המותאם הוא מבחר ה- `Color::Hsv` הפנימי. אנו מציינים תנאים מורכבים אלה באמצעות ביטוי `match` יחיד, אפילו שמעורבים כאן שני מבחרים.

#### פירוק מבנים ומרצפים

ניתן לשלב ולקנן תבניות פירוק בדרכים מורכבות עוד יותר. הדוגמא הבאה מראה פירוק מורכב בו אנו מקננים מבנים ומרצפים בתוך מרצף, ומפרקים ממנו את כל הרכיבים היסודיים שבו:

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}
```

קוד זה מאפשר לנו לפרק טיפוסים מורכבים לרכיביהם, וכך יש באפשרותנו להשתמש בערכים המעניינים אותנו בנפרד.

פירוק באמצעות תבניות הוא דרך נוחה לגשת לפיסות של ערכים, כמו הערך של שדה במבנה, ולהפריד אותם לשימושנו.

### התעלמות מערכים בתבנית

כבר ראיתם שלעיתים נוח להתעלם מערכים מסויימים בתבנית, כמו למשל בזרוע האחרונה של `match`, כדי ליצור התנהגות תופסת-כל שלא באמת מבצעת פעולה כלשהיא, אלה רק מטפלת בכל הערכים שלא טופלו בזרועות קודמות. ישנן כמה דרכים להתעלם מערכים, או מחלקי ערכים, בתבנית: שימוש בתבנית `_` (שכבר ראיתם), שימוש בתבנית `_` כחלק מתבנית אחרת, שימוש בשם שמתחיל עם מקף-תחתי, או שימוש ב- `..` כדי להתעלם משארית החלקים בערך מסויים. הבה נבין כיצד ומתי להתשמש בתבניות אלה.

#### התעלמות מלאה מערך באמצעות `_`

כבר השתמשנו במקף-תחתי כתבנית ג'וקר שמתאימה כל ערך אבל לא קושרת אותו. זה שימושי במיוחד בזרוע האחרונה של ביטוי `match`, אבל ניתן לעשות זאת בכל תבנית, כולל בפרמטים של פונקציות, כמוצג ברשימה 18-17.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-17/src/main.rs}}
```

<span class="caption">רשימה 18-17: שימוש ב- `_` בחותם פונקציה</span>

קוד זה יתעלם לחלוטין מהערך `3` שמועבר לפונקציה כארגומנט הראשון, והוא ידפיס `This code only uses the y parameter: 4`.

ברוב המקרים בהם לפונקציה אין צורך באחד הפרמטרים שלה, משנים את חותם הפונקציה כדי להסיר את הפרמטר המיותר. התעלמות מפרמטר של פונקציה יכול להיות יעיל במיחוד במקרים בהם, לדוגמא, אתם מיישמים תכונה, ולכן חייבים להתייחס לחותם הקיים, אבל מימוש גוף הפונקציה שלכם לא משתמש באחד הפרמטרים. מתן שם לפרמט כזה יגרום לקומפיילר לספק אזהרה אודות פרמט שלא בשימוש. התעלמות מהפרמטר, במקרה זה, תעלים את האזהרה.

#### התעלמות מחלקים מערך באמצעות קינון `_`

ניתן גם להשתמש `_` בתוך תבנית אחרת כדי להתעלם רק מחלק זה או אחר של הערך, למשל, כאשר רוצים לגשת רק לחלק אחד בערך ובקוד המשוייך אין צורך בחלקים האחרים. רשימה 18-8 מציגה קוד האחראי על ניהול ערך שעוקב אחר השמה. הדרישות מהקוד הן שהמשתמש לא יוכל לעקוף ערך קיים, אבל כן יוכל לבצע השמה במידה והערך עוד לא הושם.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-18/src/main.rs:here}}
```


<span class="caption">רשימה 18-8: שימוש במקף-תחתי בתוך תבנייות שמתאימות ווריאנטי `Some` כאשר אין צורך לגשת לערך הפנימי ב-`Some`</span>

קוד זה ידפיס `Can't overwrite an existing customized value` ואז `setting is Some(5)`. בזרוע הראשונה, אין צורך להתאים מול, או להשתמש, בערכים הפנימיים של ווריאנטי ה- `Some`, אבל כן צריך לבדוק עבור המקרה ש-`setting_value` ו-`new_setting_value` הם ווריאנטים של `Some`. במקרה זה אנו מדפיסים את הסיבה לכך ש-`setting_value` לא עובר שינוי.

בכל המקרים האחרים (דהיינו אם לפחות אחד מ-`setting_value` ו-`new_setting_value` הוא הערך `None`) המבוטאים על-ידי התבנית `_` בזרוע השניה, אנחנו רוצים ש-`new_setting_value` יקבל את הערך `setting_value`.

ניתן גם להשתמש במקף-תחתי בכמה מקומות בו-זמנית בתוך תבנית אחת כדי להתעלם מערכים מסויימים. רשימה 18-19 מציגה דוגמא להתעלמות מהערך השני והרביעי במרצף בן חמישה אלמנטים.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-19/src/main.rs:here}}
```

<span class="caption">רשימה 18-19: התעלמות מכמה חלקים של מרצף</span>

קוד זה ידפיס `Some numbers: 2, 8, 32`, בעודו מתעלם מהערכים 4 ו-16.

#### התעלמות ממשתנים שלא בשימוש על-ידי התחלת שמם עם `_`

אם תיצרו משתמש אבל לא תשתמשו בו, ראסט בדרך-כלל תספק אזהרה, שכן משתמש שאינו בשימוש עלול להיות באג. אבל, לעיתים דווקא נוח להיות מסוגלים ליצור משתמש ולא להשתמש בו עדיין, למשל בזמן יצירת פרוטוטייפ או בשלבים הראשונים של פרוייקט. במקרה כזה, ניתן לאמר לראסט לא להזהיר אודות משתנה מסויים שאינו בשימוש על-ידי התחלת שמו של המשתנה עם מקף-תחתי. ברשימה 18-20, אנו יוצרים שני משתנים שאינם בשימוש, אבל כאשר מקמפלים את הקוד, נקבל הודעת אזהרה רק בקשר לאחד מהם.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-20/src/main.rs}}
```


<span class="caption">רשימה 18-20: התחלת שם משתנה עם מקף-תחתי בכדי להימנע מקבלת אזהרות אודות משתנים שאינם בשימוש</span>

כאן אנחנו מקבלים הודעה על כך שלא נעשה שימוש במשתנה `y`, אבל אנחנו לא מקבלים אזהרה בקשר לאי-שימוש ב-`_x`.

שימו לב שיש הבדל עדין בין שימוש ב-`_` לבין שימוש בשם שמתחיל במקף-תחתי. התחביר `_x` עדיין קושר את הערך למשתנה, בעוד ש- `_` לא מבצע שום קישור. כדי להראות מקרה בו אבחנה זו חשובה, רשימה 18-21 מספקת שגיאה.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-21/src/main.rs:here}}
```


<span class="caption">רשימה 18-21: משתנה שאינו בשימוש ששמו מתחיל עם מקף-תחתי עדיין מקושר לערך, וכך עשוי לקחת בעלות על הערך</span>

נקבל כאן הודעת שגיאה כיוון שהערך `s` עדיין מועבר לתוך `_s`, וזה מונע מאיתנו מלהשתמש ב-`s` שוב. אולם, שימוש במקף-תחתי בפני עצמו לא מקושר לערך. רשימה 18-22 תעבור קומפילציה ללא שגיאות משום ש- `s` לא מועבר ל-`_`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-22/src/main.rs:here}}
```


<span class="caption">רשימה 18-22: שימוש במקף-תחתי לא מקשר לערך</span>

קוד זה עובד מצויין כי הערך `s` לא נקשר לשום דבר; הוא כלל לא מוזז.

#### התעלמות מחלקים נותרים של ערך באמצעות `..`

עבור ערכים שמורכבים מכמה רכיבים, ניתן להשתמש בתחביר `..` כדי להשתמש בחלקים מסויימים ולהתעלם מהשאר, תוך הימנעות מהצורך לספק רשימה של מקפים-תחתיים לכל ערך ממנו אנו מעוניינים להתעלם. התבנית `..` מתעלמת מכל חלק של ערך שלא הותאם מפורשות בשאר התבנית. ברשימה 18-23, יש לנו את המבנה `Point` שמאכסן קואורדינטות במרחב תלת-ממדי. בביטוי ה-`match`, אנחנו רוצים לפעול רק על קואורדינטת ה-`x` ולהתעלם מהערכים בשדות `y` ו-`z`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-23/src/main.rs:here}}
```


<span class="caption">רשימה 18-23: התעלמות מכל השדות של `Point` חוץ מהשדה `x` באמצעות `..`</span>

אנו רושמים את הערך `x`, מוסיפים את התבנית `..`, וזהו. זה מהיר יותר מאשר להצטרך לרשום `y: _` and `z: _`, בעיקר כאשר עובדים עם מבנים שיש להם שדות רבים בעוד אנו מתעניינים רק באחד או שניים מהם.

התחביר `..` יכסה כל כמות של ערכים שצריך. רשימה 18-24 מציגה כיצד להשתמש ב- `..` עובר מרצף.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-24/src/main.rs}}
```


<span class="caption">רשימה 18-24: התאמה של האלמנטים הראשון והאחרון במרצף, והתעלמות בכל שאר הערכים</span>

בקוד זה, שני ערכים, הראשון והאחרון, מותאמים עם `first` ו-`last`. ה-`..` תותאם ותתעלם מכל הערכים שבאמצע.

אולם, שימוש ב-`..` חייב להיות חד-משמעי. במידה ויש חוסר בהירות מהם הערכים הרצויים ומאלו יש להתעלם, ראסט תספק שגיאה. רשימה 18-25 מראה דוגמא לשימוש ארטילעי ב-`..`, ולכן קוד זה לא יעבור קומפילציה.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-25/src/main.rs}}
```


<span class="caption">רשימה 18-25: ניסיון לשימוש ב-`..` בצורה שאינה חד-משמעית</span>

כאשר מקמפלים דוגמא זו, מקבלים את השגיאה:

```console
{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}
```

ראסט לא יכולה לקבוע מכמה משתנים במרצף להתעלם לפני שיותאם ערך למשתנה `second` ואז מכמה ערכים נוספים להתעלם אחר-כך. קוד זה יכול להתכוון להתעלם מ- `2`, לקשור את `second` ל- `4`, ואז להתעלם מ- `8`, `16`, ו- `32`; או דווקא להתעלם מ-`2` ומ `4`, לקשור את `second` ל-`8`, ואז להתעלם מ-`16` ומ- `32`. ויש, כמובן, עוד פירושים אפשריים אחרים. העובדה ששם המשתנה הוא `second` אינה מציינת דבר לראסט, ולכן מקבלים שגיאת קומפילציה `..` בשני מקומות בצורה זו אינו ניתן לפירוש חד-משמעי.

### התניות נוספות באמצעות מגני התאמות

*מגן התאמה* (match guard) הוא תנאי `if` נוסף, המצויין אחרי התבנית בזרוע של `match`, וכדי שהזרוע תיבחר גם תנאי זה חייב להתקיים. מגני התאמה הם שימושיים עבור ביטויים מורכבים יותר משתבנית לבדה יכולה לבטא.

התנאי יכול להשתמש במשתנים שנוצרו בתבנית. רשימה 18-26 מציגה ביטוי `match` בו בזרוע הראשונה יש את התבנית `Some(x)` וגם את מגן ההתאמה `if x % 2 == 0` (שמתקיים אם המספר זוגי).

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-26/src/main.rs:here}}
```

<span class="caption">רשימה 18-26: הוספת מגן התאמה לתבנית</span>

דוגמא זו תדפיס `The number 4 is even`. כאשר `num` מושווה לתבנית בזרוע הראשונה, הוא מתאים כיוון ש-`Some(4)` מתאים ל-`Some(x)`. בשלב זה, מגן ההתאמה בודק אם השארית בחלוקה של `x` ב-2 שווה ל-0, וכיוון שאכן זה המצב, הזרוע הראשונה מתבצעת.

אם, במקום זאת, `num` היה שווה לערך `Some(5)`, מגן ההתאמה בזרוע הראשונה לא היה מתקיים כיוון שהשארית בחלוקת 5 ב-2 היא 1, ולא 0. ראסט תמשיך אז לזרוע השניה, וזו כן מתאימה היות ובזרוע השניה אין מגן התאמה ולכן מתאימה לכל ווריאנט של `Some`.

אין דרך לבטא את התנאי `if x % 2 == 0` כחלק מהתבנית. מגן ההתאמה מאפשר לנו יכולת ביטוי לוגית עשירה יותר. החיסרון שמגיע עם שיפור יכולת הביטוי הזו הוא שהקומפיילר לא מנסה לבדוק שכל הערכים ממוצים ברגע שמעורבים מגני התאמות.

ברשימה 18-11 הערנו שיכולנו להשתמש במגני התאמות כדי לפתור את בעיית האפלת התבנית. זכרו שיצרנו משתנה חדש בתוך התבנית בביטוי ה-`match` במקום להשתמש במשתנה מחוץ ל-`match`. משתנה חדש זה גרם לכך שלא יכולנו לבדוק כנגד הערך של המשתנה החיצוני. רשימה 18-27 מראה כיצד ניתן להשתמש במגן התאמה כדי לפתור את הבעיה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-27/src/main.rs}}
```


<span class="caption">רשימה 18-27: שימוש במגן התאמה כדי לבדוק שוויון עם משתנה חיצוני</span>

כעת, קוד זה ידפיס `Default case, x = Some(5)`. התבנית בזרוע השניה לא מכריזה על משתנה חדש `y` שמאפיל על המשתנה החיצוני `y`, ולכן ניתן להשתמש ב-`y` החיצוני במגן ההתאמה. במקום לציין את התבנית כ-`Some(y)`, שהיה גורם להאפלה של ה-`y` החיצוני, אנו רושמים `Some(n)`. בכך אנו יוצרים משתנה חדש `n` שלא מאפיל על כלום משום שאין משתנה בשם `n` מחוץ ל-`match`.

מגן ההתאמה `if n == y` אינו תבנית ולכן לא מכריז על משתנים חדשים. ה-`y` הזה *הוא* ה-`y` החיצוני, והוא אינו משתנה חדש, ולכן ההשוואה בין `n` ל- `y` משיגה את מטרה.

ניתן גם להשתמש באופרטור `|`, המייצג את הפעול הלוגית *או*, במגן התאמה כדי לציין כמה תבניות; מגן ההתאמה יהיה תקף עבור על התבניות. רשימה 18-28 מציגה את חוקי הקדימות כאשר משלבים מגן התאמה עם תבנית שכוללת `|`. החלק החשוב בדוגמא זו הוא שמגן ההתאמה `if y` תקף ל-`4`, `5`, *וגם* ל-`6`, אפילו שיכול להראות כאילו `if y` תקף רק ל-`6`.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-28/src/main.rs:here}}
```


<span class="caption">רשימה 18-28: שילוב ריבוי תבניות עם מגן התאמה</span>

תנאי ההתאמה מציין שהזרוע תותאם רק אם הערך של `x` שווה ל-`4`, `5`, או `6` *וגם* אם `y` הוא `true`. כאשר קוד זה רץ, התבנית של הזרוע הראשונה מתאימה כיוון ש-`x` הוא `4`, אבל מגן ההתאמה `if y` הוא <0>false</0>, ולכן הזרוע הראשונה לא מתבצעת. הקוד עובר הלאה לזרוע השניה, שכן מתאימה, והתכנית מדפיסה `no`. הסיבה היא שתנאי ה-`if` תקף לכל התבנית `4 | 5 | 6`, ולא רק לערך האחרון `6`. במילים אחרות, הקדימות של מגן התאמה ביחס לתבנית מתנהג כך:

```text
(4 | 5 | 6) if y => ...
```

ולא כך:

```text
4 | 5 | (6 if y) => ...
```

לאחר הרצת הקוד, התנהגות הקדימות מובנת מעליה: אם מגן ההתאמה היה תקף רק לערך האחרון ברשימת הערכים עם האופרטור `|`, אז הזרוע היתה מתאימה והתכנית היתה מדפיסה `yes`.

### `@` קישורים

האופרטור `@` נקרא *at* והוא מאפשר ליצור משתנה שמאכסן ערך באותו הזמן בו בודקים אם הערך מתאים לתבנית. ברשימה 18-29 אנו רוצים לבדוק שהשדה `Message::Hello` `id` נמצא בטווח `3..=7`. אנחנו גם מעוניינים לקשור את הערך למשתנה `id_variable` כדי שנוכל להשתמש בו בקוד המשוייך לזרוע. היינו יכולים לקרוא למשתנה הזה `id`, כמו שם השדה, אבל בדוגמא זו אנו משתמשים בשם אחר.

```rust
{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-29/src/main.rs:here}}
```


<span class="caption">רשימה 18-29: שימוש ב-`@` כדי לקשור לערך בתבנית בזמן בדיקת התאמה</span>

דוגמא זו תדפיס `Found an id in range: 5`. על-ידי ציון `id_variable @` לפני הטווח `3..=7`, אנו תופסים את הערך שמותאם לטווח באותו הזמן בו אנו בודקים את ההתאמה לטווח.

בזרוע השניה, שם יש רק ציון של טווח בתבנית, לקוד המשוייך לזרוע אין משתנה שמכיל את הערך עצמו של השדה `id`. ערך השדה `id` יכול להיות 10, 11, או 12, אבל לקוד המשוייך לזרוע אין גישה לערך עצמו. הקוד המשוייך כאן לא יכול לגשת אל הערך של השדה `id`, משום שלא שמרנו את הערך הזה למשתנה.

בזרוע האחרונה, שם מצויין משתנה ללא טווח, לקוד המשוייך כן יש את הערך עצמו מוכן לשימוש במשתנה בשם `id`. הסיבה היא שהשתמשנו כאן בתחביר המקוצר עבור שדות במבנים. אבל בזרוע הזו לא הוספנו שום תנאי על הערך בשדה `id`, כפי שעשינו בשתי הזרועות הראשונות: כל ערך יתאים לתבנית זו.

שימוש ב-`@` מאפשר לנו לבדוק ערך ולשמור אותו במשתנה כחלק מתבנית אחת.

## סיכום

תבניות בראסט הן כלי מאוד יעיל לאבחנה בין סוגים שונים של דאטה. כשמשתמשים בהן בביטויי `match`, ראסט מוודאת שהתבניות מכסות את כל הערכים האפשריים, ואם לא אז התכנית לא לעבור קומפילציה. תבניות בפקודות `let` ובפרמטרים של פונקציות הופכות בניות אלה ליותר שימושיות שכן הן מאפשרות לפרק את הערכים לפיסות קטנות יותר באותו הזמן שההשמה מתבצעת. ניתן ליצור תבניות פשוטות או מורכבות, בהתאם לצורך.

בצעד הבא, עבור הפרק הלפני אחרון של הספר, נתבונן באספקטים מתקדמים של מכלול של תכונות של ראסט.
