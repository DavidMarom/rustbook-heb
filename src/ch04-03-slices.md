## טיפוס החיתוך

*חיתוכים* מאפשרים להפנות לשורה רציפה של אלמנטים באוסף, ולא בהכרח לאוסף כולו. חיתוך הוא סוג של הפניה, ולכן אין לו בעלות על הדאטה.

הינה בעיית תכנות קטנה: כתבו פונקציה שמקבלת מחרוזת של מילים מופרדות ע"י רווחים, ומחזירה את המילה הראשונה שהיא מוצאת במחרוזת. אם הפונקציה לא מוצאת תו רווח במחרוזת, אז כל המחרוזת היא מילה בודדת, ולכן יש להחזיר את כל המחרוזת.

הבה נעקוב אחר אופן כתיבת חותם הפונקציה ללא שימוש בחיתוכים, על מנת להבין את הבעיה שחיתוכים פותרים:

```rust,ignore
fn first_word(s: &String) -> ?
```

לפונקציה `first_word` יש `&String` כפרמטר. אנחנו לא רוצים בעלות, ולכן זה בסדר. אבל, מה עלינו להחזיר? אין לנו דרך של ממש לדבר על *חלק* ממחרוזת. אבל, נוכל להחזיר את האינדקס של סוף המילה, המצויינת ע"י רווח. הבה ננסה זאת, כמוצג ברשימה 4-7.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}
```


<span class="caption">רשימה 4-7: הפונקציה `first_word` שמחזירה ערך אינדקס מסוג בייט לפרמטר ה- `String` שלה</span>

כיוון שאנחנו צריכים לעבור ה- `String` תו אחר תו ולבדוק האם הערך הוא רווח, נמיר את ה- `String` שלנו למערך של בייטים באמצעות המתודה `as_bytes`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}
```

אח"כ, אנחנו יוצרים איטרטור על המערך של הבייטים באמצעות המתודה `iter`:

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}
```

באיטרטורים נדון בפירוט [בפרק 13][ch13]<!-- ignore -->. לעכשיו, כל שצריך לדעת הוא ש-`iter` היא מתודה שמחזירה כל אלמנט באוסף וש-`enumerate` עוטפת את התוצאה מה-`iter` ומחזירה כל אלמנט כחלק מרצף באורך 2. האיבר הראשון של הרצף שמוחזר מ-`enumerate` הוא האינדקס, והאבר השני הוא הפניה לאלמנט עצמו. מצב זה קצת יותר נוח מלחשב את האינדקס בעצמנו.

מכיוון שהמתודה `enumerate` מחזירה רצף, ניתן להשתמש בדפוסים כדי לפרק את הרצף. אנו נדון יותר בדפוסים [בפרק 6][ch6]<!-- ignore -->. בלולאת ה- `for` אנחנו מספקים דפוס שמשתמש ב-`i` עבור האינדקס ברצף וב-`&item` עבור הבייט הבודד ברצף. בגלל שאנחנו מקבלים הפניה לאלמנט מ-`.iter().enumerate()`, אנחנו משתמשים ב-`&` בדפוס.

בתוך לולאת ה-`for` אנחנו מחפשים אחר הבייט שמייצג תו רווח ע"י שימוש בתחביר של בייטים מפורשים. במידה ואחנו מוצאים רווח, אנחנו מחזירים את המיקום. אחרת, אנחנו מחזירים את האורך של המחרוזת ע"י שימוש ב- `s.len()`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}
```

בשלב זה יש בידינו דרך למצוא את האינדקס של סוף המילה הראשונה במחרוזת, אבל יש כאן בעיה. אנחנו מחזירים `usize` בלבד, בעוד הערך הוא מספר בעל משמעות רק בהקשר של ה-`&String`. במילים אחרות, כיוון שזה ערך נפרד מה- `String`, אין שום ערובה שהערך עדיין יהיה תקף בעתיד. קחו למשל את התכנית ברשימה 4-8, שמשתמש בפונקציה `first_word` מרשימה 4-7.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}
```


<span class="caption">רשימה 4-8: אכסון התוצאה מהקריאה לפונקציה `first_word` ואז שינוי התוכן של ה- `String`</span>

תוכנית זו עוברת קומפילציה ללא שגיאות, ותמשיך לעבור קומפילציה גם אם היינו משתמשים ב- `word` לאחר הקריאה ל- `s.clear()`. היות ו-`word` כלל לא קשור למצב של `s`, המשתנה `word` עדיין מאכסן את הערך `5`. היינו יכולים להשתמש בערך `5` עם המשתנה `s` כדי לנסות להוציא את המילה הראשונה, אבל זה יהיה באג משום שהתוכן של `s` עבר שינוי מאז ששמרנו את הערך `5` ב- `word`.

הצורך לדאוג שמה האינדקס ב-`word` יצא מסינכרון עם הדאטה ב-`s` הוא מייגע ומועד לטעויות! ניהול אינדקסים אלה הוא אפילו עוד יותר שברירי אם כותבים פונקציה כמו `second_word`. החותם שלה יהיה צריך להראות כך:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

כאת אנו עוקבים אחר אינדקס התחלה *וגם* אינדקס סיום, ואז יש לנו אפילו עוד ערכים שחושבו מדאטה שמנצא במצב מאוד ספציפי, אבל הם לא קשורים למצב כלל. יש לנו שלושה משתנים לא קשורים שצפים להם באיזור, ויש לשמור אותם מסונכרנים.

למרבה המזל, לראסט יש פתרון לבעיה זו: חיתוכי מחרוזות.

### חיתוכי מחרוזות

*חיתוך מחרוזת* הינו הפניה לחלק מ-`String`, והוא נראה כמו:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}
```

במקום הפניה לכל ה-`String`, המשתנה `hello` הוא הפניה לחלק מה- `String`, החלק שנקבע ע"י `[0..5]`. אנחנו יוצרים חיתוכים תוך שימוש בטווח בתוך סוגריים מרובעים מהצורה `[starting_index..ending_index]`, כאשר `starting_index` הוא המיקום של תחילת החיתוך ו- `ending_index` הוא אחד יותר מהמיקום של סוף החיתוך. החיתוך, כמבנה נתונים, מאכסן את מיקום ההתחלה ואת האורך של החיתוך, שהוא שווה ל-`ending_index` פחות `starting_index`. לכן, במקרה של `let world = &s[6..11];`, המשתנה `world` הוא חיתוך שמכיל מצביע לבייט באינדקס 6 של `s` עם אורך `5`.

תמונה 4-6 מראה זאת בדיאגרמה.

<img alt="Three tables: a table representing the stack data of s, which points
to the byte at index 0 in a table of the string data &quot;hello world&quot; on
the heap. The third table rep-resents the stack data of the slice world, which
has a length value of 5 and points to byte 6 of the heap data table."
src="img/trpl04-06.svg" class="center" style="width: 50%;" />

<span class="caption">תמונה 4-6: חיתוך מחרוזת המפנה לחלק מ-`String`</span>

עם תחביר הטווח `..` של ראסט, אם רוצים להתחיל במיקום שבאינדקס 0, ניתן להשמיט את הערך שלפני שתי הנקודות. במילים אחרות, הביטויים הבאים שקולים:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

לפי אותו עקרון, אם החיתוך כולל את הבייט האחרון של ה-`String`, ניתן להשמיט את המספר שאחרי שתי הנקודות. משמע ששני הביטויים הבאים שקולים גם הם:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

ניתן גם להשמיט את שני המספרים בכדי ליצור חיתוך של המחרוזת כולה. אם כן, שני הביטויים הבאים שקולים אף הם:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> הערה: אינדקסים לחיתוכי מחרוזות חייבים להיות במיקומים במחרוזת שבדיוק בין תווי UTF-8. אם תנסו ליצור חיתוך מחרוזת באמצע תו שאורכו יותר מבייט אחד, אז התכנית תעצור ותודיע על שגיאה. למטרת הצגת הרעיון של חיתוכי מחרוזות אנחנו מניחים, בסעיף זה, תווי ASCII בלבד. דיון רחב יותר בדבר טיפול בתווי UTF-8 נמצא בסעיף ["אכסון באמצעות מחרוזות של טקסט בקידוד UTF-8"][strings]<!-- ignore --> בפרק 8.

עכשיו, עם כל המידע שברשותנו, הבה נשכתב את הפונקציה `first_word` כך שתחזיר חיתוך. הטיפוס המייצג "חיתוך מחרוזת" הוא `&str`:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}
```

אנחנו מוצאים את האינדקס של סוף המילה באותה דרך בה פעלנו ברשימה 4-7, ע"י חיפוש אחר המופע הראשון של תו רווח. כאשר אנו מוצאים רווח, אנחנו מחזירים חיתוך תוך שימוש בתחילת המחרוזת והאינדקס של תו הרווח שמצאנו בתור תחילת וסיום החיתוך, בהתאמה.

עכשיו, כאשר אנחנו קוראים ל-`first_word`, אנחנו מקבלים חזרה ערך יחיד שקשור הדוקות לדאטה הרלוונטי. הערך מורכב מהפניה לתחילת החיתוך וממספר האלמנטים בחיתוך.

החזרת טיפוס חיתוך תעבוד גם עבור הפונקציה `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

כעת יש לנו API פשוט והרבה יותר קשה להשתמש בו בצורה לא בטוחה כיוון שהקומפיילר יוודא שההפניה לתוך ה-`String` נשארת תקפה. זוכרים את הבאג מהתכנית ברשימה 4-8, כאשר קיבלנו את האינדקס לסוף המילה הראשונה אבל אז רוקנו את המחרוזת ובכך האינדקס איבד את תוקפו? הקוד ההוא היה שגוי מבחינה לוגית, אבל לא יצר שגיאות מיידיות. הבעיה היתה צצה בשלב מאוחר יותר במידה והיינו משתמשים באינדקס למילה הראשונה לאחר ריקון המחרוזת. חיתוכים הופכים באג זה לבלתי אפשרי ומיידעים אותנו בדבר קיום הבעיה מוקדם הרבה יותר. שימוש בגרסת החיתוך של `first_word` תגרום לשגיאת זמן-קומפילציה:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}
```

הינה השגאיה מהקומפיילר:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt}}
```

זכרו מכללי הבעלות שאם יש לנו הפניה מנועת-שינוי לדאטה, אז לא ניתן ליצור גם הפניה ברת-שינוי באותו זמן. בגלל ש-`clear` צריכה לקטום את ה-`String`, היא צריכה לקבל הפניה ברת-שינוי. הפקודה `println!` שלאחר הקריאה ל- `clear` משתמשת בהפניה ב-`word`, ולכן ההפניה מנועת-השינוי חייבת עדיין להיות פעילה בנקודה זו. ראסט לא מאפשרת להפניה ברת-השינוי ב- `clear` ולהפניה מנועת-השינוי ב-`word` מלהתקיים בו-זמנית, והקומפילציה נכשלת. לא רק שראסט הפכה את ה-API קל לשימוש, היא גם חיסלה, בזמן הקומפילציה, מחלקה שלמה של שגיאות!

<!-- Old heading. Do not remove or links may break. -->
<a id="string-literals-are-slices"></a>

#### מחרוזות מפורשות כחיתוכים

זכרו שדיברנו על איך שמחרוזות מפורשות מאוכסנות בקובץ הבינארי. כעת משאנחנו מכירים חיתוכים, נוכל להבין נכונה מחרוזות מפורשות:

```rust
let s = "Hello, world!";
```

הטיפוס של `s` כאן הוא `&str`: זהו חיתוך המצביע למיקום ספציפי זה בקובץ הבינארי. זו גם הסיבה שמחרוזות מפורשות הן מנועות-שינוי; `&str` היא הפניה מנועת-שינוי.

#### חיתוכי מחרוזות כפרמטרים

עכשיו כשאנו יודעים לעבוד עם חיתוכים של מחרוזות מפורשות ושל ערכי `String`, נוכל לבצע עוד שיפור אחד של `first_word`, בחותם הפונקציה:

```rust,ignore
fn first_word(s: &String) -> &str {
```

ראסטיונר מנוסה יותר יכתוב את החותם המופיע ברשימה 4-9 משום שזה יאפשר להשתמש באותה פונקציה גם על ערכי `&String` וגם על ערכי `&str`.

```rust,ignore
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:here}}
```


<span class="caption">רשימה 4-9: שיפור הפונקציה `first_word` ע"י שימוש בחיתוך מחרוזת עבור הטיפוס של הפרמטר `s`</span>

אם יש לנו חיתוך מחרוזת, נוכל להעביר אותו ישירות. אם יש לנו `String`, נוכל להעביר חיתוך של ה- `String` או הפניה אל ה-`String`. גמישות זו עושה שימוש *בכפיית דירף*, תכונה עליה נדבר בסעיף ["כפיות דירף מפורשות עם פונקציות ומתודות"][deref-coercions]<!--ignore--> בפרק 15.

הגדרת פונקציה לקבל חיתוך מחרוזת במקום הפניה ל-`String` הופכת את ה-API שלנו לכללי ושמיש יותר, ללא איבוד פונקציונאליות:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-09/src/main.rs:usage}}
```

### חיתוכים אחרים

חיתוכי מחרוזות, כפי שוודאי תוכלו לנחש, הם ספציפיים למחרוזות. אבל יש גם טיפוס חיתוך כללי יותר. התבוננו במערך הזה:

```rust
let a = [1, 2, 3, 4, 5];
```

בדיוק כפי שניתן להפנות לחלק ממחרוזת, ניתן גם להפנות לחלק ממערך. נעשה זאת כך:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

חיתוך זה הוא מטיפוס `&[i32]`. הוא עובד באותה הצורה כמו חיתוכי מחרוזות, ע"י אכסון הפניה לאלמנט הראשון, ובתוספת אורך. משתמשים בסוג זה של חיתוכים עבור אוספים מגוונים. אנו נדון באוספים אלה בפירוט כשנדבר על ווקטורים בפרק 8.

## סיכום

המושגים של בעלות, השאלה, וחיתוכים מוודאים, בזמן הקומפילציה, שימוש בטוח בזיכרון בתכניות ראסט. השפה ראסט מקנה לכם שליטה על השימוש בזיכרון באותה דרך בה שפות אחרות ברמת המערכת עושות זאת, אבל העובדה שמשתנה לו יש בעלות על דאטה משחרר אותו ברגע שהוא יוצא מהמתחם חוסך לכם את הצורך לכתוב תוספת קוד, ולרדוף אחר באגים, כדי להשיג שליטה זו.

לבעלות יש השפעה על דרך עבודתם של חלקים אחרים של ראסט, כפי שנראה במהלך הספר. הבה נעבור לפרק 5 ונראה כיצד לאגד פיסות דאטה יחדיו באמצעות `struct`.

[ch13]: ch13-02-iterators.html
[ch6]: ch06-02-match.html#patterns-that-bind-to-values
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
[deref-coercions]: ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods
